<doc>
  <source auto="true" type="str" verify="true"><![CDATA[https://cyberleninka.ru/article/n/model-anomalnogo-povedeniya-sistemy-na-osnove-veroyatnostnyh-suffiksnyh-dereviev]]></source>
  <category auto="true" type="str" verify="true"><![CDATA[Автоматика]]></category>
  <author auto="true" type="list" verify="true">
    <item type="str"><![CDATA[Абрамов Георгий Эдуардович]]></item>
  </author>
  <title auto="true" type="str" verify="true"><![CDATA[Модель аномального поведения системы на основе вероятностных суффиксных деревьев]]></title>
  <keywords auto="true" type="list" verify="true">
    <item type="str"><![CDATA[ВЕРОЯТНОСТНОЕ СУФФИКСНОЕ ДЕРЕВО]]></item>
    <item type="str"><![CDATA[ОБНАРУЖЕНИЕ АНОМАЛЬНОГО ПОВЕДЕНИЯ]]></item>
  </keywords>
  <annotation auto="true" type="str" verify="true"><![CDATA[Описывается метод применения вероятностных суффиксных деревьев для обнаружения аномального поведения программ. Используется «отпечаток» нормального поведения приложений с целью в дальнейшем обнаружить аномальное поведение как нечто, отклоняющееся от модели. В качестве основной модели используется вероятностные суффиксные деревья.]]></annotation>
  <text auto="true" type="str" verify="true"><![CDATA[Описывается метод применения вероятностных суффиксных деревьев для обнаружения аномального поведения программ. Используется «отпечаток» нормального поведения приложении с целью в дальнейшем обнаружить аномальное поведение как нечто, отклоняющееся от модели. В качестве основной модели используется вероятностные суффиксные деревья. Вероятностное суффиксное дерево; РБТ, обнаружение аномального . G.E. Abramov MODEL OF THE ANOMALOUS BEHAVIOR OF THE SYSTEM BASED ON PROBABILISTIC SUFFIX TREES Described the method of probabilistic suffix trees for detecting anomalous behavior ofprograms. Use "fingerprint" of the normal behavior of applications in order to further detect anomalous behavior as something deviating from the model. As a basic model uses a probabilistic suffix trees. Probabilistic suffix tree; PST; detection of abnormal behavior. Классификация активности приложений на основе вероятностных суффиксных деревьев Целью исследований является нейтрализация злонамеренного поведения программ. Будем стремиться получить «отпечаток» нормального поведения приложений с целью в дальнейшем обнаружить аномальное поведение как нечто, отклоняющееся от модели. В качестве основной модели будем использовать вероятностное суффиксное дерево (probabilistic suffix tree, PST), разработанное D. Ron [1]. Эта модель допускает эффективное использование информации высокого порядка, такой, как системные вызовы. Вероятностное суффиксное дерево (probabilistic suffix tree, PST), описанное в [1], это n-арное дерево, в котором узлы организованы так, что корневой узел представляет безусловную вероятность каждого символа в алфавите, в то время как узлы на следующих уровнях представляют вероятности возникновения следующего символа при условии, что уже наблюдалась комбинация одного или большего числа символов (т.е. при наличии истории). Вероятности - это относительные , . PST , , PST k k+1 . , . 1 PST , образца «2 1 1 3 1 3 1 3 3 4», где символы «2» и «4» однозначно используются как начало и конец строки. Начиная с корневого узла, который представляет пустую строку, каждый узел является суффиксом всех своих потомков, поэтому модель получила название . , , -ственным суффиксом всех единичных символов. Числа в круглых скобках, расположенные рядом с узлами, являются условными вероятностями следующих символов, за исключением того, что распределение вероятностей следующих символов для корневого узла имеет вероятность, , «4», следующих символов в обучающем примере. Необходимо также отметить, что переходы к следующему символу осуществляются от одной ветки к другой, а не от родительского узла к потомку, вследствие формата суффикса узла. Ниже представлен рекурсивный алгоритм для построения дерева. Пример для построения сканируется для определения вероятности каждого символа. Каждый символ с ненулевой вероятностью становится потомком корневого символа, и для каждого такого узла пример пересканируется для определения распределения вероятностей следующих символов. Это может создать новые листья и добавить но-PST. 2 1 1 3 1 3 1 З 3 4 Числовой набор Рис. 1. Пример построения PST Построение рекурсивно добавляет дополнительные уровни путем проверки каждого текущего листа для определения, могут ли быть созданы новые листья среди потомков данного узла. Информация о символах, предшествующих данному , , информации потомков данного узла. , , , , -деление вероятности следующего символа. Многие ветви отмирают прежде, чем распространяются до максимума глубины. Глубина (то есть порядок) дерева может быть установлена в максимальное , , . Для каждого узла дерева память должна выделяться динамически. Далее рекурсивный восходящий процесс усечения должен удалить ветви, которые предоставляют ту же информацию, что и родительские узлы. Удаление этих узлов «анадогичных родительским» снижает избыточность в структуре дерева и , . . 1 показывают отсеченные узлы и соответствующие ветви. Отсечение базируется на вероятностной информации. Главная роль PST в нашем случае - это стохастическое представление обучающих данных в древовидной структуре. Несколько PST, потенциально представляющих разные или подобные обучающие примеры, могут быть слиты в одно , -дивидуальных обучающих последовательностей. Эта операция позволяет прово- PST - PST. - , , PST, - тавляют ту же стохастическую информацию, как и их предки. Алгоритмы построения PST Существует алгоритм для реконструкции вероятностной информации следующих символов для удаленных узлов и, таким образом, реконструкции или за-PST. - тических операций с PST, таких как сравнение двух деревьев. Есть несколько ва- PST степени похожести или непохожести между PST [2]. Основываясь на изложенной выше информации, приведём далее алгоритм PST. 1. . 2. , для определения вероятности следующего символа. 3. , - . , - . 4. , - гут появиться как дети потомков самих себя. 5. , , , -. 6. ( ) по умолчанию равна длине входного исходного образца. 7. , статистическую информацию (вероятности), как и их родители. Этим устраняется избыточность структуры дерева. Можно записать алгоритм при помощи псевдоязыка: Построение ПСТ Если (тек.глубина=макс. глубина), то выход из рекурсии Вызов Заполнение списка префиксов Для I от 0 до Макс_число_знаков_адфавита Если (префикс(1)опустой^к^атель) Коне ц_списка-> правы й_брат = префикс® T = (I) Если нет Текущий узел->левый_сын = префикс® T = префикс® Заполнение списка префиксов I 0 _ _ _ (I) = _ I 1 _ - _ _ =0 , _ , , создаём его Если существует, узел->вероятность[символ_постфикс]+=1.0 Нормализаиия вероятностей (что означает нормализация) I 0 _ _ _ Если узел существует Для J от 0 до Макс_число_знаков_адфавита Tsum += узел->вероятностьУ) Для J от 0 до Макс_число_знаков_адфавита узел->вероятностьУ) /= Tsum Найти ближайший шел = , -> = 0 T = найти_ближайший узел (узел->сын, суффикс, длина суффикса) Иначе Пока узел <> пустой указатель -> (0)=c ( - -> ) выход из цикла Узел = узел->брат Если узел = пустой указатель, вернуть пустой указатель Иначе если Узел->уровень = размер суффикса вернуть узел Иначе T = найти ближайший узел (узел->сын, суффикс, размер суффикса) Если t = пустой указатель вернуть узел иначе вернуть T Алгоритмы сравнения PST Для использования суффиксных деревьев в задачах обнаружения атак необходимо иметь механизм сравнения различных PST. В этом случае процедура сравнения просматривает образец с использованием PST, для того чтобы вычислить кумулятивную вероятность возникновения символов в образце. Для сравнения образцов с использованием PST начинаем с первого символа и смотрим на корневой узел, чтобы определить вероятность возникновения данного символа. Затем продолжаем просматривать последовательность, добавляя следующий символ к предшествующему, получая таким образом новую метку. Далее необходимо найти узел, основанный на вновь созданной метке, исключая последний символ. Например, если мы пытаемся найти "1 3 2", мы пытаемся найти узел "1 3", поскольку он содержит вероятность "2", возникающую после этого. Если узел не существует, мы удаляем один символ с внешней стороны узловой метки до тех пор, пока мы не столкнемся с узлом, который существует в . Этот процесс назван "backtracking", поскольку происходит перемещение по дереву к корню, пока мы не будет найден правильный узел для того, чтобы продолжать процесс сравнения. Отметим, что в наихудшем случае необходимо возвращаться в корень, поскольку он должен содержать вероятность следующего символа для того, чтобы приступать к алгоритму сравнения. Суммарная вероятность сравнения получается путем умножения вероятности в каждой точке сравнения на текущую суммарную вероятность. Например, если мы хотим сравнить пример "1 3 2" с PST для последовательности «1 2 3 1 2 3 2 1 3», . 2, . Шаг 1: Корневой узел дает вероятность 3/8 при обнаружении "1" . Шаг 2: узел "1" дает условную вероятность 1/3 при обнаружении "3" , так 3/24. Шаг 3: узел "1 3" не существует, поэтому мы удаляем символ с внешней стороны, которая дает "3". Узел "3" дает вероятность 1/2 при обнаружении "2". Совокупная вероятность сопоставления для образца - 3/48. (1,0,0) (0,0,1) (0,1,0) (0,0,1) Рис. 2. Пример для иллюстрации сравнения PST Чем выше вероятность сравнения, тем более вероятно, что данный образец был использован при построении суффиксного дерева. Например, при сравнении "1 2" с РБТ на рис. 2, вероятность сравнения - 2/8. Это может быть проверено, поскольку из возможных восьми случаев " 1 2" возникает в обучающих данных дважды. При сравнении "1 2" - более вероятно использовано для того, чтобы построить суффиксное дерево, чем "1 3 2" с совокупной вероятностью 3/48. Сравнение суффиксных деревьев может быть основано на расстоянии (т.е. значении отличия) между ними. Расстояние между деревьями определено как евклидово расстояние между узлами каждого дерева. Расстояние между двумя узлами определяется следующим образом: где р(1) - сравнительная вероятность для узла 1. р(к|1) - условная вероятность появления символа к. Т1 и Т2 - сравниваемые РБТ. Расстояние равно 0 тогда и только тогда, когда два узла идентичны. Есть два типа сравнения: семантическое и потоковое. Семантическое сравнение включает только те узлы, которые существуют в обоих деревьях. В зависимости от обучающих данных одно дерево может содержать больше узлов, чем вто- , . проблему, нужно учесть, что если данный узел не существует в дереве, то оно может иметь ту же вероятность, что и родитель. Можно затопить дерево ненужными узлами для того, чтобы выполнить сравнение путем создания такого количества дочерних узлов, которое необходимо. При этом копируются распределения вероятностей, принадлежащие родитель, . Например, если «1_3» существует в первом дереве, но не существует во втором, мы можем «адить» общий суффиксный узел, «3», во втором дереве путем копирования распределения вероятностей в новый узел, маркированный «1_3». Теперь, когда оба дерева содержат «1_3», операция сравнения может быть успеш-. Запишем алгоритм на псевдоязыке: Сравнение ПСТ = ( 1, 2, -ное_сравнение) + ( 1, 2, _ ) + ( 2, 1, _ ) Рекурсивное Сравнение ПСТ Если узел1=пустой_ук^атель, выход ( _ -> =0) Если точное_сравнение Для I от 0 до Макс_число_знаков_адфавита Результат+=(узел 1->вероятность(0- узел2->вероятность(0)л2 Иначе T = _ _ Если (T->ypoBeHb = узел1->уровень) искл. Или (неточное_сравнение) Для I от 0 до Макс_число_знаков_адфавита Результат+=(узел 1->вероятность(0- T->вероятность(0)л2 Результат += рек. Сравнение ПСТ (узел1->сын, узел2, точность сравнения) + рек. Сравнение ПСТ (узел1->брат, узел2, точность сравнения) . ]]></text>
</doc>
