<doc>
  <source auto="true" type="str" verify="true"><![CDATA[https://cyberleninka.ru/article/n/geneticheskiy-algoritm-razmescheniya-upravlyaemyy-vremennymi-ogranicheniyami]]></source>
  <category auto="true" type="str" verify="true"><![CDATA[Автоматика]]></category>
  <author auto="true" type="list" verify="true">
    <item type="str"><![CDATA[Лебедев Б.К.]]></item>
    <item type="str"><![CDATA[Степаненко С.А.]]></item>
  </author>
  <title auto="true" type="str" verify="true"><![CDATA[Генетический алгоритм размещения, управляемый временными ограничениями]]></title>
  <keywords auto="true" type="list" verify="true"/>
  <annotation auto="true" type="str" verify="true"><![CDATA[]]></annotation>
  <text auto="true" type="str" verify="true"><![CDATA[. , , 20 , . задержкой наиболее длинного пути, но временные ограничения являются предель- . . . , . Существующие алгоритмы размещения, управляемого временными ограничениями, можно разделить на 2 категории: основанные на оценке путей распространения сигналов (path-based) и основанные на оценке цепей схемы (net-based). Path-based алгоритмы [1-3] непосредственно пытаются минимизировать задержку наиболее длинного пути. Популярным подходом является минимизация суммы длин некоторого множества критических путей. Этот набор критических путей либо предварительно определяется методом статического временного анализа, либо может динамически изменяться от итерации к итерации. Большинство алгоритмов этого класса основано на методах математического программирования. path-based - менных ограничений в процессе оптимизации. Тем не менее, их недостаток заключается в том, что они требуют существенное количество вычислительных ресурсов из-за экспоненциального числа путей, которые необходимо одновременно минимизировать. Кроме того, в некоторых типах алгоритмов размещения, например, в алгоритмах, основанных на нисходящем разбиении, очень трудно, а иногда невоз-, . Алгоритмы net-based [4-7] в отличие от path-based алгоритмов непосредственно не накладывают ограничения на пути прохождения сигнала. Вместо этого, временные ограничения или требования на пути преобразовываются в ограничения на длину цепей или веса цепей. Основная идея заключается в том, чтобы более критическим цепям присвоить больший вес. Эта информация затем используется алгоритмом минимизации взвешенной длины соединений, с целью получения размещения с лучшей временной задержкой. Этот полученный вариант размещения рассматривается статическим анализатором, после чего получается новый набор , . этот процесс повторяется на нескольких итерациях, до тех пор, пока наблюдается улучшение или пока не будет выполнено заданное число итераций. Методики, основанные на вычислении весов цепей, обладают некоторыми привлекательными свойствами: сравнительно низкая временная сложность, большая гибкость (могут быть интегрированы в существующие алгоритмы, минимизирующие длину про- * Работа выполнена при финансовой поддержке программы развития научного потенциала высшей школы РНП.2.1.2.2238 ), . ограничений современных схем, эти преимущества придают методикам, основанным на вычислении весов цепей все большую привлекательность. В данной работе предлагается генетический алгоритм решения задачи размещения, управляемого временными ограничениями. Моделирование временных ограничений. В алгоритмах размещения, управляемых временными ограничениями обычно применяется методика статического временного анализа для вычисления задержки наиболее длинного пути схемы. Результаты этого анализа далее используются алгоритмом, минимизирующим задержку наиболее длинного пути схемы. В статическом временном анализе пути распространения сигналов в схеме обычно моделируются направленным ациклическим графом G(V, E) : вершинами графа является множество входных и выходных контактов элементов схемы, а ребрами являются связи между элементами. Каждому ребру присваивается величина временной задержки. Путь распространения сигнала начинается с первичного входа или выхода элемента памяти и заканчивается в первичном выходе или входе элемента памяти. Через Pj и PO обозначаются множества входных и завершающих выходных контактов пути, соответственно. Задержка наиболее длинного пути может быть определена путем итеративного вычисления времени прибытия сигнала (arrival time) по следующей формуле: [0 if t е Pj; ARR(t) = \ I maX( s t )eE { ARR(s) + d (s, t)} otherwise; где d (s, t) - задержка ребра (s, t). Задержка наиболее длинного пути определяется по формуле: T = maxtePo ARR(t) . Подобным образом можно вычислить требуемое время прибытия сигнала (required arrival time) для каждого контакта, по следующей формуле: \Tif s е PO; Q( ) |тШ(st)eE{REQ(t) - d(s, t)}otherwise. Теперь для каждого ребра можно определить величину резерва задержки, ко, ребру, без увеличения задержки наиболее длинного пути всей схемы. Резерв задержки для заданного ребра (s, t) определяется по формуле: slack(s, t) = REQ(t) - ARR(s) - d(s, t) . - , : slack (п) = ^ d (e). een Аналогично резерв задержки пути определяется как максимальная величина задержки, которая может быть добавлена к пути, чтобы он стал критическим. Резерв задержки пути определяется по формуле: slack (п) = T - d (п). , -деления путей (path sharing). Интуитивно понятно, что если два критических пути содержат общий сегмент, ребрам этого общего сегмента должен быть присвоен больший вес. Для учета этого эффекта применяется распространенный подход, основанный на пересчете путей (path counting). В работе [8] был предложен алгоритм PATH, выполняющий назначение весов цепей на основе перебора путей. Алгоритм PATH мотивируется следующей проблемой: имея временной граф, после выполнения анализа путей прохождения сигналов, для ребер принадлежащих некоторому критическому пути, необходимо вычислить общее число критических путей, проходящих через каждое ребро. Эта проблема может быть легко решена следующим простым алгоритмом. Для каждого контакта р временного графа определяются две переменные: ♦ Прямой путь F(p) - число различных критических путей, начинающихся от контактов элементов P и заканчивающихся в p. ♦ Обратный путь B(p) - число различных критических путей, начинающихся от контактов элементов PO и заканчивающихся в р, если изменить на противоположное направление все пути распространения сигналов. Число различных критических путей проходящих через ребро (s, t) определяется по формуле: GP( s, t) = F (s) X B(t). Проблема минимизации временных задержек в общем виде формулируется : minF(х), ^ nd(е) < T, Vne P, (1) где F(x) - некоторая целевая функция задачи размещения, P - множество всех путей в схеме. Можно преобразовать данную постановку в постановку без ограничений: min F ( х) + ^ D(slack (п), T )* d (п). (2) neP e(s, t) : PWD (e) = £ D( slack (п), T), (3) П€е где D(х, у) - заданная функция скидок (discount function). Функция скидок D( х, у) называется так потому, что это монотонно убывающая функция от х, поскольку мы хотим присвоить меньший вес (больше скидок) для путей с большей величиной резерва задержки. Алгоритм. Предлагаемый алгоритм размещения управляемого временными , . - , натуральной генетики. Они реализуют "выживание сильнейших" среди рассмот-, -ния эволюции поиска. Генетические алгоритмы с успехом применялись при решении различных оптимизационных задач, в том числе задач автоматизированного проектирования СБИС [11], таких как разбиение, размещение, планирование, трас. избегания локальных оптимумов. Г енетический алгоритм состоит из следующих основных частей: кодирование решения в виде хромосомы, набор генетических операторов (кроссинговер, мутация, селекция, отбор), целевая функция. . . выполняется с помощью Одиночной последовательности (Single-Sequence или SS) [10]. Одиночная последовательность представляет собой перестановку целых чисел 1,2,3,..., n, каждое число соответствует размещаемому на плоскости элементу . SS - му ABLR-отношений (above (сверху), below (снизу), left-of (слева от), right-of ( )) , -лом: Если (X, у) в SS расположены в таком порядке их < у, тогда элемент x y. (x, y) SS X > у , тогда элемент х расположен ниже элемента у. Одиночная последователь- - ABLR. Его можно рассматривать как нормализованную последовательность пар (Sequence-Pair или SP) [9]. Для представления решения с помощью SS требуется в два раза меньше памяти по сравнению с представлением с помощью SP. SS требуют пересчета после каждого шага. Поскольку не разработаны алгоритмы инкрементной переоценки SS, довольно большое время тратится на оценивание одиноч- . - ся негомологичность хромосом, что требует применения специальных генетических операторов, таких как, например, циклический, частично-соответствующий и упорядочивающий операторы кроссинговера, а также мутация обмена, инверсии. . - альная целевая функция, минимизирующая длину проводников, и временные за- . (2). Структура генетического поиска такова: создание начальной популяции, , , выбор хромосом и применение операторов мутации, вероятностный отбор наи- . -рование наилучшего решения, и конец работы алгоритма. . играют жизненно важную роль в современных нанометровых стилях проектирова-, -висит от межсоединений проводников. ]]></text>
</doc>
