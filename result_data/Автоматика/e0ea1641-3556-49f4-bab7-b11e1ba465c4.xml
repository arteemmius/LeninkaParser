<doc>
  <source auto="true" type="str" verify="true"><![CDATA[https://cyberleninka.ru/article/n/reshenie-zadachi-vzaimnogo-isklyucheniya-i-koordinatsii-protsessov]]></source>
  <category auto="true" type="str" verify="true"><![CDATA[Автоматика]]></category>
  <author auto="true" type="list" verify="true">
    <item type="str"><![CDATA[Емельянов Александр Анатольевич]]></item>
    <item type="str"><![CDATA[Власова Екатерина Аркадьевна]]></item>
  </author>
  <title auto="true" type="str" verify="true"><![CDATA[Решение задачи взаимного исключения и координации процессов]]></title>
  <keywords auto="true" type="list" verify="true"/>
  <annotation auto="true" type="str" verify="true"><![CDATA[Необходимость координации и взаимного исключения процессов возникает в тех случаях, когда идет активная работа с нематериальными (логическими) ресурсами: в информатике - с сообщениями, буферной памятью, последовательно используемыми программами, в экономике - с правами собственности, разрешительными документами в виде накладных, путевых листов, записей в бортовом журнале судна (коносамент) и др. Некорректное решение этих задач приводит к патовой ситуации или клинчу, когда все ресурсы вроде бы в наличии, а процесс развиваться не может. Среди различных подходов к решению проблемы - основанный на принципе семафора, который и будет рассмотрен.]]></annotation>
  <text auto="true" type="str" verify="true"><![CDATA[Необходимость координации и взаимного исключения процессов возникает в тех случаях, когда идет активная работа с нематериальными (логическими) ресурсами: в информатике — с сообщениями, буферной памятью, последовательно используемыми программами, в экономике — с правами собственности, разрешительными документами в виде накладных, путевых листов, записей в бортовом журнале судна (коносамент) и др. Некорректное решение этих задач приводит к патовой ситуации или клинчу, когда все ресурсы вроде бы в наличии, а процесс развиваться не может. Среди различных подходов к решению проблемы — основанный на принципе семафора, который и будет рассмотрен. Координация и взаимное исключение — две внешние стороны непосредственной деятельности по управлению сложными процессами. Подобные задачи решаются в случаях: • создания сложных программных муль-типроцессных средств(операционных систем, пакетов имитационного моделирования, работающих по принципу симуляции реальных процессов вычислительными средствами, а также агентных программ сетевого взаимодействия); • моделирования логики экономического (логистического) процесса. Впервые задача взаимного исключения и координации параллельных процессов возникла в 80-х годах ХХ века, когда активно развивались различные платформы компьютеров (от больших вычислительных комплексов на базе вычислительной техники IBM, Cray и Burrows до компьютеров на базе 32-разрядных микропроцессоров Intel, IBM, SAN и Hewlett Packard). Первое корректное решение задачи координации в виде аппаратной реализации принципа семафора было предложено в книге [1]. Известны ее программные решения, в том числе — для создания новых операци- онных систем [2]. Что касается таких сложных комплексов, как программные имитаторы, то здесь задача координации решается гораздо сложнее, чем для операционной системы (ОС). И основная трудность заключается в том, что в имитаторе создаются свои абстрактные процессы и ресурсы, никак не связанные с вычислениями с точки зрения ОС. Поэтому без решения задачи координации в имитаторе возможны «зависания», которые сделают невозможной работу ОС (и соответственно имитационной модели). Причина заключается в образовании замыканий процессов ОС через процессы и ресурсы имитационной модели, в то время как в самой модели программных ошибок нет (эффект клинча). Постановка задачи координации для прикладных программ, в которых возникают многочисленные процессы и используются разнотипные ресурсы (в том числе и логические, т. е. нематериальные) опубликована в [3]. Приведем решение этой задачи, используя систему имитационного моделирования Pilgrim для иллюстрации динамики процесса координации. Рассмотрим техническое обеспечение современного компьютера в виде набора ресурсов: псевдопроцессоров (одного или нескольких центральных процессоров, муль- 123 №6(12) 2007 типлексного контроллера или блок-мультиплексного канала) и пассивных ресурсов (накопителей, областей основной памяти, модемов — линий связи, отдельных баз данных). Процесс — это запрос на выполнение последовательных действий по определенной программе группой псевдопроцессоров. Процесс образован, если псевдопроцессоры приписаны программе, хотя не обязательно доступны в любой момент времени. Процессы могут забирать ресурсы (включая псевдопроцессоры) для монопольного использования, из-за чего возможны конфликтные ситуации — очереди к ресурсам. Иногда конфликтные ситуации остаются неразрешенными, что происходит при блокировках, когда время ожидания в очереди становится бесконечным. Для выполнения программы любого процесса необходим центральный процессор. Процессы, выполняющие различные функции программного комплекса или параллельные ветви сложного алгоритма, должны обмениваться информацией посредством пассивных ресурсов (через область оперативной ,в либо дисковой памяти). Й Далее мы будем называть процесс, кото-§■ рый произвел порцию информации и пере-& дает ее последующему, производителем, § а процесс, получающий эту информа-| цию, — потребителем. Существует два ос-Ц новных момента, на которые необходимо § обратить внимание при решении задачи ко-« ординации: I || 1) взаимодействие типа «производила тель ^ потребитель»: производитель дол-¡2 жен сообщить конкретному потребителю, Л что он подготовил информацию, и потреби-| тель может начать обработку, если он не за-^ нят другой работой; та 2) «взаимное исключение» процессов <? при работе с общими модифицируемыми | ресурсами. I Другими словами, необходимо согласовать работу как по управлению, так и по ин- 124 формации, которая заключена в общих ресурсах. Решение задачи координации при такой постановке можно осуществить с помощью переменной величины особого вида — семафора, а также особых функций, работающих с этой переменной. Принцип семафора состоит в следующем. Допустим, что в оперативной памяти компьютера имеется слово с адресом в. Введем в рассмотрение две функции, которые могут выполняться различными процессами. Функция ^-примитив выполняет операцию в = в +1, причем во время выполнения невозможны прерывания с передачей управления другим процессам. Если бы прерывание было возможным, то один процесс, начавший выполнение такой функции, мог бы быть прерван другим, который выполнит функцию ^-примитив над этим же аргументом; когда же первый процесс вновь получит управление и выполнит функцию до завершения, то получится, что в отличается от начального вида не на «1», а на «2». Функция Р-примитив выполняет операцию в = в -1 также без прерываний со стороны других процессов, причем при в = 0 единица не вычитается, а процесс переводится в режим ожидания (т. е. приостанавливается выполнение функции) до тех пор пока какой-либо другой процесс не выполнит функцию ^-примитив над этим же аргументом. Семафором в данном случае называется неотрицательный аргумент в функций V и Р. Автор принципа семафора Э. Дийкст-ра [1] доказал, что с помощью него можно решить задачу координации процессов и по управлению, и по информации. Однако сложение и вычитание с защитой от прерываний и задержкой во времени (при вычитании) система команд реального компьютера реализовать не может. Поэтому попытаемся решить задачу координации с помощью программных средств, имея в распоряжении современную мультипрограммную операционную систему. №6(12) 2007 Практическое решение задачи координации будем основывать на двух положениях: 1) семафор — это ресурс, захватываемый процессом монопольно при выполнении примитива; 2) семафор должен хранить не только свое значение, но и информацию о событии. Первый принцип необходим для координации по информации, а второй — по управлению. Для отражения этих принципов надо создать семафор с более сложной (по сравнению со словом в основной памяти) структурой. Обозначим через N общее число процессов и рассмотрим рис. 1 (процессы Q и Я являются производителями, а процесс в — потребителем). Рис. 1. Схема взаимодействия «производители-потребители» Каждому из N процессов поставлен в соответствие блок управления событием (процессам О и Я соответствуют блоки управления ЕО и ЕЯ). Все блоки управления событием сведены в таблицу событий — программную секцию Ecbtable. В распоряжении модуля в имеется таблица синхронизации Т3, содержащая адреса всех блоков управления событием процессов-производителей, которые могут передавать к в порции информации. Передача заключается в формировании этой порции в рабочей области и в оповещении потребителя о том, что он может начать обработку. Рабочая область должна быть ресурсом, захватываемым сначала производителем (запись порции), а затем потребителем. Таблица Тв имеет заголовок из двух строк: двойного слова Ои3 и слова ЯЕв. Пара таких строк однозначно определяет таблицу синхронизации, а конкретный формат строк выбран исходя из удобств программирования. Каждый блок управления событием указывается с помощью адресной константы типа V. Последнее слово в таблице содержит единицу в старшем разряде, так как таблица — это список параметров, оформляемый в соответствии с соглашениями, регламентированными управляющей программой. Для координации выполнения процессов введем синхронизирующую функцию Twait (NS,TS). Процесс в должен перейти в состояние ожидания после выполнения в нем этой функции. Только во время ее выполнения производители могут передавать в рабочую область порцию информации и делать соответствующую отметку в своем блоке управления событием. Значение первого аргумента рассматриваемой функции задается программистом — разработчиком имитатора при следующих условиях: 1) N3 = 1, если для передачи управления к процессу в для оповещения необходимо, чтобы хотя бы один из производителей подготовил порцию (логическое «ИЛИ»); 2) N3 = Р3, если для передачи управления необходимо, чтобы все Р3 производителей, перечисленных в таблице синхронизации, подготовили свои порции (логическое правило «И»). со о и § со со о 125 No6(12) 2007 Во время выполнения функций Т\\ай (Ы3, Т3) все блоки управления событием подвергаются изменениям: содержимое разрядов 1 становится равным нулю, а разрядов 0 — единице. Управляющая программа передает управление модулю в после появления совокупности событий, определяемых синхронизирующей функцией Т\\ай (Ы3,Т3). Предположим теперь, что один из производителей подготовил порцию информации и начал выполнять другую синхронизирующую функцию: Трс^ (ЕО,Т3). В этом случае ни один производитель из числа перечисленных в таблице Т3 не может начать выполнение такой же функции, ни один потребитель не может выйти из состояния ожидания, до тех пор, пока функция 7post (ЕО,Т3) не выполнится до конца. Операнд ЕО указывает на блок управления событием производителя — этого процесса О. В этом блоке делается отметка о событии — передаче информации в рабочую область, причем содержимое блока меняется: в разряде 0 появляется единица, а в разряде 1 — ноль. ,в Введем в рассмотрение величину в11\13 — количество единиц в разрядах 1 всех бло-§■ ков, перечисленных в Т3. Нетрудно пока-& зать, что и | 1) 0 < в11\13 < Р3, где Р3 — это число Ц строк в таблице Т3; 2) N3 — кратное выполнение Р-прими- « тива над семафором в11\13 приводит к тому ^ же результату, который мы получили при || однократном выполнении функции Т\\ай £ (^,Т3); ¡2 3) однократное выполнение 1/-примити- | ва над семафором равносильно однократ- «I ному выполнению функции 7post (ЕО,Т3). со та Рассмотренные функции 7post (ЕО,Т3) и <? Т\\ай (N3,T3) выполняют как синхронизацию | типа «производитель-потребитель», так и § взаимное исключение при работе с общей <2 областью для обмена порциями информации. Эту рабочую область целесообразно 126 сделать в виде отдельной секции, причем разбить ее на отдельные поля по следующему правилу: на каждое взаимодействие «производитель-потребитель» отводится одно поле. Адреса этих полей являются точками входа или внешними ссылками (extern). Синхронизирующие функции можно реализовать в виде макроопределений, используя Ассемблер или C++. Решение задачи взаимного исключения может потребоваться не только при создании сложных программных мульти-процессных средств, но и для моделирования логики экономического процесса [4]. Дело в том, что в логистике, при решении задач, связанных с маршрутизацией и перевозками, возникают различные логические условия. Кроме того, клинч может возникнуть и при решениях, связанных с выполнением правовых условий. Рассмотрим практическое решение такой задачи средствами Pilgrim: имитационная модель под названием «Стоянка маршрутного такси». Пример. На остановку маршрутного такси с определенными интервалами приходят пассажиры и подъезжают такси. Такси уезжает, когда в машину сядут 10 пассажиров. Если пришедший пассажир не обнаруживает стоящего такси, то он встает в очередь на посадку. Когда такси подъезжает на пустую остановку (никого нет), машина ждет пассажиров. Если такси подъехало, а на остановке стоит пришедшее раньше, то последняя встает в очередь. Принцип работы узла delet: вошедший в него актор семейства «такси» становится «тележкой» для акторов семейства «пассажиры», входящих следом. Как только в узел войдет заданное количество акторов-пассажиров, они поглотятся, а актор-тележка переходит в следующий узел; при этом первые перестают существовать как заявки на обслуживание в системе. Исходные данные для моделирования представлены в табл. 1. №6(12) 2007 Таблица 1 Исходные данные имитационной модели № п/п Параметры Среднее значение, мин 1 Время моделирования 600 2 Интервал прихода пассажиров 1 3 Интервал приезда такси 10 Опишем работу модели (рис. 2). Генератор 7 создает акторы, имитирующие пассажиров. Интервал прихода пассажиров в соответствии с теоремой о суперпозиции потоков случайных событий имеет экспоненциальное распределение. Интервал генерации акторов, имитирующих такси, имеет нормальное распределение(обоснование: маршрут такси состоит из множества отрезков, поэтому имеют место условия центральной предельной теоремы, даже если на маршруте несколько машин). Использование в описании генератора 8 нормального закона распределения интервала генерации означает, что временной интервал между приездами такси на остановку чаще оказывает- Запросы такси Приходы такси Такси уехало Рис. 2. Схема имитационной модели координации двух процессов ся ближе к своему среднему значению и реже — дальше от него (чем больше отклонение интервала от среднего, тем реже это происходит). Узлы 1 и 5 имитируют соответственно очереди пассажиров и такси. Ключ 6 в начале работы модели находится в открытом состоянии (по умолчанию), а ключ 2 закрывается при приходе в очередь 1 первого актора-пассажира. Это делается для того, чтобы в узел Сее первым вошел актор-такси, а не пассажир (иначе пассажир станет «тележкой»). Как только в Сее войдет первый актор-такси, ключ 6 закрывается, а ключ 2 одновременно с ним открывается. Теперь выходящие из генератора 6 акторы-такси стоят в очереди 5, а акторы-пассажиры заходят в узел Сее (идет заполнение такси). Когда в узле Сее накопится 10 акторов-пассажиров, актор-такси перейдет в терминатор (заполненное такси уедет). После этого ключ 6 открывается, чтобы в Сее мог зайти следующий актор-такси, а ключ 2 в это же время закрывается, чтобы акторы-пассажиры стояли в очереди 1 до прихода в Сее актора-такси. Таким образом, ключи 2и6в модели всегда находятся в противоположных состояниях: если один открыт, то другой закрыт. Тем самым чередуется доступ к узлу Сее разных типов акторов — такси и пассажиров. Рассмотренный принцип «тележки» позволил эффективно решить задачу взаимного исключения и координации процессов «производитель-потребитель». Нетрудно заметить, что в модели нет ни одного узла обслуживания (узлов типа эе^ или ргос с ненулевым временем обслуживания), но в очередях могут возникать существенные задержки. Здесь рассмотрены простейшие условия: заполнение салона такси пассажирами до 10. Возможно и усложнить задачу, поскольку водители могут отправляться, не дожидаясь заполнения салона, поскольку имеются типовые места на маршруте, где 127 «а со о и § со со о No6(12) 2007 с такой-то вероятностью можно «подсадить» пассажиров и получить тот же денежный эффект, сэкономив время. Таким образом, можно спланировать дополнительные рейсы и соответственно получить экономический эффект. Текст модели в комментариях не нуждается: « о Ц § 0 & 1 I Ü s « 1 » i g g I S ев «о S 1 i « #include <Pilgrim.h> float modtime = 6 0 0.0 float tpass = 1.0 float ttaxi = 10.0 forward { modbeg ("Стоянка такси" actor ("Запросы такси" actor ("Приходы такси" network (dummy, dummy) { // Модель // Моделируем 10 часоЕ // Интервал прихода пассажиров // Интервал прихода такси 8, modtime, (long)time(NULL), none, 1, none, 4, 2); 7, none, expo, tpass, zero, zero, 1); 8, none, norm, ttaxi, ttaxi/3, zero, 5); top(1): top(2): t->ft= queue place; if else // Пометить актора-пассажира ("Очередь", none, 2), (addr[3]->tn == 1) rels(2); // Такси подано? // Да: посадка hold(2); ("Есть такси? // Нет: ожидаем 3); top(3): top(4): top(5): top(6): 1, 1, 0, 10, 4); key place; delet ("Посадка rels(2); hold(6); place; term ("Такси уехало"); hold(2); rels(6); place; queue ("Такси ждет", none place; key place; 6); ("Стоянка свободна? 3); fault(123) ; } modend ( "ResTaxi.doc" return 0; } 1, 12, page) ; ]]></text>
</doc>
