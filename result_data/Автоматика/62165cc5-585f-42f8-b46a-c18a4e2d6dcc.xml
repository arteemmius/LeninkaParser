<doc>
  <source auto="true" type="str" verify="true"><![CDATA[https://cyberleninka.ru/article/n/deduktivnyy-sintez-funktsionalnyh-i-imperativnyh-programm]]></source>
  <category auto="true" type="str" verify="true"><![CDATA[Автоматика]]></category>
  <author auto="true" type="list" verify="true">
    <item type="str"><![CDATA[Дрождин В. В.]]></item>
    <item type="str"><![CDATA[Жуков М. В.]]></item>
  </author>
  <title auto="true" type="str" verify="true"><![CDATA[Дедуктивный синтез функциональных и императивных программ]]></title>
  <keywords auto="true" type="list" verify="true">
    <item type="str"><![CDATA[дедуктивный синтез]]></item>
    <item type="str"><![CDATA[дедуктивная таблица]]></item>
    <item type="str"><![CDATA[синтез транзакций]]></item>
  </keywords>
  <annotation auto="true" type="str" verify="true"><![CDATA[Для предметной области, описанной на языке конструктивной логики, дедуктивный метод позволяет автоматически находить решение новых задач. Рассматривается способ реализации дедуктивного метода, основанный на дедуктивных таблицах, приводятся примеры дедуктивного синтеза функциональных и императивных программ.]]></annotation>
  <text auto="true" type="str" verify="true"><![CDATA[© В. В. дрождин, М. В. ЖУКОВ Пензенский государственный педагогический университет имени В.Г. Белинского, кафедра прикладной математики и информатики e-mail: drozhdin@spu-penza.ru Дрождин В. В., Жуков М. В. - Дедуктивный синтез функциональных и императивных программ // Известия ПГПУ им. В. Г. Белинского. 2009. № 13 (17). С. 89-94. - Для предметной области, описанной на языке конструктивной логики, дедуктивный метод позволяет автоматически находить решение новых задач. Рассматривается способ реализации дедуктивного метода, основанный на дедуктивных таблицах, приводятся примеры дедуктивного синтеза функциональных и императивных программ. Ключевые слова: дедуктивный синтез, дедуктивная таблица, синтез транзакций. Drozhdin V. V., Zhukov M. V. - The deductive synthesis of functional and imperative programs // Izv. Penz. gos. pedagog. univ. im.i V. G. Belinskogo. 2009. № 13 (17). P. 89-94. - The deductive method enables to find the solutions of new tasks for the domain, described at the language of constructive logic. The article considers one of deductive methods of realization based on the deductive tables. It also gives examples of deductive synthesis both functional and imperative programs. Keywords: deductive synthesis, deductive table, synthesis of transactions. Одной из наиболее сложных проблем в области программирования является разработка метода автоматической генерации программы компьютером, для задачи, которая ранее им не решалась и для которой у него отсутствует алгоритм решения. Одним из возможных способов решения этой проблемы является дедуктивный синтез программ, основанный на дедуктивных таблицах [1]. Синтез программы начинается с ее спецификации: задания отношения между входными и выходными данными. Спецификация должна описывать цель или ожидаемое поведение программы и в общем виде задается следующим образом: ^а) <= найти z такой, что Ц[а^], где z - выходные данные, а - входные, Q - условия, заданные на языке конструктивной логики, которым должны удовлетворять входные данные а и соответствующий им результат z. Следовательно, необходимо найти функцию f такую, чтобы для любого значения а, ее результат z удовлетворял ограничению Q. Согласно дедуктивному методу данная задача интерпретируется как доказательство теоремы существования: ^а)3^)й[а, z]. Для ее доказательства достаточно найти функцию f получения z по а, которую будем строить с помощью метода дедуктивных таблиц. Дедуктивные таблицы. Дедуктивная таблица состоит из колонки утверждений (assertions), в которой записываются известные аксиомы, колонки целей (goals), которая содержит цели для доказательства, и выходной колонки, в которой формируется текст программы. Если в одной спецификации задано несколько функций, то в таблице появляется несколько выходных колонок. Для синтеза программы её спецификация добавляется в дедуктивную таблицу в качестве цели для доказательства. При этом в таблицу может быть уже включен набор аксиом, описывающих предметную область задачи, свойства предикатов и функций, использованных в спецификации. Ниже приведен вариант начального состояния дедуктивной таблицы: assertions goals f(a) Q[a, z] z A, A2 A n где А1, А2,.. Ап - известные аксиомы предметной области. Процесс доказательства представляет собой последовательное преобразование дедуктивной таб- лицы, до тех пор, пока в ней не появится одна из строк: assertions goals f(a) true t или assertions goals f(a) false t При этом программа t будет являться искомым решением, т.е. ^а) <= ^ Построение осуществляется посредством эквивалентных преобразований, в основу которых положены эквивалентные преобразования конструктивной логики и свойства дедуктивных таблиц, либо посредством подобных преобразований. В первом случае дедуктивная таблица (строка дедуктивной таблицы) заменяется эквивалентной, во втором результирующая таблица (строка) представляет собой объединение исходной и подобной таблиц (строк). Свойства дедуктивных таблиц 1 Двойственность (слева расположена исходная таблица, справа - эквивалентная ей) A s -A s и G s -G s 2 Подстановка A s A9 s9 и G s G9 s9 где 9 - подстановка, т.е. множество {х1 ^ ^, ..., хп ^ пар вида х. ^ £, где х. - переменная в исходном выражении, ^ - заменяющая х. подстановка. Дедуктивные правила 1 Правила разделения 1.1 And-split (в верхней части таблицы, до двойной черты, расположена исходная таблица, в нижней -строки, которые будут добавлены к ней после применения дедуктивного правила) A1 Л A2 s A1 s A2 s 1.2 Or-split Gi v g2 s Gi s G2 s 1.3 If-split if A then G s A s G s 2 Правило резолюции (GG - goal, goal) Gi [P] s G2 [P’] t G19[false] л G29[true] if P9 then t9 else s9 где 9 - наибольший общий унификатор подвыражений Р и Р’. С учетом свойства двойственности и свойств логических операций, можно получить и другие правила резолюции: АА, АС, СА. Заметим, что при применении правила резолюции зачастую в таблице могут появиться строки вида: false t или true t которые не представляют никакой ценности для дальнейшего процесса доказательства и могут быть удалены из таблицы. Чтобы избежать появления таких строк можно использовать полярность выражений. Выражение, расположенное в столбце goals имеет положительную полярность, если количество знаков отрицания -влияющих на него чётно, в противном случае полярность отрицательная. Для выражений расположенных в столбце assertions все с точностью наоборот. При применении правила резолюции подвыражение P(P’) следует заменить true, если его полярность положительная, иначе - false. 3 Правило эквивалентности AJl = r] s A2 [l’] t A19[false] v A29[r9] if (l = r)9 then t9 else s9 где 9 - наибольший общий унификатор подвыражений l и l’. 4 Правило индукции Если Q[a, z] - исходная цель (спецификация), то в таблицу может быть добавлена гипотеза индукции, утверждающая истинность исходного утверждения для меньшего, чем а аргумента и содержащая обращение к искомой функции £ Q[a, z] z if x < a then Q[x'w f(x)] где <w - отношение полной фундированности. Дедуктивный синтез функциональных программ. Процедуру синтеза функциональных программ рассмотрим на примере построения программы со следующей спецификацией: <front(s), last(s)> <= найти <z4, z2> такие, что [if -(s = Л) then (char(z2) л s = z4 • z2)], где s - произвольный набор символов (строка), Л -строка, не содержащая ни одного символа, char(s) -предикат, принимающий значение true, если строка s состоит только из одного символа, • - операция конкатенации строк. Следовательно, необходимо разработать программу <front(s), last(s)>, декомпозирующую строку s на две подстроки z4 и z2, конкатенация кото- рых дает исходную строку s, причем z2 - последний символ строки s. Программы для функций front(s) и last(s), полученные в результате применения метода дедуктивной таблицы и аксиом домена строк будут иметь вид: front(s) <= [if char(s) then Л else head(s) • front(tail(s))] last(s) <= [if char(s) then s else last(tail(s))]. Дедуктивная таблица, с комментариями к каждому шагу построения приведена ниже (заметим, что все аксиомы в столбце assertion, которым не присвоен порядковый номер - это известные аксиомы домена строк): assertion goal | front(s) 1а8(:(8) Комментарии i) if -(s = Л) then char(z2) л s = z2 • z2 Zi По правилу 22 получим 2), 3) 2) -(s = Л) 2\, удалены из результирующих столбцов, т.к. не являются свободными переменными в 2) 3) char(z2) л [s = Zi • Z2]+ Zi г2 [Л* у = у]- Аксиома конкатенации 4) char(z2) л [s = z2]+ Л Получено по правилу эквивалентности и подстановке А, у <- г2} [х = х] - 5) char(s) Л Правило резолюции в и подстановка {х <— в, г2«— в} if char(u) then [[(u • yi) • у 2] = u • (yi • У2)] Аксиома конкатенации 6) char(u) л char(y2) Л s= u • (yi • y2) u • yi у 0 Получено применением к 3) правила эквивалентности и подстановки {г2<— и*уь г2<— у2} 7) if x <string s then if -(x = Л) then char(last(x)) л x = front(x) • last(x) Применение правила индукции к 1) if -(у = Л) then у = head(y) • tail(y) Аксиома декомпозиции Из 6), 7) и аксиомы декомпозиции можно получить: 8) -(s = Л) л -char(s) head(s) • front(tail(s)) last(tail(s)) Из 5), 8) и аксиомы: (у = Л) char(y) v -(tail(y) = Л) выводится: 9) true if char(s) then Л else head(s) • front(tail(s)) if char(s) then s else last(tail(s)) дедуктивный синтез императивных программ на примере синтеза транзакций [2]. Рассмотрим базу данных (БД) кадрового агентства, схема которой приведена на рис. 1, со следующими ограничениями целостности (ОЦ) (приведены только необходимые в дальнейшем ограничения): 1. В таблице Applicant (Соискатель) не может быть 2-х записей с одинаковым атрибутом name, т.к. name является первичным ключом; 2. Для любой строки r таблицы Interview (Собеседование) в таблице Applicant существует строка, первичный ключ которой равен атрибут applicant из r; 3. Applicant не может быть Employee (Работником), т.е. множество значений атрибута name из таблицы Applicant не пересекается с множеством значений атрибута name из таблицы Employee. С учетом изложенных ОЦ БД процедура трудоустройства нового работника employee будет состоять из этапов: 1. Если в таблице Applicant есть соискатель applicant с именем работника employee, то: 1.1 Удалить все собеседования applicant; 1.2 удалить applicant из таблицы Applicant; 2. Добавить employee в Employee. Рис. 1. Схема БД кадрового агентства Прежде чем приступать к синтезу кода транзакции трудоустройства введем необходимые обозначения: 1. R(e) - предикат, принимающий значение true если отношение R содержит кортеж e. В рассматриваемом примере R может принимать одно из значений Employee, Interview, Company, Applicant сокращенно обозначаемые как E, I, C, A соответственно; 2. s П (e) - селектор, извлекающий значение i-го атрибута из кортежа e длинной n. Любая транзакция представляет собой композицию одной из атомарных транзакций: 1. insertR (e) - добавление e в R; 2. deleteR (e) - удаления e из R; 3. modify R (x, e) - замена x на e в R. Новые транзакции могут образовываться следующими способами: 1. композиция t1 ;; t2; 2. условный переход if p then t1 else t2 fi, где p -предикат; 3. цикл foreach x in R|p do t od, где p - предикат, заданный для отношения R и позволяющий выбрать кортежи, к которым будет применена транзакция, размещенная в теле цикла. Чтобы перейти от синтеза функциональных к синтезу императивных программ, в конструктивную логику необходимо ввести понятие состояния. Будем различать два типа объектов: обычные объекты (s-object), такие как состояние, атрибут или кортеж, и функциональные объекты (f-object), которые возвращают состояние, значение атрибута или кортеж как результат вычисления. Представители первого класса объектов - это результаты вычислений, полученные для конкретного состояния БД. Рассмотренные выше предикаты и транзакции - это f-object-ы, каждому из которых можно поставить в соответствие s-object: f-object s-object Альтернативное обозначение s-object Комментарии к s-object e e' w:e некоторое конкретное значение кортежа е R(e) R'(w, e') w:: R(e) true, если e' находится в R при состоянии БД w s П (e) S' П (w, e') w: sП(e) значение атрибута s" кортежа e' при состоянии БД w t(e) t'(w, e') w; t(e) состояние, в которое перейдет БД из w после выполнения транзакции t с входными данными e' Автоматический синтез транзакции заключается в поиске такого кода транзакции, который, не нарушая ограничений целостности, переводит БД в состояние, удовлетворяющее ограничениям, заданным в спецификации транзакции. Следовательно, необходимо найти доказательство теоремы: (^о)^х)(Эт)(С0д ^ ^ х) Л где s0 - исходное состояние БД, s0;т - состояние БД после выполнения транзакции т, х - вектор входных аргументов транзакции т, С^) - предикат проверки ограничений целостности БД в состоянии s, Й - предикат, специфицирующий задачу. Для процедуры трудоустройства нового работника а теорема будет иметь вид: (^о)(^)(3т) х) ^ -А(^ х)) л (Ух)( I'(sо, х) ^ (Зу)(А'(^ У) л applicant(x) = пате(у))) л (Vx)(Vy)((A'(sо, х) л у) л пате(х) = пате(у)) ^ (х=у))) ^ (Е'(8о;т, а) л х) ^ -А.'^о^ х)) Л (Vx)( I'(sо;т, х) ^ ^уХ^О^т у) Л аррНсаП;(х) = пате(у))) л (Vx)(Vy)((A'(sо;т, х) Л A'(sо;т, у) Л пате(х) = пате(у)) ^ (х = у))) Теперь, когда сформулирована спецификация задачи, можно приступать к дедуктивному синтезу (см. таблицу ниже): assertion goal transaction Комментарии 1) C(s0) ^ E' (so;t, a) л C(so;t) so;t 2) C(s0) so;t 3) [E'(so;t, a)] + aC(so;t) so;t [E'(msertg' (w, x), x)]- Свойство транзакции insert 4) C(s0;T1;insertg (a)) s0;Ti;mserts (a) {w <— s0;t, i <— ii;;inserts (a), x <— a} 5) [—A(so;tb a)] + л C(so;tO s0;Ti;mserts (a) A'(w, x) ^ [-A'(delete^'(w,x),x)]- Свойство транзакции delete 6) A'(s0;t2, a) л C(s0;T2;delete^ (a)) s0;i2;deleteii (a); inserts (a) {w <— s0;t2, ii <— x2;;delete^ (а), х <— а} 7) C(s0;i2) a C(s0;i2; delete^ (a)) if A’(s0;t2, a) then s0;i2;delete^ (a); inserts (a) else s0;T2;inserts (a) fl Из 6) и 5) 8) C(s0;i2) a C(s0;i2; delete^ (a)) s0;x2;(if A(a) then delete^ (a) else A fl); inserts (a) Преобразование транзакции (алгоритм преобразований описан в [2]) 9) A'(s0;t2, a) л C(s0;t2) л (Vx)(T(s0;t2, x) ^ —p(x, a)) s0;t2; delete^ (a); inserts (a) Из 6) (из фрейма удаления) р(а, х) = (applicant(x) = name(a)) 10) A'(s0;i3;t, a) л C(so;i3;t) s0;i3; (foreach x in I|p(x, a) do delete/ (x) od); delete^ (a); inserts (a) Здесь t - это цикл с вложенной транзакцией, квантор всеобщности заменен на true после сколемизации 11) A'(s0;i3,a) л C(s0;i3;t) so;i3; (foreach x in I|p(x,a) do delete/ (x) od); delete^ (a); inserts (a) т.к. t не влияет на предикат А 12) C(so;t3) s0;i3; (if A(a) then (foreach x in |p(x, a) do delete/ (x) od); delete^ (a); else A fl); insert^ (a) Из 5) и учитывая то, что t не нарушает никаких ограничений целостности C(s0) 13) true s0; (if A(a) then (foreach x in I|p(x, a) do delete/ (x) od); delete^ (a); else A fl); insert^ (a) { s0;i3 «- so] Таким образом, код транзакции трудоустройства нового работника будет иметь вид: if A(a) then foreach x in I|p(x, a) do deletef (x) od; delete^ (a); else Л fi; insert^ (a). Рассмотренный метод синтеза программ на основе дедуктивных таблиц позволяет автоматически генерировать программы решения задач в предметных областях, описанных на языке конструктивной логики. ]]></text>
</doc>
