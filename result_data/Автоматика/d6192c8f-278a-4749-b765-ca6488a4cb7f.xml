<doc>
  <source auto="true" type="str" verify="true"><![CDATA[https://cyberleninka.ru/article/n/razrabotka-kripto-servis-provayderov-operatsionnyh-sistem-semeystva-microsoft-windows]]></source>
  <category auto="true" type="str" verify="true"><![CDATA[Автоматика]]></category>
  <author auto="true" type="list" verify="true">
    <item type="str"><![CDATA[Бабенко Л.К.]]></item>
    <item type="str"><![CDATA[Чернятинский С.Б.]]></item>
  </author>
  <title auto="true" type="str" verify="true"><![CDATA[Разработка крипто-сервис провайдеров операционных систем семейства Microsoft Windows]]></title>
  <keywords auto="true" type="list" verify="true"/>
  <annotation auto="true" type="str" verify="true"><![CDATA[]]></annotation>
  <text auto="true" type="str" verify="true"><![CDATA[Современное положение в сфере информационных технологий требует от разработчиков программного обеспечения включения эффективных механизмов защиты в свои проекты. При этом цели данной защиты весьма различны. В некоторых проектах защите подлежит сам продукт информационных технологий, в других - данные, с которыми он оперирует. Так или иначе, обеспечение необходимого уровня защиты - одна из основных задач современной разработки программного обеспечения. Для защиты используется множество механизмов, однако бесспорно, криптография занимает лидирующее положение в этом вопросе. Именно криптография используется для шифрования исполняемого кода программ, хранения конфиденциальных данных, аутентификации и пр. В связи с этим возникает множество вопросов, главным из которых является: необходимо ли разработчикам самостоятельно реализовывать криптографические алгоритмы. В случае самостоятельной разработки, внимание проектировщиков отвлекается от основной задачи, тратится столь драгоценное время, растет программный код, возрастает вероятность внесения ошибки и т. д. Эту проблему частично решают многочисленные библиотеки, включающие в себя реализацию практически всех современных криптографических систем. Все, что требуется от разработчиков, - это включить в свой проект данную библиотеку. Но эта простота обманчива. Опять тратится время на изучение интерфейса библиотеки, экспортируемых функций, типов и структур данных. В случае же изменения требований к защите программного продукта, возникает необходимость в расширении или, что еще хуже, замене данной библиотеки другой. Помимо того, что необходимо переучиваться на использование новой библиотеки, так еще придется адаптировать свой проект к интерфейсу новой библиотеки. Помимо этого, при использовании библиотек в виде исходных текстов или исполняемых модулей вся ключевая информация хранится в пользовательском приложении, что существенно снижает уровень безопасности таких систем. К тому же при таком механизме внедрения средств криптографической защиты информации (СКЗИ) не осуществляется контроль за целостностью самих СКЗИ. Как видно, использование библиотек криптографических систем позволяет частично решить проблему самостоятельной разработки механизмов защиты приложений. Однако, это не самый удобный, эффективный и безопасный выбор из возможных решений. Корпорация Microsoft предложила новый метод разрешения данной проблемы для разработчиков, работающих в операционных системах семейства Windows. Этим решением стало включение в состав операционных систем, начиная с Windows 95 OSR2 для линейки 9*/МЕ или с Windows NT 4.0 для линейки NT 4.0/2000/XP/.NET, специального интерфейса программирования криптографических приложений CryptoAPI. CryptoAPI абстрагирует своих пользователей от деталей реализации требуемой криптографической системы и ключевой информации, и представляет собой конечное множество четко определенных стандартных функций, которое покрывает собой все возможные современные методы криптографической защиты информации. Используя CryptoAPI, можно, не прилагая практически никаких усилий, изменять уровень защиты приложения. Все что для этого нужно, - это изменить идентификаторы используемых алгоритмов в разделе описания констант проекта. Все же остальное: вызовы функций и передаваемые параметры остаются прежними. Очевидно, интерфейс программирования криптографических приложений предоставляет разработчикам программного обеспечения очень удобный, эффективный и с высокой степенью безопасности сервис для защиты своих проектов криптографическими средствами. Следует отметить, что изначально в CryptoAPI внедрены лишь американские криптографические стандарты, да и то со значительными ограничениями (ограниченная длина ключевой информации и пр.). К примеру, в качестве симметричных алгоритмов шифрования, используются: Data Encryption Standard (DES) и его модификации, RC2 и RC4, а для ассиметричной системы используется RSA. Однако еще одной важной особенностью CryptoAPI является его расширение путем внедрения специальных провайдеров криптографических служб, составляющих ядро CryptoAPI и реализующих требуемые криптографические системы. Следует также отметить, что многие сетевые продукты компании Microsoft используют в качестве криптографического интерфейса CryptoAPI. Поэтому и уровень безопасности этих приложений может быть изменен. Цель данной статьи - предоставить читателю общие сведения о CryptoAPI, описать технологию разработки крипто-сервис провайдера, а также познакомить читателя с основными возможностями крипто-сервис провайдера, разработанного кафедрой БИТ на базе отечественных криптоалгоритмов. Интерфейс программирования криптографических приложений CryptoAPI Microsoft® CryptoAPI обеспечивает необходимый сервис, который позволяет разработчикам программного обеспечения внедрять криптографические механизмы в свои проекты. Разработчики приложений используют функции CryptoAPI, не вникая в детали реализации используемой криптографической системы. Архитектура CryptoAPI представлена на рисунке 1. Приложение обращается к CryptoAPI посредством четко определенных и унифицированных функций, которые полностью обеспечивают современные механизмы криптографической защиты данных. CryptoAPI в свою очередь, исходя из параметров переданных в функции, после их дополнительной обработки вызывает соответствующие функции провайдера и передает им модифицированные параметры. После выполнения провайдером соответствующей функции CryptoAPI опять обрабатывает полученные результаты и возвращает их пользователю. Очевидно, что CryptoAPI является посредником между пользовательскими приложениями и криптографическим системным программным интерфейсом CryptoSPI, абстрагируя пользователей от непосредственного контакта с реализациями криптографических систем, что в значительной мере повышает уровень безопасности как приложений, так и самих реализаций. Архитектура CryptoAPI Рис. 1 Следует также отметить, что пользовательское приложение никогда напрямую не работает с ключевой информацией. Вся ключевая информация хранится в специальных ключевых контейнерах провайдера, а приложение получает и передает в функции CryptoAPI лишь некое числовое представление, так называемый индекс (handle), необходимого ключевого объекта. Пользовательское приложение сможет получить ключевой объект только путем вызова специальной функции. Но и в этом случае в зависимости от типа ключевого объекта он будет некоторым образом защищен. CryptoAPI включает в себя следующий набор функций: Функции работы с провайдерами: CryptAcquireContext - получает индекс заданного ключевого контейнера провайдера. Позволяет создавать, открывать и удалять ключевые контейнеры. Службы операционной системы обычно используют свой системный ключевой контейнер. При вызове этой функции можно не указывать название провайдера. Тогда будет использоваться стандартный для заданного типа провайдер. CryptContextAddRef - добавляет ссылку на ключевой контейнер. Вызов этой функции увеличивает счетчик числа пользователей ключевого контейнера на единицу. Обычно используется, если индекс ключевого контейнера передается в качестве параметра в некоторую функцию. Освобождение ключевого контейнера возможно, только если данный счетчик равен 1. В противном случае он уменьшается на 1. CryptEnumProviders - перечисляет крипто-сервис провайдеры, зарегистрированные в системе. Для этого она считывает определенные ветки реестра. CryptEnumProviderTypes - перечисляет типы провайдеров, зарегистрированных в системе. Также выполняется путем считывания веток реестра. CryptGetDefaultProvider - запрашивает провайдер заданного типа, назначенный для использования по умолчанию. CryptGetProvParam - запрашивает параметры провайдера. Можно получить список поддерживаемых алгоритмов и другую полезную информацию о провайдере. CryptReleaseContext - освобождает ключевой контейнер. Если счетчик числа пользователей равен 1, то провайдер сохраняет ключевые пары пользователя и выгружает контейнер из памяти. В противном случае счетчик уменьшается на 1. CryptSetProvider - устанавливает провайдер, используемый по умолчанию. CryptSetProvParam - устанавливает параметры провайдера. В зависимости от провайдера она может изменять некоторую управляющую информацию. Функции работы с ключевой информацией: CryptDeriveKey - создает ключ, порожденный от хэш-значения некоторого блока данных. Обычно используется для создания сеансового ключа, основанного на пароле. CryptDestroyKey - удаляет ключ из ключевой цепочки контейнера. CryptDuplicateKey - создает точную копию ключа. CryptExportKey - экспортирует ключ в пользовательское приложение. Ключевой объект может быть экспортирован только, если установлен специальный флаг при генерации ключевого объекта. CryptGenKey - генерирует ключ. Может генерировать как симметричный ключ, так и ключевые пары пользователя. CryptGenRandom - генерирует случайную (псевдослучайную) последовательность данных. CryptGetKeyParam - запрашивает параметры ключа. К ним можно отнести такие параметры как битовая длина ключа и прочее. CryptGetUserKey - создает новый ключевой объект и копирует в него запрошенную ключевую пару пользователя. CryptImportKey - импортирует ключ в провайдер из пользовательского приложения. CryptSetKeyParam - устанавливает параметры ключа. Функции работы с объектами, расположенными в памяти: CryptDecodeObject(Ex) - расшифровывает объект, расположенный в памяти. CryptEncodeObject(Ex) - зашифровывает объект, расположенный в памяти. Функции работы с блоками памяти: CryptEncrypt - зашифровывает блок памяти. Обычно поддерживается только симметричное шифрование, однако некоторые провайдеры способны в этой функции выполнять и ассиметричное шифрование CryptDecrypt - расшифровывает блок памяти. Функции работы с электронной цифровой подписью: CryptCreateHash - создает и инициализирует хэш-объект. CryptDestroyHash - уничтожает хэш-объект. CryptDuplicateHash - создает дупликат хэш-объект. CryptHashData - вычисляет хэш-значение блока памяти. CryptSignHash - вырабатывает цифровую подпись соответствующего хэш-объекта. CryptVerifySignature - проверяет цифровую подпись соответствующего хэш-объекта. Разработчик программного обеспечения, желающий включить криптографический сервис в свой проект, прежде всего, должен подключиться к провайдеру и загрузить необходимый ключевой контейнер, вызвав функцию CryptAcquireCon-text, и получить индекс ключевого контейнера. Эта функция загружает в контекст провайдера ключи пользователя и прочую управляющую информацию. Полученный индекс контейнера пользователь CryptoAPI затем передает практически во все остальные вызовы функций. После завершения работы с провайдером необходимо вызвать функцию освобождения контекста CryptReleaseContext, которая сохраняет модифицированные ключи в зашифрованном виде на некотором носителе информации. Крипто-сервис провайдеры Крипто-сервис провайдеры обеспечивают функциональную поддержку Cryp-toAPI. Именно они содержат непосредственную реализацию криптографических стандартов и алгоритмов. Приложения не коммутируют напрямую с провайдером. Вместо этого приложения вызывают функции CryptoAPI, экспортируемые системными библиотеками динамических связей Advapi32.dll и Crypt32.dll. Операционная система фильтрует эти вызовы функций и передает их соответствующим функциям провайдеров. Приложения используют индексы для ссылки на объекты провайдера. В качестве таких объектов могут выступать: ключевые контейнеры, хэш-объекты и ключевые объекты. Любой провайдер состоит как минимум из библиотеки динамических связей, в которой реализованы функции системного криптографического интерфейса, и электронной цифровой подписи, предназначенной для сохранения целостности самого провайдера. При вызове функции CryptAcquireContext операционная система осуществляет проверку целостности провайдера, и в случае ее нарушения все вызовы его функций будут неудачны. В операционных системах Windows 95/98/ME/NT4.0 подпись хранится в специальном ключе реестра, а в Windows 2000 и Windows XP подпись может храниться в области ресурсов провайдера. Механизм проверки подписи реализован в библиотеке динамической связи advapi32.dll. Процедуру выработки электронной подписи полностью берет на себя корпорация Microsoft. Она и принимает решение, включать ли новый провайдер в последующие версии своих операционных систем. Однако для разработчиков крипто-сервис провайдеров Microsoft выпустила набор инструментов CSPDK. В состав данного набора входят столь необходимые для разработчиков провайдеров инструменты: Утилита cspsign.exe. Она предназначена для выработки и проверки электронной цифровой подписи разрабатываемого провайдера. Модифицированную библиотеку динамических связей advapi32.dll, предназначенную для работы с утилитой cspsign.exe. На данный момент CSPDK предлагает файлы advapi32.dll для следующих операционных систем: Microsoft Windows 98 SE Microsoft Windows ME Microsoft Windows NT 4.0 Service Pack 3 Microsoft Windows NT 4.0 Service Pack 4 Microsoft Windows NT 4.0 Service Pack 6 Microsoft Windows 2000 Microsoft Windows 2000 Service Pack 1 Microsoft Windows 2000 Service Pack 2 Для корректной работы тестируемого провайдера необходимо заменить файл “{sys}\advapi32.dU” на модифицированный и скопировать в системную директорию утилиту выработки и проверки подписи провайдера. Поскольку этот файл является не только системным, но и загружается вместе с операционной системой, то замена этого файла вручную довольно сложный процесс. Но эта операция довольно легко реализуется с помощью функции SetupAPI - SetupInstallFileEx. Согласно системному криптографическому интерфейсу каждый провайдер должен экспортировать следующий набор функций, почти идентичный функциям CryptoAPI: CPAcquireContext - загрузка ключевого контейнера. CPCreateHash - создание хэш-объекта. CPDecrypt - расшифрование блока памяти. CPDeriveKey - порождение ключа от хэш-значения некоторого блока памяти. CPDestroyHash - уничтожение хэш-объекта. CPDestroyKey - уничтожение ключа. CPEncrypt - зашифрование блока памяти. CPExportKey - экспорт ключа. CPGenKey - генерация ключа. CPGenRandom - генерация случайной последовательности данных. CPGetHashParam - получение параметров хэш-объекта. CPGetKeyParam - получение параметров ключа. CPGetProvParam - получение параметров провайдера. CPGetUserKey - получение запрашиваемого ключа из ключевой пары подписи. CPHashData - вычисление хэш-значения блока памяти. CPHashSessionKey - вычисление хэш-значения сеансового ключа. CPImportKey - импорт открытого ключа пользователя. CPReleaseContext - освобождение ключевого контейнера. CPSetHashParam - установление параметров хэш-объекта. CPSetKeyParam - установление параметров ключа. CPSetProvParam - установление параметров провайдера. CPSignHash - выработка электронной цифровой подписи. CPVerifySignature - проверка электронной цифровой подписи. CPDuplicateHash - дублирование хэш-объекта. CPDuplicateKey - дублирование ключа. Для обеспечения совместимости с операционной системой все эти функции должны быть объявлены с макросом WINAPI. Конечно, провайдеру не обязательно реализовывать все эти функции. Однако в этом случае, он должен как минимум определить эту функцию и в ее теле вернуть код ошибки E_NOTIMPL. В случае если провайдер состоит из нескольких библиотек, проверку целостности дополнительных модулей нужно производить в реализации функции CPAc-quireContext. Этапы разработки крипто-сервис провайдера Процесс разработки крипто-сервис провайдера можно разбить на следующие этапы: Выбор криптографических алгоритмов. Создание структур и типов данных. Реализация криптографических алгоритмов. Внедрение реализованных криптографических алгоритмов в функции системного криптографического интерфейса. Регистрация разработанного провайдера в системе. На первом этапе определяются функциональные требования к крипто-сервис провайдеру, на основе которых производится выбор соответствующих криптографических систем, стандартов и алгоритмов. Выбор механизмов управления ключевыми- и хэш-объектами осуществляется на втором этапе. При этом необходимо обеспечить возможность поиска объектов по их индексам, а также обеспечить синхронизацию совместного использования процессами и потоками этих объектов. Структура списка ключевых контейнеров провайдера приведена на рис. 2. Структура списка ключевых контейнеров Список ключевых ________контейнеров__________ Ключевой контейнер Ключевые пары пользователя Список ключевых объектов Список хэш-объектов Ключевой контейнер Ключевые пары пользователя Список ключевых объектов Список хэш-объектов Рис. 2 Третий этап разработки относится к наиболее трудоемкому. Именно он определяет эффективность крипто-сервис провайдера. На этапе внедрения в каждую экспортируемую функцию провайдера внедряется соответствующий реализованный криптографический механизм и определяется поведение провайдера. Каждая функция провайдера в случае успешного завершения должна возвращать значение TRUE (истина), а в случае неудачного - значение FALSE (ложь) и соответствующий код ошибки, который устанавливается путем вызова функции SetLastError. Получая управление, функция провайдера проверяет переданные ей параметры, существование необходимых объектов, и только после этого выполняет функциональную часть. Для корректной работы провайдера в операционной системе, он должен быть определенным образом зарегистрирован в ней. Регистрация провайдера производится путем записи в специальные ключи реестра регистрационной информации. Регистрационная информация провайдера находится в ключе реестра «HKEY_LOCAL_MACHINE \ SOFTWARE \ Microsoft \ Cryptography \ Defaults \ Provider». Структура регистрационной информации: Название провайдера: Image Path - имя библиотеки динамической связи провайдера; Signature - электронная цифровая подпись провайдера. В случае, если подпись расположена в области ресурсов провайдера применяется значение: SigInFile. Type - тип провайдера. Тип провайдера: Name - имя провайдера. При правильном внесении регистрационной информации в систему и корректной электронной цифровой подписи провайдер готов выполнять свои функции предоставления механизмов криптографической защиты, согласно заложенным в него функциональным возможностям. Крипто-сервис провайдер на базе отечественных стандартов Кафедрой БИТ по приведенной в статье технологии разработан криптосервис провайдер на базе следующих стандартов РФ: ГОСТ 28147-89, ГОСТ Р 34.11-94, ГОСТ Р 34.10-94 и ГОСТ Р 34.10-2001. Поскольку в РФ не принят единый стандарт ассиметричной системы шифрования, то в качестве таковой в провайдере принята система Эль-Гамаля с цифровой подписью Шнорра. При этом в провайдере используется собственная высокопроизводительная реализация, достигнутая за счет существенной оптимизации алгоритмов, а также создания эффективного математического аппарата, использующего механизм предвычислений. При этом базовые математические операции реализованы с помощью непосредственных вызовов инструкций микропроцессора на языке низкого уровня. Крипто-сервис провайдер экспортирует весь набор функций системного криптографического интерфейса. Провайдер обладает следующими низкоуровневыми функциональными возможностями: Согласно ГОСТ 28147-89: - сгенерировать 256-битовый ключ симметричного шифрования. - зашифровать / расшифровать блок памяти в режиме простой замены. - зашифровать / расшифровать блок памяти в режиме гаммирования. - зашифровать / расшифровать блок памяти в режиме гаммирования с обратной связью. Согласно ГОСТ Р 34.11-94: - выработать хэш-значение блока памяти. Согласно ГОСТ Р 34.10-94: - сгенерировать параметры электронной цифровой подписи размерностью 512 или 1024 бит. - сгенерировать ключевую пару цифровой подписи. - выработать цифровую подпись заданного хэш-значения. - проверить цифровую подпись заданного хэш-значения. Согласно ГОСТ Р 34.10-2001: - сгенерировать ключевую пару цифровой подписи. - выработать цифровую подпись заданного хэш-значения. - проверить цифровую подпись заданного хэш-значения. Согласно системе Эль-Гамаля с цифровой подписью Шнорра: - сгенерировать параметры системы размерностью 512 или 1024 бит. - сгенерировать ключевую пару системы. - зашифровать 256-битовый блок памяти. - расшифровать 256-битовый блок памяти. На их основе с помощью CryptoAPI можно построить любую криптографическую систему. Производительность разработанного крипто-сервис провайдера приведена в табл. 1. Таблица 1. Производительность крипто-сервис провайдера _____________________на базе отечественных стандартов_________________ Наименование Intel Pentium операции 800 МГц 2.4 ГГц ГОСТ 28147-89, Мбайт I с Простая замена 5.40 15.24 Г аммирование 5.17 14.88 Г аммирование с обратной связью 5.18 14.88 ГОСТ Р 34.11-94, Мбайт I с Вычисление хэш-функции 2.21 5.76 ГОСТ Р 34.10-94, мс Размерность параметров р и а (бит) 512 1024 512 1024 Г енерация параметров 307 28 281 140 11 407 Г енерация ключевой пары 009 030 003 012 Выработка цифровой подписи 009 030 003 012 Проверка цифровой подписи 025 077 010 031 ГОСТ Р 34.10-2001, мс Г енерация ключевой пары 008 003 Выработка ЭЦП 008 003 Проверка ЭЦП 037 015 Ассиметричная система Эль-Г амаля с цифровой подписью Шнорра, мс Размерность параметров р и а (бит) 512 1024 512 1024 Зашифрование 029 100 012 040 Расшифрование 035 117 015 048 Работа поддержана грантом РФФИ №03-07-90075. ]]></text>
</doc>
