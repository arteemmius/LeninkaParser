<doc>
  <source auto="true" type="str" verify="true"><![CDATA[https://cyberleninka.ru/article/n/obzor-sovremennyh-modeley-evolyutsionnyh-vychisleniy-dlya-resheniya-zadachi-planirovaniya-sbis]]></source>
  <category auto="true" type="str" verify="true"><![CDATA[Автоматика]]></category>
  <author auto="true" type="list" verify="true">
    <item type="str"><![CDATA[Ерошенко Илья Николаевич]]></item>
  </author>
  <title auto="true" type="str" verify="true"><![CDATA[Обзор современных моделей эволюционных вычислений для решения задачи планирования СБИС]]></title>
  <keywords auto="true" type="list" verify="true">
    <item type="str"><![CDATA[ПЛАНИРОВАНИЕ СБИС]]></item>
    <item type="str"><![CDATA[ЭВОЛЮЦИОННЫЕ ВЫЧИСЛЕНИЯ]]></item>
    <item type="str"><![CDATA[ОПТИМИЗАЦИЯ]]></item>
  </keywords>
  <annotation auto="true" type="str" verify="true"><![CDATA[Рассматривается задача планирования сверхбольших интегральных схем. Планирование является одним из ранних этапов конструкторского проектирования СБИС. Данная задача относится к классу NP. В работе указаны недостатки традиционных алгоритмов поиска субоптимального плана СБИС. Приведены описания более современных моделей эволюционных вычислений: дифференциальной эволюции, муравьиного алгоритма, метода роя частиц, меметического алгоритма, который является гибридным генетическим алгоритмом. Для перечисленных алгоритмов приведены описания представления плана в виде польской записи, О-дерева, B*-дерева.]]></annotation>
  <text auto="true" type="str" verify="true"><![CDATA[Рассматривается задача планирования сверхбольших интегральных схем. Планирование является одним из ранних этапов конструкторского проектирования СБИС. Данная задача относится к классу NP. В работе указаны недостатки традиционных алгоритмов поиска субоптимального плана СБИС. Приведены описания более современных моделей эволюционных вычислений: дифференциальной эволюции, муравьиного алгоритма, метода роя частиц, меметического алгоритма, который является гибридным генетическим алго-. польской записи, О-дерева, Е*-дерева. Планирование СБИС; эволюционные вычисления; оптимизация. I.N. Yeroshenko REVIEW OF MODERN EVOLUTIONARY COMPUTATION MODELS FOR VLSI FLOORPLANNING The article is dedicated to the problem of VLSI floorplanning. Floorplanning refers to the early stage of physical VLSI design. VLSI floorplanning is an NP-hard problem. In this paper the disadvantages of the traditional floorplanning algorithms for searching suboptimal solution are mentioned. The description of the more modern evolutionary computation models is given (differential evolution, ant colony optimization, swarm optimization, memetic algorithm which is a hybrid genetic algorithm). Floorplan representations Polish expression, O-tree, B*-tree are briefly described for the mentioned algorithms. VLSI floorplanning; evolutionary computation; optimization. . - тирования сверхбольших интегральных схем. Оно влияет на производительность, . Планирование заключается в размещении модулей таким образом, чтобы они , . -ции могут быть минимизация площади кристалла, длины межсоединений и др. При качественном размещении не только уменьшается площадь микросхемы, но и уменьшается стоимость внутренних соединений. Задача планирования относится к классу NP. Планирование СБИС и представления плана. При планировании СБИС важно выбрать соответствующее представление плана. Обычно выделяют два типа * Работа выполнена при частичной поддержке РФФИ (проект № 09-01-00492). представлений: гильотинные и негильотинные. Гильотинный план получается путем рекурсивных гильотинных разрезов прямоугольника на части. План, который не может быть получен путем таких разрезов, называется негильотинным. В данной статье кратко описаны только те представления, которые связаны с рассматриваемыми метаэвристическими алгоритмами. Гильотинный план описывается польской записью, которая состоит из имен модулей, операторов вертикального и/или горизонтального разрезов (рис. 1). 3 1 2 Н 4 3 5 V Н V Рис. 1. Гильотинный тан, польская запись и бинарное дерево разрезов Негильотинные планы могут быть описаны с помощью множества разных представлений. Рассмотрим два схожих представления: О-дерево и Б*-дерево. План с п прямоугольными модулями представляется горизонтальным (вертикальным) О-деревом из п+1 узлов, причем п узлов соответствуют п модулям, а один узел соответствует левой (нижней) границе плана (рис. 2). О-дерево кодируется кортежем (Т,л), где Т - битовая строка, состоящая из 2п бит, для определения структуры дерева, а л задает размещение модулей. План называется ЬБ-компактным, если ни один из модулей не может быть перемещен влево и вниз без необходимости сдвига других модулей. Рис. 2. План и соответствующее О-дерево Основанное на бинарном дереве представление «Б*-дерево» предложено для LB-кoмпaктнoгo размещения. В В*-дереве вершина обозначает модуль. Левая дочерняя вершина обозначает самый нижний модуль справа от модуля, представленного родительской вершиной (рис. 3). Правая дочерняя вершина обозначает модуль выше модуля, представленного родительской вершиной, с той же x. Эволюционные вычисления. Термин «эволюционные вычисления» (ЭВ) подразумевает использование для решения разнообразных задач проектирования, оптимизации, прогнозирования и управления совокупности алгоритмических, программных, аппаратных средств и приближенных эвристических методов, основанных на имитации механизмов эволюции для синтеза структур обработки данных, а также на статистическом подходе к исследованию ситуаций и итерационном приближении к искомому решению. В течение последних 50 лет были предложены разнообразные схемы ЭВ: генетические алгоритмы, генетическое программирование, , , эволюция, модели поведения роя пчел, стаи птиц и колонии муравьев, моделирование отжига или потока и другие конкурирующие эвристические алгоритмы [1]. Эти методы относятся к междисциплинарному направлению биоинформатики. Основное преимущество таких методов - возможность распараллеливания процесса поиска и получения множества альтернативных квазиоптимальных решений [2]. Долгое время для планирования СБИС наиболее популярными алгоритмами были моделирование отжига и генетические алгоритмы. . -не 80-х гг. Моделирование отжига имеет наибольшую степень сходства с моделями эволюционных стратегий и эволюционного программирования. Однако имеются и отличия: размер популяции решений равен единице; поиск решений ведется локально от точки к точке; мутация является единственным оператором поиска, а селекция проводится по специальным правилам [1]. Генетические алгоритмы. Генетический алгоритм (ГА) - метаэвристиче-ский алгоритм поиска, имитирующий природную эволюцию и работающий с по. , -ложен еще в 1975 году Джоном Холландом. Эволюционный процесс представляется как способность лучших особей оказывать большее влияние на состав новой популяции на основе длительного выживания из более многочисленного потомства [3]. Основным блоком в ГА является блок генетических операторов [4]. Важную роль в ГА играет кроссинговер - оператор скрещивания, благодаря которому осуществляется рекомбинация решений. Недостатки традиционных подходов. К недостаткам моделирования отжига можно отнести сильную зависимость качества конечного решения от качества , . [2] , -вания оставляет желать лучшего, так как не учитывается топологическая инфор- Рис. 3. План и соответствующее Б*-дерево мация. Вычислительная сложность у алгоритма моделирования отжига велика. ГА являются затратными в плане используемой памяти. Рассмотрим более современные модели ЭВ. Дифференциальная эволюция. Дифференциальная эволюция (ДЭ) - это поисковый эволюционный алгоритм, основанный на популяции (как и генетический алгоритм), использует операторы кроссинговера, мутации и селекции. Метод дифференциальной эволюции был разработан Рэйнером Сторном и Кеннетом Прайсом в 1997 г. Самое важное отличие от ГА заключается в том, что главным оператором ДЭ является не кроссинговер, а мутация. ДЭ использует мутацию в качестве поискового механизма и селекцию для исследования перспективных об. для построения пробных векторов. Задача оптимизации, состоящая из D параметров, может быть представлена D-р^мерным вектором. В ДЭ сначала создается случайным образом популяция NP векторов. Мутация. Для каждого целевого вектора xiG создается мутантный вектор в соответствии с формулой: Vi,G+1 = Xr1,G + F * (Xr2,G - Xr3,G ) (1) Индексы r1,r2,r3 выбираются случайным образом на отрезке [1, NP]. Они i. - ров в популяции должно быть не меньше четырех. F - один из параметров метода, некоторая положительная действительная константа на отрезке [0,2]. Кроссинговер. Компоненты целевого вектора xiG смешиваются с компонентами мутантного вектора У;,0+1 для получения пробного вектора. Элементы мутантного вектора попадают в пробный вектор с вероятностью CR. Целевой вектор сравнивается с пробным вектором. Вектор с наименьшим значением ЦФ сохраняется. В работе [6] в качестве представления плана для ДЭ используется Б*-дерево. Муравьиный алгоритм. Идея муравьиного алгоритма (ACO - ant colony optimization) заключается в моделировании поведения муравьев, который связан с их умением быстро находить наиболее краткий маршрут от муравейника к источ-. . ACO 1992 . Муравьи достигают источника пищи и возвращаются обратно, оставляя фе. , большой долей вероятности пойдут по ним. Феромон со временем испаряется. На коротком пути плотность феромонов высокая. Испарение феромона также позволяет избегать попадания в локальные оптимумы. В качестве представления плана в работе [7] выбрана польская запись. Модули могут менять ориентацию. Пусть nM - число модулей, nR - число операторов в польской записи. Для дерева разрезов соблюдается равенство nM = nR + 1. Поиск решений осуществляется на полном графе поиска решений G=(X,U), где X = X1 U X2 UX3 U X4. Вершины множества X1 ={x1i | i=1,2,..., nM} соответствуют модулям m1i, размещаемым в первой ориентации. Вершины множества X2 ={x2i | i=1,2,..., nM} соответствуют модулям m2i, размещаемым во второй ориентации. Вершины множества X3 ={x3i | i=1,2,..., nR } соответствуют горизонтальным разрезам H. Вершины множества X4 ={x4i | i=1,2,., nR } соответствуют вертикальным разрезам V. Поиск решения задачи планирования осуществляется коллективом муравьев Z={ zk |k=1,2,...,l}. На каждой итерации муравьиного алгоритма каждый муравей zk . маршрут в графе G=(X,U), включающий nM вершин, принадлежащих множествам X1 или X2, nR вершин, принадлежащих множествам X3 или X4. Моделирование поведения муравьев в задаче планирования связано с распределением феромона на ребрах графа G.Ha начальном этапе на всех ребрах графа G откладывается небольшое количество феромона. Процесс поиска решений итерационный. Каждая итерация включает три этапа. На первом этапе муравей находит , , испарение феромона. В работе [7] используется циклический (ant-cycle) метод му. ( ). Метод роя частиц. Рой частиц можно рассматриваться как многоагентная , . . (par- ticle swarm optimization - PSO) была предложена Кеннеди и Эберхартом в 1995 г. На каждой итерации частицы перемещаются в новые позиции. Новая позиция определяется по формуле: X (t +1) = Xi (t) + Vi (t +1), (2) где vi(t+1) - скорость перемещения частицы из позиции xi(t) в позицию xi(t+1). Начальное состояние определяется как xi(0), vi(0). Формула показана в векторном виде, для отдельного измерения j формула примет вид: Xij (t + 1) = Xij (t) + Vij (t + 1). (3) Пусть fi(t) - текущее значение ЦФ в позиции частицы i в позиции xi(t), xi*(t) -лучшая позиция частицы i, которую она посещала с начала первой итерации, fi*(t) - , F(t) - t, x(t) - . i- : Vij (t +1) = w * Vij (t) + ¿1* rnd (0,1) * (x ij (t) - Xij (t)) + (4) ¿2 * rnd(0,1) * (Xj (t) - Xij (t)), где rnd(0,1) - случайное число на интервале (0,1); w - инерционный коэффициент, k1, k2 - . Формула расчета скорости состоит из трех слагаемых. Предыдущая скорость частицы служит инерционным компонентом. Второе слагаемое прямо пропорционально текущему расстоянию частицы от ее наилучшей позиции, которая была найдена с первой итерации. Второе слагаемое является когнитивным компонентом. Третье слагаемое, называемое социальным компонентом, прямо пропорционально текущему расстоянию частицы от наилучшей позиции роя в текущий мо-t. , в оптимальные позиции, найденные другими частицами. После случайной инициализации популяции частиц для каждой из них вычисляется значение ЦФ fi(t+1). Если оно окажется лучше, чем fi*(t), то fi*(t+1) = fi(t+1), иначе fi*(t+1) = fi*(t). Среди fi(t+1) выбирается лучшее решение F(t), . Итерационный процесс повторяется. В работе [8] в качестве представления плана для PSO выбрана польская запись, в работе [9] применяется Б*-дерево. Меметический алгоритм. Меметические алгоритмы (МА) - одно из интенсивно развивающихся направлений в области эволюционных вычислений. Термин «меметический алгоритм» был впервые представлен Москато еще в 1989 г. Под . МА понимают гибридизацию эволюционного алгоритма с индивидуальным обучением или процедурами локального поиска. В работе [5] МА используется для минимизации площади охватывающего прямоугольника и длины проводников в рамках задачи планирования СБИС. В качестве представления выбрано О-дерево. Каждая особь в популяции МА - , - . Целевая функция в данном МА представлена в виде формулы: Area( F) Wirelength( F) cos t(F) = w1 *---------— + w2 *---------------------2-—. (5) Area Wirelength В формуле Area*, Wirelength* представляют минимальную площадь и минимальную длину проводников соответственно. Так как на практике данные значения неизвестны, то используются оценочные значения. w1 и w2 - коэффициенты для ЦФ площади и ЦФ длины проводников, 0 < w1 < 1, 0 < w2 < 1, w1+w2=1. Приспособленность особи вычисляется по следующей формуле: f((Т= Л '■ <6) cos t ( F(T ,ж}) ( ), . , помощью О-дерева (Т,л) МЛП находит локальное оптимальное решение посредством проверки тех О-деревьев, которые могут быть получены путем удаления и . , , если это приведет к улучшению решения. : 1) t:= 0; 2) P(t) PopSize; 3) рассчитать фитнес особей в P(t) и запомнить лучшее решение в best; 4) : a) t:= t + 1; b) Для каждой особи в P(t): i. p1; ii. p2; iii. -дания дочерней особи c1; iv. fitness(c1) fitness (v), c1, - тод локального поиска; v. fitness (c1) fitness (p1), p1 := c1; vi. если fitness (c1) > fitness (best), то best := c1; vii. c1 f; viii. если fitness(f) > fitness(v), то оптимизировать f, используя метод ; ix. если fitness(f) > fitness(p1), to p1 := f; x. если fitness(f) > fitness(best), to best := f. 5) best. Заключение. Анализ публикаций по теме планирования СБИС и конструкторского проектирования СБИС в целом показал, что модели эволюционных вычислений успешно применяются для поиска субоптимального решения. Для того чтобы повысить качество получаемых решений, авторы используют различные , . -. - . , что полный отказ от традиционных моделей эволюционных вычислений нецелесообразен, можно использовать гибридный подход, который позволяет задействовать преимущества отдельных метаэвристик и учитывать специфику задачи . ]]></text>
</doc>
