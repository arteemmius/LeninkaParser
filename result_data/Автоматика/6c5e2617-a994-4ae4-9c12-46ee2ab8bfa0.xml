<doc>
  <source auto="true" type="str" verify="true"><![CDATA[https://cyberleninka.ru/article/n/apparatno-programmnye-metody-obespecheniya-nadezhnosti-vychisleniy-v-multiprotsessorah-s-dinamicheskoy-arhitekturoy]]></source>
  <category auto="true" type="str" verify="true"><![CDATA[Автоматика]]></category>
  <author auto="true" type="list" verify="true">
    <item type="str"><![CDATA[Царё И.В.]]></item>
  </author>
  <title auto="true" type="str" verify="true"><![CDATA[Аппаратно-программные методы обеспечения надежности вычислений в мультипроцессорах с динамической архитектурой]]></title>
  <keywords auto="true" type="list" verify="true"/>
  <annotation auto="true" type="str" verify="true"><![CDATA[]]></annotation>
  <text auto="true" type="str" verify="true"><![CDATA[Решение любых задач в компьютерных системах характеризуется такими параметрами как надежность вычислений и информационная безопасность. Первый предполагает определенную уверенность в правильности полученных в результате работы некоторой программы результатов, в том числе при возможных сбоях и отказах вычислительного оборудования, а второй - степень защищенности системы (а также программ и данных) от несанкционированного влияния (доступа), в том числе защищенность от других программ, работающих в той же системе, а также от вредоносных программ (например вирусов), которые могут поступать из локальных или глобальных сетей, к которым присоединена данная вычислительная система. Указанные проблемы обычно возрастают многократно в мультипроцессорных системах и в любых системах, организованных по сетевому принципу (локальные сети, кластеры, grid-системы). С точки зрения аппаратуры это связано с понижением общей надежности системы по мере возрастания количества аппаратуры (процессоров, контроллеров), имеющейся в системе, и в ещё большей степени с увеличением количества коммуникаций (каналов, кабелей, разъемов и т.п.). С точки зрения программного обеспечения проблема, в первую очередь, связана с возможностью нарушения защиты памяти, принадлежащей той или иной программе. В большинстве существующих компьютерных систем эти проблемы обычно решаются преимущественно программными средствами, т.е. средствами операционной системы, а также различными защитными программами (антивирусами, брандмауэрами и т.п.) и являются как бы внешними по отношению к выполняемым программам (решаемым задачам). Аппаратная защита областей памяти, выделенной некоторым программам, как правило, не является достаточно надёжной, так как любая программа, которая может «прикинуться» частью операционной системы, т.е. получить высший приоритет, может получить доступ к памяти, выделенной для любой программы или её данных. Мультипроцессоры с динамической архитектурой (МДА) В значительной степени все эти проблемы могут быть решены при использовании идеологии мультипроцессоров с динамической архитектурой (МДА) [1,3], в которых решение любых задач основано на сетевом подходе к описанию программ (задач) и организации вычислительного процесса, при котором аппаратная архитектура вычислительной системы динамически подстраивается под структуру решаемых задач, включая также оригинальный подход к организации межпроцессорного взаимодействия и оригинальный сетевой язык ЯРД. Программа в МДА имеет вид сети (графа), узлами которой являются объекты одного из семи классов: операторы (изображаются полукругом), данные (изображаются кружками), ссылки (изображаются треугольниками), ресурсы (изобража- ются прямоугольниками), отношения (изображаются ромбами), типы (изображаются эллипсами) и структуры/подсети (изображаются двойными кружками) [1, 3]. В каждом классе может быть произвольное множество типов. Язык для описания таких программ называется «ЯРД» и имеет как графическую, так и текстовую форму [1]. На рис. 1 показан пример сетевой программы МДА в графической форме для перемножения матриц (на рисунке, в силу простоты программы, присутствуют только операторы, данные, ссылки, ресурсы и типы). Рис. 1. Пример графического представления программы на языке ЯРД Выполнение программы в МДА состоит в программно-аппаратной интерпретации всех узлов сетевой программы на множестве вычислительных модулей (ВМ), связанных между собой некоторой коммуникационной сетью, имеющей произвольную конфигурацию, хотя предпочтительной является структура типа гиперкуба. Узлы (объекты) программы автоматически распределяются для вычислений между аппаратными узлами системы (вычислительными модулями) в соответствии с принципом автоматического распараллеливания. При этом конфигурация программной сети непрерывно изменяется в процессе выполнения. Как правило, в начале выполнения программы имеет место увеличение сети благодаря генерации новых узлов и новых связей (автотрансформация сети), к концу выполнения программы большинство узлов программной сети исчезает, сеть постепенно теряет способность к автотрансформации, в результате получается сеть, состоящая только из объектов класса «данные», образующих некоторую структуру, которая и является решением задачи. Каждый вычислительный модуль (ВМ) мультипроцессорной системы МДА включает в себя помимо основного вычислительного (исполнительного) процессора (ИП), который, собственно, и осуществляет вычисления, ещё как минимум два специализированных процессора - управляющий процессор (УП), который берёт на себя функции управления распараллеливанием вычислительного процесса и управление памятью, и коммутационный процессор (КП), который осуществляет передачу информации между модулями [2, 4]. Дополнительно могут быть реали- зованы процессор ввода-вывода (ПВВ) для связи с периферийными устройствами и контрольный процессор (КоП), в функции которого входит постоянный контроль правильности сетевых программных структур, а также периодическое тестирование аппаратуры МДА. При отсутствии в ВМ ПВВ и КоП их функции могут быть частично реализованы на УП и КП либо программно, с помощью соответствующих функций операционной системы. Все процессоры ВМ работают независимо и параллельно (при полной децентрализации управления), освобождая основной (вычислительный) процессор от проблем управления параллельными вычислительными процессами, коммуникаций, контроля и т.п., что существенно повышает производительность системы в целом. Типовая структура вычислительного модуля (ВМ) МДА изображена на рис.2. При использовании современных технологий все вспомогательные процессоры (УП, КП, ПВВ, КоП) могут быть реализованы с использованием ПЛИС (например фирмы “Altera”), поскольку их функции достаточно просты. Рис. 2. Архитектура вычислительного модуля (ВМ) МДА В качестве вычислительных (исполнительных) процессоров могут быть использованы любые типовые процессоры фирм Intel (Pentium, Xeon), Texas Instruments (TMS), Sun (Sparc) или любые другие существующие процессоры, либо специально разработанные процессоры, однако возможна и реализация вычислительных функций на ПЛИС, что более соответствует основной идеологии МДА, в которой процессор для выполнения некоторого вычисления должен динамически создаваться только на время этих вычислений, а затем уничтожаться. Основным препятствием для такой реализации пока является низкая скорость перепрограммирования ПЛИС, что снижает общую эффективность системы. В настоящее время разработан ряд коммуникационных процессоров (модулей) с динамической архитектурой (КПДА) [4], которые могут использоваться в качестве элемента коммутационой среды как в мультипроцессорах с традиционной архитектурой, так и в мультипроцессорах с динамической архитектурой (МДА), кластерных и grid-системах. КПДА представляет собой печатную плату, вставляемую в разъёмы шины PCI ПЭВМ или «промышленной ПЭВМ» (Industrial PC). На плате размещены ПЛИС фирмы “Altera”, на которых реализуются вспомогательные процессоры ВМ (УП, КП и т.д.), включая и схему управления памятью (и аппаратной трансляции адресов), микросхемы памяти объёмом 128-256-512 Мб, разъёмы для обеспечения внешних связей модуля, а также возможно размещение процессора TMS, реализующего функции ИП (часть функций ИП может быть реализована также и на ПЛИС). В случае использования КПДА в кластерных и grid-системах функции ИП могут быть реализованы вне модуля (в этом случае процессор TMS отсутствует) на обычных процессорах Intel, которые размещаются вне платы, на материнских платах ПЭВМ, либо на процессорных платах Industrial PC. Модуль КПДА включает в себя шесть полнодуплексных каналов с суммарной пропускной способностью до 30 Гбайт/с. Модуль обеспечивает интеллектуальную маршрутизацию пакетов с использованием механизма «индикаторных множеств» [4]. Обеспечение надёжности вычислений и информационной безопасности Для обеспечения надежности вычислений и информационной безопасности в МДА предусмотрен ряд механизмов, наиболее важными из которых являются следующие: организация абстрактного пространства адресов и механизм дублирования программных структур. Организация адресного пространства ориентирована не на физическую память, а на структуру программы, организованной в виде сети из объектов (узлов программной сети). В такой системе адрес некоторого объекта (узла программной сети), программы/процедуры (метода объекта) или некоторого элемента информации состоит из следующих компонентов. Номер (идентификатор) задачи T - некоторый код (или слово), который однократно присваивается задаче при загрузке ее в МДА. Этот код может также содержать номер модуля, с которого была загружена задача, и порядковый номер задачи, загруженной с даного модуля. Дополнительно может присутствовать и текстовый идентификатор задачи, используемый при внешнем отображении процесса выполнения задачи и её результатов. Разные экземпляры одной задачи, одновременно выполняемые в мультипроцессоре, будут иметь разные номера или идентификаторы. Номер модуля M, в котором находится данный экземпляр задачи или одного из ее узлов (объектов). Иерархический номер узла программной сети N, входящего в сеть данной задачи. Определяется сетевой структурой задачи и местом данного узла (объекта) в общей структуре задачи.. Может состоять из нескольких номеров, связанных в цепочку, длина которой зависит от глубины иерархии узлов. Номер компонента узла (объекта) программной сети C. Каждый объект может иметь несколько компонентов в соответствии со структурой дескриптора этого объекта. В число компонентов могут входить: ссылка на собственные данные или программы узла (тело); ссылка на «хозяина» - вышестоящий в иерархии объект, частью которого является данный объект, или, если данный объект является главным в задаче, то ссылка на операционную систему; статус объекта (его состояния и свойства); ссылка на тип узла (объекта), который содержит соответствующие процедуры (программы, методы); ресурс (вычислительный модуль, или другая структурная единица аппаратуры, например блок памяти, в которой расположен данный объект); аргументы и результаты данного узла - это другие узлы (связанные с данным узлом различными отношениями), которые поставляют данные для вычислений (аргументы) либо получают результаты этих вычислений. Множество (последовательность) индексов S, которые определяют набор машинных слов или компонентов тела данного объекта, необходимых для вычислений именно в данном экземпляре объекта. Структура индексов может варьироваться, так как тело самого объекта может иметь различную структуру (например, это может быть многомерный массив или сложная древовидная структура). Смещение в массиве (подмассиве) компонента объекта (номер слова) либо номер процедуры в библиотеке процедур данного типа, если данный объект является «типом», О. Таким образом, полный адрес некоторого элемента информации (слова любой разрядности, массива или подмассива, процедуры и т.п.), используемого при выполнении данного объекта сетевой программы, может иметь вид Т.М.КС.8.О, где, в свою очередь, части N и 8 могут быть последовательностями индексов (номеров), которые зависят от структуры программы и используемых в ней данных. Компоненты адреса Т и М, а во многих случаях и N могут в конкретном случае не влиять на выполнение части программы в данном модуле, они используются операционной системой для других целей - установления взаимосвязи между узлами программной сети, расположенных в разных модулях, контроля процесса вычислений, передачи данных между модулями и т. п. Каждый объект (узел сетевой программы) состоит, как минимум, из двух частей -дескриптора и тела. Дескриптор содержит всю описательную информацию объекта программы, включая класс, тип и идентификацию объекта (паспорт объекта - имя и пр.), его состояние (статус), меняющееся в процессе выполнения программы, а также некоторое множество ссылок на компоненты (тело) объекта, включая процедуры (методы). Для любого объекта имеется связь с «типом», который, в свою очередь, содержит в качестве тела множество процедур (методов), которые и реализуют свойства даного типа, а также и текущие индексы тела, ссылку на его «хозяина» (вышестоящий в иерархии объект), связи объекта с его аргументами и результатами, с ресурсом, в котором размещен объект (или в котором он должен быть размещен). Пример типовой структуры дескриптора и тела показан на рис. 3. Рис. 3. Организация объектов (узлов программной сети) Тело объекта представляет собой некоторое множество (массив, структуру) данных или программ (процедур), организация которого однозначно определяется дескриптором и типом объекта и может иметь некоторую структуру, определяемую типом объекта. В дескрипторе также находятся текущие индексы тела объекта, которые определяют порядок обработки тела объекта, например номер строки или столбца матрицы (если объект имеет класс «данные» и тип «матрица»). На рисунке буквами «&> с индексами обозначены дескрипторы объектов, которые входят в состав основного составного объекта, в этом случае собственно «тело» объекта представляет собой массив ссылок на дескрипторы частей этого объекта (которые по структуре аналогичны основному дескриптору объекта, показанному на рисунке слева). Разумеется, что возможны и более простые случаи, когда тело объекта представляет собой простой массив данных или даже единичные данные. На самом деле все поля дескриптора, кроме «паспорта», «статуса» и «текущих индексов», являются по сути связями, т.е. ссылками на соседние в программной сети объекты, включая и стандартные объекты операционной системы. При поступлении некоторого элемента программы (узла, объекта) в конкретный модуль и размещении соответствующих данных и программ в физической памяти данного модуля дескриптор объекта располагается в сответствующем банке регистров модуля (либо в специально выделенном участке памяти модуля), при этом в соответствующем банке регистров модуля строится таблица физических адресов, которая используется управляющим процессором для трансляции абстрактных адресов, подобных вышеописанному абстрактному адресу Т.М.КС.8.О, в физические адреса соответствующих данных или процедур. Таблица физических адресов может иметь вид. Структура дескриптора объекта при размещении его в памяти модуля Дескриптор объекта Физические адреса Другая информация Паспорт - Имя объекта и др. Ссылка на «хозяина» Физический адрес дескриптора «хозяина» - Ссылка на тип Физический адрес дескриптора типа Далее могут использоваться ссылки на компоненты типа (описание структуры типа, массив процедур/методов типа) Ссылка на тело Физический адрес тела (начало массива или структуры) - Статус - Побитное описание свойств объекта Текущие индексы Набор (массив) индексов, характеризующих обрабатываемую часть объекта Ресурс Физический адрес дескриптора ресурса Номера модулей, идентификаторы блоков памяти, идентификаторы внешних устройств Связь с аргументом 1 Физический адрес аргумента - Связь с аргументом 2 Физический адрес аргумента - Связь с результатом Физический адрес результата - Связи с другими объектами программной сети Физический адрес объекта (его дескриптора) Любая программа (включая большинство компонентов операционной системы) обращается к данным или процедурам (методам) объектов по абстрактному адресу Т.М.КС.8.О, который транслируется соответствующим блоком УП (т.е. аппаратными средствами) в физический адрес соответствующих данных или процедур (физические адреса определяются и заполняются в таблице только при размещении данного объекта в памяти конкретного модуля). Большинство объектов программной сети, таким образом, не имеет возможности доступа к данным или программам не только другой программы, но и объектов данной программы, с которыми не предусмотрена логическая связь, т. е. они не являются объектами, связанными в сети соответствующими отношениями (аргументами, результатами, операторами, обрабатывающими соответствующие аргументы, методами типа и т.д.). Существуют общие ресурсы (это, например, программы и данные операционной системы, библиотеки типов и т.п.), которые доступны всем программам, но эти ресурсы имеют аппаратно поддерживаемый признак «только для чтения», так что ни одна программа или ее узел не имеют возможности изменить ни программы, ни данные, которые относятся к общим ресурсам, ни, тем более, процедуры и данные, относящиеся не только к другим программам, но и к частям данной программы, которые не связаны логически с данным узлом. В наиболее типичном случае программа (процедура) некоторого узла программной сети имеет право изменять (т.е. записывать) данные только в теле узла, соответствующего результату данного узла (например оператора), либо в собственном теле объекта. Аналогичным образом организуется и информация на внешних носителях (например жестких дисках). При этом поля адреса Т, М, N присутствуют только в дескрипторах узлов и используются только той частью операционной системы, которая работает на УП и КП, а в программах каждого узла присутствуют и используются только поля С, 8, О. На рис. 4 показана общая схема трансляции адресов (абстрактных в физические). Такая структура адресации практически полностью исключает возможность несанкционированного доступа не только к другим программам или операционной системе, но и к объектам той же программы, которые не связаны между собой. Практически в данном случае исключена возможность работы вирусов или иных вредоносных программ, а также возможность случайного влияния на объекты чужих программ в результате ошибок программирования. Поскольку трансляция адресов осуществляется аппаратно в процессе обращения к соответствующим фрагментам памяти, принадлежащим конкретному узлу (объекту) программной сети, либо узлам (объектам), связанным с ним определенными отношениями, то это практически не сказывается на времени общего процесса вычисления. Если позволяет мощность соответствующей аппаратуры, то в каждом ВМ может быть несколько банков регистров для размещения дескрипторов объектов и соответствующих таблиц физических адресов, один из которых соответствует текущему, т.е. выполняемому в данный момент узлу программной сети, а другие соответствуют ближайшим узлам, которые находятся в очереди и готовятся к последующим вычислениям, т. е. банки регистров для последующих вычислений заполняются заранее (и это заполнение не влияет на процесс текущего вычисления, поскольку выполняется параллельно управляющим процессором). В этом случае для перехода к выполнению следующего объекта программной сети практически не требуется времени, достаточно переключить номер текущего банка регистров и новый объект сразу готов к вычислениям (т.е. происходит практически мгновенное переключение контекста вычислений). При этом освободится один из банков регистров, который соответствовал предыдущему вычислению, и его можно параллельно заполнить данными дескриптора нового объекта, который ещё только стоит в очереди на исполнение. Чтение/запись информации Рис. 4. Схема трансляции адресов Механизм дублирования. Каждый узел (объект) программной сети, поступающий в некоторый аппаратный модуль (процессор), при инициализации создает себе «дублера», т.е. копию узла, который посылается в другой модуль, определяемый операционной системой. Копируются как дескриптор узла, так и все его данные и процедуры (если это необходимо; стандартные типы и процедуры, которые входят в состав стандартных объектов операционной системы и изначально присутствуют во всех ВМ, естественно, не дублируются). В принципе, количество таких дублеров устанавливается при программировании, но по умолчанию всегда создается хотя бы один «дублер». Далее возможны два способа применения этого механизма - «холодное» (наиболее типично) или «горячее» дублирование (что также указывается при программировании). При «холодном» дублировании соответствующий модуль только хранит дескриптор и соответствующую информацию, ничего с ней не делая. Если один из модулей, на котором выполняется один из смежных с данным узлов, спустя заранее оговоренное время (либо по другим признакам) обнаруживает, что этот модуль не выполнил свою функцию (не произвел соответствующие вычисления) либо просто пришел в неисправное состояние (информация об этом распространяется по всей сети), то активизируется «дублер», который и выполняет соответствующие вычисления. Активизированный дублер предварительно создает нового дублера для себя. Если дублеров несколько, то они могут активизироваться по очереди. Таким образом, при любом отказе аппаратуры (модулей, процессоров, коммуникационных сетей) конкретные вычисления все равно будут выполнены на другом модуле (других модулях). Это может несколько снизить общую эффективность системы (т. е. быстродействие) при наличии отказов и сбоев аппаратуры, но в любом случае гарантирует, что задача будет решена и результат будет получен, что особенно важно для систем реального времени, управляющих систем и т.п. При любой генерации новых объектов программной сети и пересылке их для выполнения или хранения (дублирования) в другие модули, всегда в исходном модуле (где был сгенерирован объект и откуда он был послан в другие модули) сохраняется его «представитель», т.е. дескриптор, который позволяет в любой момент вычислений установить, куда был послан соответствующий объект. Таким образом, при любых отказах и сбоях аппаратуры сохраняется возможность восстановить все объекты и продолжить вычисления, пусть даже и на меньшем количестве модулей. Для наиболее критичных к отказам систем может быть применено «горячее» дублирование. В этом случае дублеры основного узла не «простаивают», а так же выполняют нужные вычисления, которые затем могут быть, например, сравнены по мажоритарному принципу, что обеспечит максимальную вычислительную надежность системы. «Горячее» дублирование, а также количество «дублёров» при любом способе дублирования задается при программировании. Рассмотренные здесь два механизма не исчерпывают все возможности МДА по обеспечению надёжности и безопасности вычислений, однако являются наиболее важными. Функции операционной системы Функции операционной системы в МДА [3], обеспечивающие управление процессом решения задачи на мультипроцессорной архитектуре, во-первых, оказываются в этом случае гораздо более простыми, чем в традиционных системах, при этом значительная их часть реализуется аппаратно, а во-вторых, виртуальная структура операционной системы, как и структура прикладной программы, в полной степени соответствует структуре любой решаемой задачи. В основном функции ОС, способствующие автоматическому распараллеливанию программы, организованы как некоторое множество очередей к ресурсам мультипроцессора. Практически основные функции ОС предназначены для поддержки функционирования семи классов объектов в программах, и значительная часть ОС - это набор базовых методов этих классов. Функции операционной системы также поддерживают вышеописанные механизмы адресации и распределения памяти и механизмы дублирования процессов. Таким образом не средства программирования и управления процессами приспосабливаются к архитектуре аппаратной части мультипроцессора, а виртуальная архитектура аппаратной части приспосабливается при помощи средств программирования и операционной системы к структуре каждой решаемой задачи, что и обеспечивает высокую эффективность и надежность вычислений в МДА, защиту программных структур от несанкционированных воздействий и защиту вычислительного процесса от сбоев и отказов аппаратуры. Это обеспечивает полностью децентрализованное и асинхронное управление процессом параллельных вычислений при полностью автоматическом распараллеливании задачи. Заключение Таким образом, распараллеливание программы в МДА и выполнение её компонентов осуществляется автоматически благодаря свойствам и поведению самих объектов, составляющих программу. При этом аппаратно поддерживается абстрактная адресация данных и программ (процедур) этих объектов, а абстрактные адреса автоматически переводятся в физические в процессе выполнения программы. Аналогичным образом автоматически производится и дублирование программных объектов. Программист может либо вообще не заботиться о распараллеливании, адресации объектов, их дублировании и выполнении программ на множестве вычислительных модулей, либо влиять на него, если необходимо, задавая в программе соответствующие сложные ссылки, связи с ресурсами, коэффициенты дублирования объектов и режим «холодного» (по умолчанию) или «горячего» дублирования. Операционная система МДА очень проста, часть ее функций, таких как распределение памяти или запуск объектов на выполнение выполняются на аппаратном или микропрограммном уровне, а интерфейсные функции (взаимодействие с пользователями, утилиты и т. п.) выполняются такими же сетевыми программами, как и прикладные, единственное отличие заключается в том, что программы операционной системы имеют приоритет, позволяющий им работать с защищенными областями памяти, т. е. иметь доступ к объектам с абстрактной адресацией. ]]></text>
</doc>
