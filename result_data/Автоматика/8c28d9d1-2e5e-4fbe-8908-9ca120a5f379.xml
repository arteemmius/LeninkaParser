<doc>
  <source auto="true" type="str" verify="true"><![CDATA[https://cyberleninka.ru/article/n/model-potrebleniya-resursov-vychislitelnoy-sistemoy]]></source>
  <category auto="true" type="str" verify="true"><![CDATA[Автоматика]]></category>
  <author auto="true" type="list" verify="true">
    <item type="str"><![CDATA[Тормасов А. Г.]]></item>
  </author>
  <title auto="true" type="str" verify="true"><![CDATA[Модель потребления ресурсов вычислительной системой]]></title>
  <keywords auto="true" type="list" verify="true"/>
  <annotation auto="true" type="str" verify="true"><![CDATA[]]></annotation>
  <text auto="true" type="str" verify="true"><![CDATA[Существующие в настоящее время модели вычислительных систем в основном предназначены для моделирования «физического» компьютера как совокупности процессора, памяти, шины обмена данными и так далее. Другой класс моделей используется для реализации разнообразных планировщиков ресурсов операционной системы (ОС). Но моделей, описывающих переход ресурсов ОС от одного потребителя к другому практически нет. В работе делается попытка сформулировать и обосновать математическую модель потребления ресурсов операционной системы, используя систему из дифференциальных и алгебраических уравнений. Модель может быть использована для исследования как процесса микропланирования на уровне планировщика ОС, так и на уровне макропланирования общего прохождения потока процессов через компьютерную систему. Вычислительная система в рамках предложенной модели может являться как локальной, так и распределенной разной степени связности. Компьютер и ресурсы операционной системы Операционная система, запущенная на компьютере, обладает определенным набором ресурсов, необходимых для запуска и работы процессов и нитей [Дейтел и др., 2006; Танен-баум, 2002]. К таким ресурсам можно отнести всевозможные экземпляры структур данных ядра ОС, ассоциированные с процессом, например открытые файлы, семафоры и другие объекты синхронизации и т. п. Особенностью таких ресурсов является тот факт, что каждый процесс или нить запрашивает создание такого ресурса путем обращения к ядру ОС (прямому через системный вызов или опосредованному из-за работы других системных вызовов). Таких ресурсов в ОС обычно ограниченное количество, хотя часто бывает, что они выделяются из общей памяти динамически и ограничение на их количество является искусственным. В общем можно считать, что эти ресурсы перераспределяются, так как обычно создается как бы про запас некоторое количество структур, и они при запросах пользовательских процессов просто выделяются из этого запаса. Другим классом ресурсов ОС являются «распределяемые» ресурсы - те, которые «всегда есть». Примерами таких ресурсов являются полосы пропускания сети или дисковой подсистемы или доля CPU. В любой момент времени, когда работает планирование таких ресурсов, их не надо «отбирать» у текущего обладателя, а следует просто перераспределить между потребителями. Если мы находимся в вызове планировщика CPU, то мы знаем, что тот процесс или нить, которую мы снабдим CPU, его и получит, а все, что нам надо решить, - кто из готовых к исполнению потребителей должен попасть на процессор. В дальнейшем мы будем ссылаться на «потоки исполнения» как основных потребителей ресурсов, хотя могут существовать и другие типы потребителей - процессы, легковесные потоки, волокна и так далее - в зависимости от типа операционной системы. Аналогично планированию времени CPU обстоит дело и с сетевой полосой пропускания. Любой «поток исполнения» операционной системы обслуживает какую-либо задачу. Можно сказать, что его «жизненным циклом» является создание «потока исполнения» и выделение необходимых для этого ресурсов, затем выполнение определенного количества команд. Причем «поток исполнения» регулярно прерывает свое исполнение (т. е. не попадает на процес- ISSN 1818-7900. Вестник НГУ. Серия: Информационные технологии. 2006. Том 4, выпуск 1 © А. Г. Тормасов, 2006 сор) из-за того, что система не выделяет ему времени процессора. В процессе жизнедеятельности «поток исполнения» меняет уровень потребления ресурсов (т. е. в разные моменты деятельности он обладает разным количеством ресурсов разного типа, которыми пользуется эксклюзивно или разделяет их с другими «потоками исполнения»). В конце своей деятельности, после исполнения некоторого количества команд, «поток исполнения» умирает, а все отведенные ему ресурсы возвращаются операционной системе. В этом смысле мы не можем говорить, что «поток исполнения» «потребляет» ресурсы, он, скорее, временно захватывает их и потом освобождает. Следует отметить, что «потоки исполнения» могут по собственной инициативе останавливаться на неопределенное время (например, ожидая прямо или опосредованно, через какое-либо другое событие, какого-либо внешнего события, к примеру прихода сетевого пакета или нажатия пользователем клавиши). Для обычных «потоков исполнения» можно выделить два типовых режима работы -исполнение, когда у «потока исполнения» нет оснований для задержки в работе, кроме собственно недостатка ресурсов СРи, и ожидание, когда он «спит». В режиме «исполнения» доля получаемых ресурсов СРи ограничена только тем уровнем, который планировщик может выделить для работы данного «потока исполнения» исходя из заложенных в него параметров планирования. В режиме ожидания «поток исполнения» обычно отпускает все возобновимые ресурсы (так как он их не может использовать эффективно) за исключением таких ресурсов, как «доля физической памяти, занятой виртуальной памятью процесса», хотя их «отпускание» не обязательно, память может быть как вытолкнута на диск в страничный файл, так и оставаться занятой. Но остальные, распределяемые ресурсы, остаются по-прежнему захваченными в режиме ожидания. формализации модели Модельными переменными выбраны время ^ и расстояние х. Переменная времени ^ традиционно описывает переход системы от прошлого к будущему. Переменная х является аналогом «внутреннего времени» процесса или нити исполнения. По сути своей оно течет только тогда, когда процесс получил долю центрального процессора и описывает решение задачи, имея размерность «количества команд». Физический смысл такого параметра представляет собой продвижение решения задачи от начала до конца. Будем считать, что этот процесс описывается как продвижение вдоль некоторой направленной ветви графа, начало которой (первый узел) соответствует началу решения задачи и конец (второй узел) - окончанию решения задачи, причем текущая точка на графе соответствует какому-то состоянию решения задачи в момент (х, 0. Используя аналогию с потоком машин на автостраде, можно сказать, что каждая выполненная «потоком исполнения» команда эквивалентна какому-то расстоянию, которое проезжает машина за один оборот колеса. Колесо может крутиться быстрее или медленнее, тогда машина будет передвигаться быстрее или медленнее. Существует максимальная скорость, с которой может двигаться машина, также существует и максимальная скорость, с которой может выполняться «поток исполнения» (скорость звука), - она ограничена максимальной производительностью процессора, так как решение каждой задачи осуществляет только один процессор. Машина может перевозить грузы разного типа, и иногда она останавливается на некоторое время. Планирование «потоков исполнения» ОС с точки зрения аналогии можно рассматривать как некую «разрешенную на автостраде скорость», которой обычно придерживаются машины, если есть такая возможность. Если они притормаживают из-за занятости автострады, то при первой же возможности машины ускоряются до нужной скорости, а при временном превышении скорости они ее сбрасывают до «крейсерской». В принципе длина пути для конкретной задачи может меняться по ходу расчета, скажем, в результате обратной связи или действий пользователя, но обычно мы рассматриваем как бы «посмертное» состояние процесса, оценивая его после того, как он закончился, и считая, что мы уже знаем его полный «жизненный путь» и соответственно количество выполненных команд. Считаем, что абсолютное значение х соответствует текущей стадии выполненного процесса («пройденному расстоянию») и меняется для каждой задачи от 0 до ХП1ах. Будем считать, что мы рассматриваем единственный «поток исполнения», который в процессе своей жизнедеятельности обладает ресурсами разного типа, и каждый из ресурсов может быть исчислен в каких-либо единицах - штуках, байтах, байтах в секунду и т. д. Хочется подчеркнуть, что эти ресурсы не «перерабатываются» или «потребляются», они просто являются необходимыми для работы «потока исполнения». В зависимости от типа ресурса модель может быть разной. В частности если процесс нуждается в перераспределяемом ресурсе, то этот ресурс (для большинства типа таких ресурсов) обязан быть предоставлен операционной системой, и если его временно нет, то процесс может быть переведен в режим ожидания до момента удовлетворения этого запроса. Другой класс запрашиваемых ресурсов - «распределяемые», которые могут быть получены процессом в любом количестве, большем 0 (не обязательно полностью), и после получения любой ненулевой доли которых процесс может продвигаться вдоль своего «внутреннего времени» X. В этой статье мы не будем рассматривать вопросов, связанных с дискретностью представления ресурсов, считая, что все необходимые нам функции обладают соответствующими необходимыми степенями гладкости. Будем считать, что мы можем определить абсолютное значение ресурсов данного процесса как функцию обеих переменных Res (x, t) в момент абсолютного времени t и внутреннего времени X. Введем величины. р (x, t) - вектор плотности ресурсов, размерностью [ресурс / операции]. По сути своей его компоненты означают удельную плотность какого-либо ресурса в точке (x, t). Подчеркнем, что он не означает количества «потребленных» ресурсов, он означает для большинства ресурсов долю (абсолютную или относительную, или просто количество в каких-либо единицах), которую процесс использует (резервирует исключительно для себя) при своем функционировании. Большинство ресурсов не может быть временно отпущено процессом, например если процесс открыл файл или создал семафор, то он остается в его распоряжении даже если продвижения по оси х нет (т. е. процесс, например, спит). u (x, t) - скорость «потока исполнения», т. е. скорость выполнения команд, или скорость продвижения по внутреннему времени, размерностью [операции / секунды]. Q (x, t) = р (x, t) ) u (x, t) - вектор потока ресурсов [ресурс / секунды]. Рассмотрим в качестве примера ресурса долю CPU. Будем считать, что текущий «поток исполнения» выполняется на одном процессоре, который находится в состоянии «исполнения». Введем «мгновенную» относительную долю CPU, которую должен получить данный «поток исполнения» на данном процессоре в соответствующий момент времени 0 # T(x, t) # 1 (от слова «target»), и реально полученную долю CPU 0 # D (х, t) # 1 (от слова «delivered»). T (x, t) обычно является результатом работы планировщика ресурсов, который определяет, что «поток исполнения» исходя из каких-либо параметров должен бы получить вот такую долю CPU. Плотность ресурса р (x, t) определим опять как долю CPU, которая в момент времени t была получена «потоком исполнения», и долю выполненной работы x (количество выполненных команд от начала работы нити). Пусть Pmx - максимальная производительность CPU в командах в секунду, т. е., условно говоря, «скорость звука», имеющая ту же размерность, что и u. Q (x, t) = р (x, t) ) u (x, t) - поток ресурсов в данном случае будет представлен как поток «использованных возможностей» CPU. Производная потока вдоль X по сути представляет собой изменение полученной доли ресурсов вдоль процесса исполнения. Запишем «закон сохранения массы», или уравнение неразрывности, в форме + SQfeO = (Ц Здесь f(x, t) описывает поведение «источника» массы. Если вспомнить, что р по сути своей есть удельная доля использованного CPU, то фактически f(x, t) представляет собой функцию «желаемого уровня потребления» ресурсов в дифференциальной форме. В формуле (1) также заложены процессы распространения «малых возмущений», которые, с точки зрения предметной области, обусловлены необходимостью «компенсации» изменений плотности полученного ресурса во времени изменением потока ресурса. Иначе говоря, если мы в один момент времени некоторое время долго исполняли команды «потока исполнения» на 100 %, и превысили отведенный лимит T, то это превышение некоторое время будет компенсироваться отсутствием выделения CPU, и, следовательно, во времени возникнут колебания уровня потребления ресурса, которые будут распространяться вдоль оси X. При этом следует отметить, что по своей сути для «чисто расчетных участков» выполнение команд потока происходит только тогда, когда он получил CPU, т. е. D тождественно равно 1. Но если сам процесс должен ждать некоторое время (например, другого процесса, обмена данными или просто ввода пользователя), то продвижение вдоль оси X также будет наблюдаться, т. е. интегрально D будет уже меньше 1. В наших переменных можно считать D (х, t) ) Pmx = u (x, t). Рассмотрим теперь производную скорости выполнения процесса по времени, которая по своей сути управляется внешней по отношению к процессу функцией выделения планировщиком операционной системы ресурса: du (x, t) dt = мx,t). Существует множество планировщиков ресурсов, работающих по своим законам. Их поведение можно измерить на реальной работающей системе или получить его оценки из приближенных математических моделей. Имеет смысл выделить несколько частных случаев, на которых можно рассмотреть поведение «усредненного планировщика», который при прочих равных условиях стремится скомпенсировать разность между желаемой долей ресурсов каждой нити исполнения T(x, t) и полученной долей D (х, t). Это можно считать «давлением», определяющим изменение потока ресурсов. Рассмотрим как пример загруженную однотипными задачами компьютерную систему, в которой есть множество нитей исполнения, получающих при прочих равных условиях примерно одинаковую долю CPU. Будем считать, что компенсация недополученного или перепо-лученного ресурса осуществляется пропорционально разности желаемого и полученного: d^ = f(x, t) = Я ) (Pmax ) T(x, t) - u). В этой ситуации T определяется какой-либо политикой распределения ресурсов и так называемым уровнем обслуживания (SLA - service level agreement), согласно которому процесс или нить должны получить заранее оговоренную долю CPU, т. е. функция T (x, t) задана извне. Здесь Я - коэффициент, играющий роль максимального ускорения, с которым планировщик компенсирует «недостачу» ресурса. Полученное выражение можно считать аналогом «закона сохранения импульса». Перейдя к макроскопическому рассмотрению, можно рассмотреть как другой частный случай уравнение, аналогичное уравнению состояния несжимаемой жидкости с правой частью (а - коэффициент, имеющий размерность х - единицы длины операции), параметры которого опять-таки можно подобрать из экспериментов и измерений: ut + uux = Я (PmaxT (x, t) - u) + mPpfX . Записав аналог «закона сохранения импульса» в другой форме, можно получить 2Q (x, t) + Э (Q (x, t) u (x, t) + p (p (x, t)) = dt dx Jl2 ’ где p (р) есть замыкающее систему уравнение состояния («движущая поток ресурсов сила»), а f2(x, t) является «источником импульса» или, собственно говоря, определяет алгоритм планировщика. Такой подход предоставляет возможность естественным образом ввести две независимые функции f(x, t) и f(x, t), которые по своей физической сути описывают внутреннюю потребность в ресурсе алгоритма работы «потока исполнения» для его функционирования, и его действительное выделение планировщиком ресурсов. Как уже отмечалось, правую часть можно получить из практической оценки поведения планировщика. Простейшее уравнение состояния может быть задано эмпирической формулой в виде Р # К Р (Р (х, 0) = У2 тах (' - Р)' где Ртах - максимальная скорость продвижения по х, или предельная скорость распространения малых возмущений; р* - предельно допустимая плотность потока команд (предельная пропускная способность потока). Оно фактически описывает тот факт, что при приближении к некой максимальной плотности давление начинает быстро расти. а Рис. 1. Пример уравнения состояния Можно обосновать, что данные уравнения являются гиперболическими, описывающими волновые явления. Но в тот момент, когда «поток исполнения» находится в состоянии ожидания, очевидно, что никакие возмущения не могут распространяться, и такие области будут являться негиперболическими. Несколько «потоков исполнения», работающих одновременно, можно описать аналогичными уравнениями, используя для замыкания системы уравнений тот факт, что для каждого процессора системы сумма относительных уровней загрузки каждого «потока исполнения» определяется планировщиком, например при Ж., являющимся весом каждого активного «потока исполнения», относительная доля /-го «потока исполнения» может определяться исходя из формулы 1 для потоков в состоянии исполнения, __ 0 для потоков в состоянии ожидания. j Здесь выполняется естественное условие сохранения для «потоков исполнения» в состоянии исполнения / 1. Для другого класса возобновляемых ресурсов, например для сетевой полосы пропускания, формулировка модели и модельных параметров может выглядеть так же, за исключением того факта, что даже если «поток исполнения» не нуждается в этом ресурсе, то он тем не менее может продвигаться вдоль оси х. Кроме того, должна быть введена кросс-зависимость Ртах от разности между желаемой полосой пропускания и полученной полосой, так как пропорционально недополученной полосе пропускания мы должны увеличить время, за которое достигается какой-то этап в первой группе уравнений для доли СРи: РетахС*, 0 = PmaxXDN/TN, где индекс N относится к сетевой полосе пропускания. Ж где 8j = { Остальные, невозобновляемые ресурсы, можно описать в основном алгебраическими формулами типа Pt = P(x t), причем для большинства ресурсов зависимостью только от х, Pt = P(x), так как в большей степени они являются функцией внутреннего состояния «потока исполнения» и их появление определяется алгоритмом работы конкретного «потока исполнения». Отдельно стоит выделить ситуацию, когда возможность выделения какого-то конкретного ресурса ограничена его количеством (этот факт, как обычно, можно учесть набором алгебраических уравнений, связывающих отдельные «потоки исполнения» в отдельные моменты времени и их последовательность) или тем фактом, что конкретный экземпляр ресурса захвачен другим «потоком исполнения» и надо дожидаться его освобождения. Обычно это означает изменение поведения «потока исполнения», и появление или изменение размера зон во времени, когда «поток исполнения» находится в состоянии ожидания. Таким образом, можно выделить два класса состояния «потока исполнения» - вынужденное ожидание, связанное с обработкой системой запроса на неудовлетворенный ресурс, и «врожденное» ожидание, связанное с его алгоритмом работы. Так же, используя подобный подход, можно смоделировать последовательность работы разных «потоков исполнения», когда результат работы одного «потока исполнения» используется как начальное условие для другого «потока исполнения». Другим вариантом может быть ситуация, когда текущее состояние «потоков исполнения» связывают более сложные алгебраические уравнения, описывающие, например, обмен данными между параллельными нитями, используемыми в одной расчетной программе. Сетевые вычислительные модели для нелинейных систем уравнений гиперболического типа Рассмотрим общий подход к решению гиперболических уравнений, заданных на графе (см., например: [Kholodov, 2004; Холодов и др., 2006]). Пусть на каждом ребре k направленного графа - сети, дерева, других вариантов графа (рис. 2), необходимо найти решение одномерной системы уравнений гиперболического типа v, + AvXk = 0, t > 0, 0 < Xk < Xk, k = 1,...,K. (2) Здесь v = #v1, ., Vj - - вектор искомых параметров; A = #aj-, i, j = 1, ..., I - матрица, которая может быть разной на каждой из ветвей, I - размерность системы уравнений (1); K - число ветвей (ребер) графа. Эта система может быть линейной или нелинейной, дивергентной, иметь ненулевую правую часть и т. д., что не принципиально для последующего изложения. х„ = 0 Х„=Х„ Рис. 2. Пример направленного графа Из предположения о гиперболичности (2) следует, что матрица А имеет только действительные собственные значения (возможно, и кратные) Л = {Л.}(/ = 1,...,I), определяемые как корни уравнения Р(Л) = Det (А - ЛЕ) = 0, (Е - единичная матрица) и базис X = {од}, DetQ ! 0, из левых собственных векторов ~, / = 1,...,I (являющихся строками матрицы X), для каждого Л. с точностью до длины определяемых из однородных линейных систем уравнений ~(А - Л/Е) = 0, / = 1,...,I. (3) Тогда А / X-1 ЛХ, (где X-1 обратная к X матрица) и систему (1) можно привести к эквивалентному (1) виду XV, + XAvXl = XV, + ЛОуч = 0, (4) взяв I соответствующих линейных комбинаций исходных уравнений (2). Каждое из условий совместности (4) ~ ^ = 0, 4 = 2 + Л- #-, - = 1, ■■•, I (5) - 4, ’4, 9, - дхк’ ’ ’ у ' является по сути обыкновенным дифференциальным уравнением вдоль -й характеристики системы (13) (рис. 3): 4х = Л&. (6) Такая характеристическая форма уравнений (2) или ее модификации с использованием инвариантов Римана, если удается найти соответствующее точное решение (5), часто используется для построения эффективных разностных схем для решения (2), а в граничных точках она необходима для замыкания граничных условий. Как известно, корректная постановка краевых условий для (2) заключается в задании начальных условий V (0, хк) = v0(xk), и граничных условий при хк = 0 и хк = Хк в узлах графа I = 1,...,Ь,L + 1,...,L + Г,L + Г + 1,...,L + Г + и. Здесь Ь - число внутренних узлов графа, с которыми связано более одной ветви; Ь° - число узлов - входов графа, из которых исходит только одна ветвь графа; Ь' - число узлов - выходов графа, в которые входит только одна ветвь графа. На рис. 2 приведен пример нумерации ветвей (к = 1,...,К) и узлов I = 1,...,Ь,Ь + 1,...,Ь + Г,Ь + Г + 1, ...Ь + Г + Г направленного графа. Эта нумерация может быть и любой другой. Чтобы подчеркнуть тот факт, что для определения искомых параметров wl во внутренних узлах графа I = 1,...,Ь, могут привлекаться самые разные математические модели (алгебраические или обыкновенные дифференциальные уравнения, уравнения в частных производных и т. д.), часть таких узлов обозначена точками (I = 1,3), а остальные - прямоугольниками (I = 2,Ь - 1,Ь). На свободных концах ветвей (ребер) графа (в узлах I=Ь + 1, ..., Ь+Ь° - входах графа, для которых хк = 0, и в узлах I = Ь + Ь° + 1,...,Ь + Ь° + Г - выходах графа, для которых хк = Хк ) постановка краевых условий ничем не отличается от обычной постановки краевых условий одномерной гиперболической системы, а именно: в каждый момент времени число граничных условий (г°к - для входов, гк - для выходов) должно быть равно числу уходящих за область интегрирования характеристик (6) и вместе с условиями совместности (5) вдоль идущих внутрь области интегрирования характеристик они должны составлять линейно независимую дифференциально-алгебраическую систему. Например, для входов: V ^, 0)) = 0, / = 1,., г;, (7) Рис. 3. Расположение характеристик в граничных и внутренних узлах разностной сетки -і° для выходов: V(ихк)) = о, і = I - г; + 1,...,I - г;. (8) Тогда при расчете таких граничных точек можно использовать гС граничных условий (7) или гк условий (8) вместе с I — г С (для , = Г к + 1,..., I) или I — гк (для , = 1,..., I — гк) условий совместности (5), причем матрицы X 0 = ' а\ ' ~1 0 ~ 0. г к , X- = ~1 — гк ~ ог к + 1 ~ I — гк + 1 , ~1 0 , ~ 0 (9) (соответственно для входов и выходов) должны быть неособенными: DetXо ! о, DetX^ ! 0 (10) Здесь ~ - левые собственные векторы матрицы А из (3), векторы ~получаем, дифференцируя (7) и (8): & 11 д{ д( 1 + ! У = 1 д{0к, дУУ 11 д{0 " дt - & л<р-к1 = & д{, ду + ~ ёу_ & В точках ветвления графа 1 = 1, .,L, обозначая через Мчисло входящих в узел 1 и выходящих из него ветвей, а через т = к, • ••,кМ их номера (см. рис. 2), будем считать искомыми величинами (помимо значений векторов уд,...,у М в окончаниях входящих в узел 1 и выходящих из него ветвей) также вектор м ($) = #мд, ...,м>щ- с размерностью Бр для определения которых пусть имеется некоторое количество дифференциальных или алгебраических уравнений, например: } г(, Ул, ., Ум) = 0, г = 1, ., г. (12) Для расчета таких узлов графа помимо граничных условий (12) необходимо использовать условия совместности (5), выбирая их аналогично (7)-(11). Если в некоторый момент времени t число положительных собственных чисел Л,(1,0) матрицы А в прилегающей к узлу 1 точке выходящей из этого узла ветви т° равно г°1т0, а число отрицательных собственных чисел Л,(^ Хт) матрицы А в прилегающей к узлу 1 точке входящей в этот узел ветви т равно г'1т-, то необходимо выполнение условия: г = 1М + 3 — ! г 0т о — ! гы. (13) т о т Кроме того, для обеспечения линейной независимости используемых уравнений (12), (5) необходимо, чтобы De tX ! 0 Здесь ~а1 0 0 0 0 0 0 0 0 0 0 а>ы 0 0 0 0 0 0 0 0 0 0 0 0 ~~ат 0 0 0 0 0 0 0 0 0 0 ~Ьт 0 0 0 0 0 0 0 0 0 0 0 0 ~аМ 0 0 0 0 0 0 0 0 0 0 ~ЬМ 0 ~ 111 ~ 11т ~11М ~11 ~ ,1,1 ~1г,т ~1у,М ~ 11 ~ -)2} 2}3 ~ -)21±, э}r 1. ~ ) 2wn ’ f ’ 2w Ш11’ ~m 12w lm: f ’ 2wlM3’ ~am, f,®bm - собственные векторы матрицы Л, для каждой из ветвей m — 1,M, соответствующие привлекаемым для расчета узла I условиям совместности (5). Для выходящей из узла ветви с номером m°: a = 1, b = r°lm., для входящей в узел ветви с номером m : a — I — r'lm. + 1, b = I. В соответствии с (13) размерность матрицы X равна Iм + S — r + ! r .m + ! rm. m m Для одновременного расчета нескольких классов ресурсов система (2) должна быть продублирована для каждого класса в зависимости от типовых модельных алгоритмов и замкнута уравнениями взаимозависимостей (пример см. ниже). Особенности топологии графов в моделировании реальной вычислительной системы Для реальной вычислительной системы в предложенной модели каждый «поток исполнения» представляет собой отдельную дугу графа. При этом если использовать модель в общем виде, не вводя отношения предшествования, то полученный граф не будет обладать связностью и соотношениями, описывающими «перенос» ресурсов из одного узла в другой через дуги. Технически полный граф состояния вычислительной системы будет описываться как совокупность отдельных (обычно не связанных друг с другом) подграфов, описывающих отдельные «потоки исполнения». Часть из них может быть связана друг с другом (например, для совокупности «потоков исполнения» одного процесса), но чаще связи не наблюдается, так как операционная система считает все задачи не связанными друг с другом. Каждый подграф представляет собой чередующуюся последовательность дуг, описывающих отрезки исполнения и ожидания для «потока исполнения». Причем в «отрезки ожидания» входят только отрезки «неопределенного» ожидания какого-либо внешнего события. Отрезки исполнения включают в себя естественным образом периоды ожидания выделения (освобождения) каких-либо ресурсов как простое уменьшение во времени темпа передвижения вдоль оси х. Так, например, если на отрезке [х x2] было необходимо провести обмены с сетью объемом N, и темп обмена был K единиц обмена в единицу времени, то время за которое можно перейти из х1 в х будет не менее чем N/K. Если же оценить время перехода исходя из скорости CPU, то оно будет (х2 — x1)/Pmax, т. е. необходимо, чтобы выполнялось соотношение N/K < (Х2 — xD/Pmx, из которого получаем соотношение для «текущей максимальной скорости CPU» Pmax(x) < (Х2 — x)/(N/K), что предлагается смоделировать как локальное уменьшение максимальной мощности CPU Pmax. Взаимозависимости подобного типа между разными ресурсами связывают алгебраические и дифференциальные уравнения, описывающие поведение всей системы. Следует также отметить, что в реальной вычислительной системе процедуры рождения и умирания «потоков исполнения» выполняются очень часто, т. е. наш граф оказывается динамически меняющимся во времени. Одним из интересных подходов, который тем не менее выходит за рамки настоящей статьи, является использование графов для описания предшествования каких-либо операций, одни из которых могут следовать только после выполнения других. При этом можно построить модель передачи не только обычных параметров операционной системы, но и «параметров пользователя». Например, можно описать расчетную задачу, которая работает на кластере компьютеров и передает от одного «потока исполнения» к другому расчетные данные, которые появляются только в определенные моменты работы «потока исполнения». В этом случае пользователь может описать решение своей задачи в терминах «потоков исполнения» и смоделировать ход расчета с точки зрения потребляемых ресурсов. Также возможно описать процесс расчета задач на кластере связанных по сети компьютеров. Для этого необходимо введение параметров связности (скорости передачи информации внутри кластера от узла к узлу) в дополнение к уже упомянутым классам параметров, используемых в моделях одного компьютера. Это можно сделать набором простых алгебраических уравнений. В статье предложен новый подход к моделированию реальных вычислительных систем, который дает возможность описать распределение и использование множества типов ресурсов потребителями при решении задач на компьютере. Подход позволяет построить полную замкнутую модель вычислительной системы, для всех типов и классов ресурсов. Вычислительная система может быть представлена как отдельным компьютером, так и как кластер компьютеров разной степени связности. Предложенный подход использует вычислительные модели на графах для построения описания процесса перехода ресурсов, использующие алгебраические и дифференциальные уравнения. Часть уравнений, описывающих поведение «потоков исполнения», является гиперболическими, и для их решения предложено использовать сеточно-характеристический метод. ]]></text>
</doc>
