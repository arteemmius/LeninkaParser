<doc>
  <source auto="true" type="str" verify="true"><![CDATA[https://cyberleninka.ru/article/n/sravnitelnyy-analiz-metodov-vychisleniya-logicheskih-funktsiy]]></source>
  <category auto="true" type="str" verify="true"><![CDATA[Автоматика]]></category>
  <author auto="true" type="list" verify="true">
    <item type="str"><![CDATA[Плотников Дмитрий Александрович]]></item>
  </author>
  <title auto="true" type="str" verify="true"><![CDATA[Сравнительный анализ методов вычисления логических функций]]></title>
  <keywords auto="true" type="list" verify="true">
    <item type="str"><![CDATA[вычисление логических функций]]></item>
    <item type="str"><![CDATA[программируемые логические контроллеры]]></item>
    <item type="str"><![CDATA[метод масок]]></item>
    <item type="str"><![CDATA[logic functions calculation]]></item>
    <item type="str"><![CDATA[Programmable logic controllers]]></item>
    <item type="str"><![CDATA[masks method]]></item>
  </keywords>
  <annotation auto="true" type="str" verify="true"><![CDATA[Проанализированы существующие методы вычисления логических функций применительно к задаче программной реализации логических блоков с большим числом входных переменных.]]></annotation>
  <text auto="true" type="str" verify="true"><![CDATA[© 2010 г. Д.А. Плотников Южно-Российский государственный South-Russian State технический университет Technical University (Новочеркасский политехнический институт) (Novocherkassk Polytechnic Institute) Проанализированы существующие методы вычисления логических функций применительно к задаче программной реализации логических блоков с большим числом входных переменных. Ключевые слова: вычисление логических функций; программируемые логические контроллеры; метод масок. This article analyzes logic functions calculation methods applied to the software implementation of logic blocks with a great number of input variables. Keywords: logic functions calculation; programmable logic controllers; masks method. При разработке микропроцессорных устройств управления технологическими процессами и диагностики (далее - устройств) нередко возникает необходимость реализации с их помощью вычислений некоторого числа логических функций, имеющих большое (несколько десятков) количество входных переменных. Во многих случаях к устройствам такого рода предъявляются следующие типовые требования. 1. Конфигурируемость в процессе эксплуатации в условиях заказчика. Данное требование обусловлено тем, что в зависимости от типа объекта управления или диагностики и пожеланий заказчика в устройстве может быть реализована различная логика управления выходными сигналами. Таким образом, заказчику должна быть предоставлена возможность оперативного изменения логической функции, реализуемой устройством, с целью расширения области его применения. 2. Компактность программной реализации. Если не требуется очень высокое быстродействие, то вычисление логических функций обычно выполняется программно отдельным функциональным блоком программного обеспечения (ПО) устройства. Чем более компактным будет этот блок, тем меньшие требования будут предъявлены к объёму памяти программ и данных микропроцессорной системы (МПС), что, в свою очередь, позволит снизить себестоимость устройства или реализовать в нём дополнительные функции. 3. Приемлемое быстродействие. Таким образом, возникает задача поиска наиболее эффективного способа представления и вычисления логических функций, соответствующего сформулированным выше требованиям. Широкое распространение получили следующие методы вычисления логических функций [1] непосредственных вычислений, бинарных программ, табличный метод и метод масок. Рассмотрим далее достоинства и недостатки каждого из них применительно к поставленной задаче. Метод непосредственных вычислений, как следует из его названия, осуществляется путём реализации средствами используемого языка программирования логических операций, определяемых формулой функ- ции. Метод является одним из наиболее простых для понимания и программирования. Очевидно, что сложность программы, производящей вычисления, а также её быстродействие, напрямую связаны с количеством логических операций, указанных в формуле. Таким образом, для повышения быстродействия и уменьшения размера программы исходная функция предварительно должна быть минимизирована. Наличие или отсутствие влияния значений входных переменных на время вычисления зависит от реализации алгоритма. При условии обязательного выполнения каждой операции, предусмотренной формулой, время вычисления будет максимальным и практически постоянным. С другой стороны, алгоритм вычислений может быть оптимизирован с целью исключения действий, не влияющих на результат. Например, если при вычислении функции, записанной в дизъюнктивной нормальной форме (ДНФ), одна из конъюнкций примет значение «1», то все дальнейшие вычисления могут не выполняться, так как на результат они не повлияют. В этом случае время вычислений будет зависеть от значений входных переменных. В любом случае максимальное время вычисления результата можно оценить как число логических операций в реализуемой формуле, умноженное на среднее время выполнения одной операции. Существенным недостатком метода является невозможность изменения вычисляемой функции без соответствующего изменения программы вычислений, что делает его непригодным для выполнения поставленной задачи. Метод бинарных программ заключается в последовательном анализе значений всех входных переменных по определённой схеме. Последовательность анализа задают в виде бинарного графа (БГ), позволяющего на основе известного значения очередной переменной определить порядок рассмотрения оставшихся переменных для получения значения функции. Существует несколько способов построения БГ [2], одним из которых является использование разложения функции по Шеннону. Если имеется некая функция п переменных х2, ..., хп), то её можно представить следующим образом: f (Xj, x2,..., x„ )= xJ (1, Каждую из •> Хп ) + Х1/(0 Х2 , • • •, Хп ) .(!) остаточных функций (ОФ) Л (x2,•■■, Хп )= / (!= Хп ) И /2 (x2,•■■, Хп )= -Л0, Х2,-',Хп ) разлагают аналогичным образом по следующей переменной х2: /1 (Х2 , • ", Хп ) = Х2 /3 (Х3 , •'', Хп ) + Х2 /4 (Х3, • ", Хп ) ; /2 ( Х2 , •, Хп ) = Х2 /5 (Х3, •, Хп ) + Х2 /6 (Х3, •, Хп ) . Процесс повторяют до тех пор, пока в качестве всех ОФ не получат константы «0» или «1». Каждому текущему разложению функции по переменной соответствует вершина БГ. В вершинах осуществляется проверка одной логической переменной х. Каждая вершина имеет два выхода, соответствующие значениям «0» и «1» проверяемой переменной, и один или несколько входов. Несколько входов возможны в том случае, если на некоторых этапах разложения будут получены одинаковые ОФ - их реализуют в виде единственной вершины БГ, к которой ведёт несколько путей. На рисунке приведён пример БГ, полученного разложением функции /Х\, х2, ..., хп) по формуле (1). Вершины БГ, не имеющие выходов, соответствуют значениям функции. f1(x2,..., X Пример бинарного графа В соответствии с полученным БГ составляют программу вычислений, состоящую из инструкций типа: «если Х = 1), то перейти к вершине Мк, иначе перейти к вершине Мь». При этом каждый из путей БГ не обязательно включает в себя проверки всех п переменных: в ряде случаев результат получается досрочно. Время вычисления методом бинарных программ не постоянно и зависит от входных данных (точнее, от длины пути от начальной вершины БГ до вершины, соответствующей результату). Поэтому для повышения среднего быстродействия БГ оптимизируют путём выбора порядка проверки переменных с целью минимизации средней длины пути (т.е. с целью как можно более раннего получения результата без проверки всех переменных). Для упрощения программы возможна также минимизация числа вершин. В [1, 2] отмечено, что в настоящее время отсутствуют эффективные универсальные методы такой оптимизации. Тем не менее максимальное время получения результата можно оценить как произведение числа переменных (т.е. максимально возможной длины пути БГ) на время выполнения одной операции сравнения. Как и в предыдущем случае, структура программы вычислений при использовании данного метода существенно зависит от реализуемой функции (точнее, от построенного на её основе БГ). Таким образом, метод бинарных программ не удовлетворяет требованию конфигурируемости. Табличный метод реализуется на основе таблицы истинности (ТИ) вычисляемой функции. При этом вектор входных воздействий Х=(хь х2, ... , хп) рассматривается как двоичное число X. На этапе разработки программы для каждого из возможных значений вектора X вычисляется значение функции, которое записывается в таблицу, размещённую в памяти МПС и упорядоченную по возрастанию двоичного числа, соответствующего вектору X. На этапе вычислений число X, соответствующее текущему вектору входных воздействий, рассматривается как индекс ячейки ТИ, содержащей требуемое значение функции. Из всех рассмотренных методов табличный метод обладает наибольшим быстродействием, причём не зависящим от значений входных переменных. Для получения результата достаточно выполнить лишь два действия: вычисление адреса ячейки, содержащей результат, и извлечение результата из памяти. При этом вычисление выполняется путём простого сложения адреса начала таблицы с числом X, соответствующим вектору X, а извлечение - при помощи операции перемещения данных с использованием косвенной адресации. Ещё одним достоинством метода является независимость его программной реализации от вычисляемой функции. Ограничением является лишь максимальное число входных переменных п, определяющее размер ТИ. Таким образом, путём замены ТИ в памяти МПС можно реализовать любую функцию с числом переменных, не превышающим п. Составление ТИ по имеющейся формуле или словесному описанию функции не представляет сложности и может быть выполнено в условиях заказчика. Возможность оперативной замены ТИ обеспечивается её размещением в отдельной области энергонезависимой памяти, к которой предоставлен доступ обслуживающему персоналу. Основным недостатком табличного метода является значительный размер ТИ при большом числе входных переменных, определяемый формулой К = 2п , где К - число ячеек ТИ; п - число входных переменных. С учётом того, что ячейки памяти МПС имеют несколько двоичных разрядов, каждый из которых может представлять отдельное значение ТИ, число К может быть уменьшено (ценой некоторого снижения быстродействия). С этой целью вектор входных переменных X разбивается на две части: XI, определяющую номер ячейки ТИ, содержащей результат, и X2, определяющую номер двоичного разряда ячейки, содержащего результат. Очевидно, что размерность п2 вектора X2 связана с числом двоичных разрядов ^ ячейки памяти МПС соотношением: п2 < (Nm). При этом с целью экономии памяти число п2 следует выбирать максимально большим. Число ячеек памяти, отведённых под ТИ, определяется как К = 2{"-"2). (2) Получение результата в этом случае выполняется в два этапа: сначала из ТИ извлекается значение ячейки с номером, соответствующим вектору Х1, а затем в качестве результата принимается значение разряда этой ячейки, номер которого соответствует вектору Х2. Ещё один способ экономии памяти - реализация вычислений систем логических функций. В этом случае каждый разряд ячейки ТИ соответствует результату вычисления определённой функции. Нужно отметить, что при этом для любого числа вычисляемых функций в пределах [1, N„,1 время получения результата остаётся неизменным. Проанализируем табличный метод на предмет соответствия сформулированным требованиям. Как показано выше, он полностью удовлетворяет требованию конфигурируемости и является наиболее быстродействующим из рассмотренных методов. Оценим требования, предъявляемые методом к объему используемой памяти. Поскольку запас по быстродействию очень велик, с целью экономии памяти рассмотрим модификацию метода, в которой каждая ячейка содержит несколько значений ТИ, а общее число ячеек определяется формулой (2). Исходя из этой формулы, для реализации функции с числом переменных 19...21 потребуется соответственно 64...256 кбайт памяти. В настоящее время такие объёмы встроенной памяти имеются у сравнительно небольшого числа мощных тридцатидвухразрядных однокристальных микроконтроллеров (ОМК). Более простые контроллеры обычно оснащены памятью объёмом не более 64 кбайт, в которой кроме ТИ необходимо разместить код прикладного ПО. Использование дополнительной внешней памяти, как правило, нежелательно, поскольку оно повышает себестоимость МПС и снижает её надёжность. Таким образом, табличный метод может использоваться для решения поставленной задачи лишь в случае сравнительно небольшого числа переменных (10.20 в зависимости от объёма памяти МПС и размера прикладного ПО). Метод масок основан на использовании таблицы решений (ТР) реализуемой функции. ТР содержит список всех комбинаций входных переменных, при которых функция принимает значение «1». Такую таблицу удобно строить на основе ДНФ функции: при этом каждой конъюнкции ДНФ соответствует отдельная строка ТР. Если некоторая переменная входит в конъюнкцию в прямом виде, то в соответствующую позицию строки ТР пишется единица, если в инверсном виде - то ноль. Если переменная вообще не входит в рассматриваемую конъюнкцию, то в качестве её значения указывается символ «*», обозначающий, что в данном случае (т.е. при указанных значениях остальных переменных) значение функции не зависит от данной переменной. Например, для функции четырёх переменных у = х1 + х1х2 + х1 х3 х4 ТР будет иметь следующий вид, представленный в табл. 1 х1 *2 хз х4 0 * * * 1 1 * * 1 * 1 0 Для получения Таблица 1 значения функции методом масок на этапе разработки программы на основе ТР формируются две матрицы: М и Т, размерность которых совпадает с размерностью ТР. В матрице М все элементы ТР, имеющие значение «*», заменяются нулями, а остальные - единицами. В матрице Т все элементы ТР со значениями «1» и «0» сохраняются, а остальные заменяются нулями. В табл. 2 приведён пример матриц М и Т, сформированных для заданной ранее ТР (табл. 1) Таблица 2 Матрица М х1 х2 хз х4 1 0 0 0 1 1 0 0 1 0 1 1 Матрица Т х1 х2 хз х4 0 0 0 0 1 1 0 0 1 0 1 0 В процессе вычислений вектор входных переменных поразрядно логически умножается на первую строку матрицы М, за счёт чего всем входным переменным, не оказывающим влияния на результат функции в соответствующей строке ТР, присваиваются значения «0». Затем результат умножения сравнивается с соответствующей строкой матрицы Т. При совпадении считается, что вычисления окончены (т. е. текущая комбинация значений входных переменных соответствует одной из строк ТР), а функции присваивается значение «1». При несовпадении рассматривается вторая строка матриц, третья и так далее. Если совпадение не обнаружено ни в одной строке, то функции присваивается значение «0». Как и в случае табличного метода, алгоритм получения результата при использовании метода масок не зависит от вычисляемой функции. Это позволяет оперативно менять функцию путём замены матриц М и Т в памяти МПС, что обеспечивает соответствие требованию конфигурируемости. Время получения результата при использовании метода масок зависит от значений входных переменных. Для примерной оценки быстродействия используем следующую методику. Поразрядное логическое умножение вектора входных воздействий на строку матрицы М потребует пШАЛУ операций логического умножения, где NАЛУ - разрядность арифметико-логического устройства (АЛУ) используемого ОМК, а п - число входных переменных. Столько же операций сравнения потребуется для обработки каждой строки матрицы Т. Для извлечения каждого двоичного слова из матриц М и Т потребуется операция перемещения данных с использованием косвенной адресации, а также операция увеличения адреса. Таким образом, максимальное время получения результата можно оценить по формуле ( „ \ Tmax _ T0 NK \ N АЛУ -6 (3) где Ттах - максимальное время получения результата; Т0 - среднее время выполнения одной операции; NК - число конъюнкций в ДНФ функции (число строк в матрицах М и Т); п - число входных переменных; NAЛУ - разрядность АЛУ. Из формулы (3) следует, что максимальное время получения результата зависит от числа конъюнкций в ДНФ реализуемой функции. Все остальные параметры определяются аппаратными средствами и в процессе работы не изменяются. Считая, например, что Т0 = 1 мкс, NAЛУ = 8, а п = 80, получим, что значение функции восьмидесяти переменных, содержащей 800 конъюнкций в ДНФ, может быть получено за время, не превышающее 48 мс. Таким образом, достаточно сложная функция может быть реализована с приемлемым быстродействием при помощи недорогого восьмиразрядного ОМК. Для каждой конъюнкции в памяти МПС будет отведено п/8 байтов в матрице М и столько же в матрице Т. Таким образом, описание всех 800 конъюнкций займёт 16 000 байтов (около 16 кбайт). Полученное значение объёма памяти является вполне приемлемым с точки зрения сегодняшних возможностей МПС. Обобщая изложенный выше материал, составим сводную табл. 3 соответствия рассмотренных методов сформулированным требованиям. Из таблицы видно, что в наибольшей степени предъявленным требованиям удовлетворяют метод масок и табличный метод. Однако требования табличного метода к объёму памяти МПС в большинстве практических ситуаций существенно превосходят аналогичные требования метода масок. Таким образом, табличный метод целесообразно использовать для достижения максимально возможного быстродействия при сравнительно небольшом числе переменных. Если же число переменных велико (более двадцаци), Поступила в редакцию а требования к быстродействию не слишком жёсткие, более предпочтительным является метод масок. С учётом выводов, сформулированных в данной статье, при участии автора был разработан прибор для проверки блока логики управления защитой турбоагрегата (ППБЛ) [3], предназначенный для обслуживания системы мониторинга вибрационного состояния и защиты турбоагрегатов [4]. С помощью метода масок в ППБЛ была реализована программно-логическая модель проверяемого блока, имеющая 72 входа, 4 выхода и общее количество конъюнкций в ДНФ всех реализованных функций 487. При использовании ОМК семейства MCS51 с тактовой частотой 20 МГц среднее время получения результата составило 11 мс, максимальное - 25 мс. Таблица 3 ]]></text>
</doc>
