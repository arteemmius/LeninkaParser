<doc>
  <source auto="true" type="str" verify="true"><![CDATA[https://cyberleninka.ru/article/n/ispolzovanie-prefiksnogo-dereva-dlya-hraneniya-i-poiska-strok-vo-vneshney-pamyati]]></source>
  <category auto="true" type="str" verify="true"><![CDATA[Автоматика]]></category>
  <author auto="true" type="list" verify="true">
    <item type="str"><![CDATA[Таранов И. С.]]></item>
  </author>
  <title auto="true" type="str" verify="true"><![CDATA[Использование префиксного дерева для хранения и поиска строк во внешней памяти]]></title>
  <keywords auto="true" type="list" verify="true">
    <item type="str"><![CDATA[СЛОВАРНЫЕ СТРУКТУРЫ ДАННЫХ]]></item>
    <item type="str"><![CDATA[ПРЕФИКСНЫЕ ДЕРЕВЬЯ]]></item>
    <item type="str"><![CDATA[B-ДЕРЕВЬЯ]]></item>
    <item type="str"><![CDATA[ИНДЕКСЫ В СУБД]]></item>
  </keywords>
  <annotation auto="true" type="str" verify="true"><![CDATA[Поиск среди больших объёмов текстовых данных, хотя и изучается в computer science давно, не теряет своей актуальности. В работе представлена структура данных для поиска и эффективного хранения во внешней памяти массивов текстовых строк, реализованная для поддержки индексов в XML СУБД Sedna. Описываются алгоритмы для вставки, удаления и поиска строк переменной длинны в префиксных деревьях, хранимых на дисках. Мы также сравниваем нашу реализацию с существующей реализацией B-дерева. В работе показано, что в некоторых случаях предложенная структура данных занимает в несколько раз меньше места во внешней памяти при той же скорости поиска.]]></annotation>
  <text auto="true" type="str" verify="true"><![CDATA[Таранов И. С. epsilon@ispras.ru Аннотация. Поиск среди больших объёмов текстовых данных, хотя и изучается в computer science давно, не теряет своей актуальности. В работе представлена структура данных для поиска и эффективного хранения во внешней памяти массивов текстовых строк, реализованная для поддержки индексов в XML СУБД Sedna. Описываются алгоритмы для вставки, удаления и поиска строк переменной длинны в префиксных деревьях, хранимых на дисках. Мы также сравниваем нашу реализацию с существующей реализацией В-дерева. В работе показано, что в некоторых случаях предложенная структура данных занимает в несколько раз меньше места во внешней памяти при той же скорости поиска. Ключевые слова: словарные структуры данных; префиксные деревья; В-деревья; индексы в СУБД 1. Введение Проблемы реализации структур данных, реализующих основные словарные операции (добавление, удаление и поиск элемента), хотя и изучаются в computer science очень давно, тем не менее, не теряют своей актуальности. В данной работе описана структура данных, предназначенная для хранения множества строковых ключей во внешней памяти, приведено её сравнение с В-деревьями, и описаны основные алгоритмы работы с ней. Предложенная структура данных в некоторых случаях позволяет значительно сократить объём индекса во внешней памяти. Задача разработки специальной структуры данных встала в ходе работы над XML-СУБД Sedna [1, 2]. Данная XML-СУБД поддерживает индексы по значению узлов над XML-документом. В результате к структуре данных, используемой для поддержки индексов, предъявляются следующие требования: 1. Возможность хранить ключи произвольно большой длины. Необходимость этого связана с подходом к хранению XML, где все 283 значения при отсутствии предписывающей схемы являются строками, при таком хранении нельзя заранее ограничить длину строки. Одним из примеров длинных строк являются URI, поиск по которым зачастую необходим, но которые при этом могут быть достаточно длинными. 2. Возможность хранить мультимножество пар "ключ/значение". В произвольном XML-документе при произвольном индексе могут существовать одинаковые ключи с разным значением и одинаковые значения с одинаковыми ключами. Причём при обновлении документа (например, удалении узлов) может быть удалена только одна из одинаковых пар "ключ/значение". 3. Эффективный поиск пары "ключ/значение" необходим для быстрого удаления пары из индекса при обновлении документа. 2. Обзор существующих работ Стандартной структурой данных для создания такого индекса является В-дереео [3] и его варианты [4, 5, 6] 1. В-деревья очень широко применяются в базах данных для задач индексации [8]. Хранение ключей произвольной длины в В-деревьях хотя и возможно, однако представляет ряд проблем. Во-первых, достаточно сложно реализовать эффективное хранение ключей переменной длины. На практике обычно в узле дерева хранят только ограниченную часть ключа, а остаток хранят в отдельных страницах переполнения (overflow pages) [9, 10]. Такой подход достаточно эффективен в тех случаях, когда ключи короткие или различаются в первых символах. Во-вторых, в случаях, когда одному ключу соответствует множество различных значений, сложно реализовать достаточно эффективный поиск по паре "ключ/значение". Часто В-деревья не предусматривают хранения мультимножества ключей. Для поставленной же задачи характерно наличие дубликатов пар "ключ/значение". Для возможности хранения одинаковых логических ключей в качестве физического ключа используется конкатенация пары "ключ/значение" [II]2. В статье предложен подход к организации индексов над строками во внешней памяти, который удовлетворяет всем вышеописанным требованиям. Его 1 Во всей статье под В-деревьями на самом деле подразумеваются В деревья [7]. 2 Здесь мы будем понимаем под физическим ключом тот ключ, который действительно используется при сравнении и поиске в описываемой структуре данных. Под логическим ключом понимается ключ, который передаётся интерфейсу работы с данной структурой данных. 284 можно рассматривать как расширение структуры данных, известной как trie [12], которую в дальнейшем будем называть префиксное дерево3. Идея использования данной структуры для реализации индексов не нова. В работе [14] предложена структура данных S(b)-tree, которая представляет собой разновидность В-дерева, в узлах которого находится бинарная “Патриция” (patricia tree) [15]. Особенностью S(b)-tree является то, что в узлах хранятся не ключи как таковые, а количество пропускаемых при сравнении бит. В процессе поиска искомую строку, возможно, придётся сравнивать со строкой, хранящейся во внешней памяти. Однако само по себе такое сравнение не представляет больших проблем. Для поставленной задачи проблемой было бы хранить все строки-ключи в отдельном месте. S(b)-tree позиционируется как структура данных для поддержки полнотекстового индекса и достаточно хорошо справляется с этой задачей [16]. Наиболее похожей на описанную в работе структуру данных является предложенная в работе В-trie [17]. За основу в этой работе была взята реализация префиксного дерева от тех же разработчиков, которая предусматривает эффективное использование процессорного кеша [18]. В обеих структурах предложено эффективное для этого разбиение префиксного дерева на блоки (buckets). Кроме того, существуют совсем простые реализации подобного подхода, такие как Index Fabric [19], который является тем же В-деревом, в узлах которого хранение и поиск ключей осуществляется с помощью префиксного дерева. 3. Описание предложенной структуры В статье предложена структура данных для хранения множества строк К, которую в дальнейшем мы будем называть BST (Block String Trie), и над которой определены следующие (словарные) операции: • insert(s) - добавить строку s в множество К; • deleters) - удалить строку s из множества К\ • find(s) - найти все строки в К с префиксом s, включая саму строку s. Данная структура данных, как видно, сама по себе не предусматривает хранения пар "ключ/значение". Учитывая наши требования, мы будем хранить значения, как части физически сохраняемого ключа. Рассмотрим пример. Пусть надо сохранить пару (k, v). Для этого мы строим строковый ключ к' = к+ С + stringiy), где под с понимается символ, которого нет в алфавите символов логических ключей (так, для текстовых строк можно 3 В русском переводе [13] для перевода термина trie используется слово “луч”. Также в литературе встречается слово “бор”. использовать нулевой символ), a slritlg(v) — любое строковое представление значения. Если надо найти все значения, соответствующие некоторому ключу к , необходимо вызвать find (к + с) . В нашей структуре данных мы разделяем несколько уровней объединения вершин дерева. Внутренние вершины дерева объединяются в ветки, а ветки целиком хранятся в страницах внешней памяти. Ниже мы опишем последовательно эти уровни. 3.1. Префиксное дерево Описываемая структура данных представляет собой корневое дерево Т, хранящее множество ключей К и устроенное следующим образом: 1. Каждая вершина X содержит следующие поля: префикс prefix(x) (возможно, пустой), массив Е(х) из п(х) исходящих из неё рёбер, помеченных различными символами (упорядоченный в лексикографическом порядке), а также некоторые флаги (булевские переменные), например final(x), который определяет, соответствует ли этой вершине какой-либо ключ. Флаги вершины будут описываться по мере их введения. 2. Ребра е = (х,Ц(х)) (будем обозначать Ц(х) вершину, в которую ведёт i -е ребро из массива Е(х)) помечены символами с(е). В данном случае мы не отличаем отдельные символы от строк и будем считать их строками единичной длины. 3. Любой путь S(x1,xn) = х1е1х2е2К еп_ххп в дереве задаёт строку S , которая получается из этого пути S конкатенацией строк 5 = prefix(xj) + с(е j) + prefix{x2) + с(е2) +К + c(enl) + prefix{xn) Строка S, заданная путём S, принадлежит хранимому в дереве множеству ключей К в том и только в том случае, если конечная вершина Хп пути S помечена флагом final(хп). Отметим, что в общем случае некоторому множеству ключей К может соответствовать более одного дерева Т. Это объясняется тем, что в дереве, в котором есть хотя бы одна вершина, из которой исходят не все возможные рёбра, можно добавить вершину х' с произвольным префиксом, не помеченную final(х'). Полученное дерево будет задавать то же самое множество ключей К. Поэтому введём дополнительное свойство, выполнения которого требовать мы не будем, позволяя реализовать тем самым отложенное удаление (которое будет обсуждаться ниже): 1. Любая вершина хеГ, для которой п(х) < 1, помечена как final(х). Т.е. (единственному) пути, ведущему от корня к такой вершине, соответствует ключ множества К. 2. Заметим, что при выполнении последнего свойства множество К однозначно задаёт дерево Т. Доказательство этого факта не представляет сложности, однако выходит за рамки данной статьи. Дерево Г, для которого выполняется последнее свойство, будем называть минимальным. Кроме того, вершину X, для которой выполняется (не выполняется) условие п(х) < 1 => final{x) , будем называть неизбыточной (избыточной). В дальнейшем (если не оговорено обратного) будем рассматривать только минимальные деревья. Заметим также, что для хранения мультимножества достаточно ввести дополнительный параметр вершины count(x) > 1, определённый только для вершин, для которых установлен флаг final(x). 3.2. Разделение на страницы Описанная в предыдущем разделе структура удобна для хранения и поиска строковых ключей в оперативной памяти. Но для использования её с большими объёмами данных во внешней памяти необходимо эффективно распределять её на страницы фиксированной длины. Заметим, что это важно не только для структур данных, предназначенных непосредственно для хранения во внешней памяти (например для поддержания индексов баз данных), но также для структур данных в оперативной памяти [13]. Для такого разделения выделим особый тип ссылочных вершин, которые не хранят префиксов и ссылок на другие вершины, а хранят лишь ссылку на другой узел, находящийся в другой странице. Такие вершины пометим флагом external(x), каждая из которых ссылается на некоторую вершину у = .1 (х) такую, что external(x) => not external(.j(х)). Введём также понятие ветки. Назовём веткой корневое дерево В такое, что конечные вершины всех путей от корня к листовым вершинам в нём помечены либо final(x), либо external(x) . Если в дереве Т нет ссылочных вершин, то оно состоит из одной ветки. Заметим, что любое дерево Т может произвольным образом быть разбито на ветки путём вставки перед любой вершиной новой ссылочной вершины. Ссылочная вершина разбивает ветку на две. Если ветки считать узлами, то они также образуют дерево Тъ . Отметим также, что ссылочные вершины никак не влияют на минимальность дерева по определению и не являются избыточными. Страницы могут хранить одинаковый объём данных W байт4. В странице могут храниться одна или несколько веток исходного дерева, причём в одной странице могут храниться только ветки с общим прямым предком Р(В). Последнее условие необходимо, во-первых, для обеспечения локальности изменений в дереве [20], а, во-вторых, для обеспечения эффективных блокировок на уровне страниц. Из этого также следует, что на странице, в которой хранится корневая ветка, других веток быть не может. 4. Алгоритмы Алгоритмы изменения дерева должны обеспечивать, во-первых, локальность изменений (ограниченное число изменяемых страниц), во-вторых, компромисс между оптимальным заполнением страниц и высотой дерева. 4.1. Поиск пути Алгоритм BST-Search(r, к) возвращает вершину х ^ такУю- что: • строка s(xn ), задаваемая путём S(l\ Хп). если такая существует, является префиксом искомой либо совпадает с ней, • искомая строка к является префиксом строки s(xn+1) либо совпадает с ней. Т.е. выполняется неравенство: s(xn) < к < s(xn+l), где под операцией А < В понимается то, что А является префиксом В или совпадает с ней. Процедура получает на вход указатель X на корневой узел поддерева, а также строку к . Промежу точные результаты поиска сохраняются в стек S . В процедуре также используется функция у = Z(x, с) , которая находит среди исходящих рёбер вершины X ребро, помеченное символом с, и возвращает узел у , в который оно ведёт, либо NIL, если такого ребра нет. Такую функцию можно реализовать, например, бинарным поиском, т.к. массив рёбер упорядочен. Также используется функция Cut(p, s), которая возвращает строку, получающуюся из S удалением префикса р . Алгоритм достаточно компактен, поэтому приведём его здесь: 4 В СУБД §ес1па, для которой реализована описываемая структура, размер страницы по умолчанию равен 64К. 288 1. BST-Search(x, к, S) 2. Push(,S\ x) 3. if external{x) then 4. Disk-Read(./(x)) 5. return BST-Search(./(x) , к , S) 6. endif 7. if not ls-Prefix(/>re/bc(x), k)) then 8. if ls-Prefix(A:, prefix{x)) then 9. return x 10. else 11. return NIL 12. endif 13. else 14. 5 <— Q,u\.(prefix(x), k) 15. if Empty(s) then 16. return X 17. elseif Z(x,s[l]) = NIL 18. return NIL 19. else 20. return BST-Search(Z(x,s[l]), Cut(s[l], s), S) 21. endif 22. endif Процедура возвращает такой узел X, что все пути, ведущие из корня в final -вершины и содержащие X, задают строки, для которых искомая строка является префиксом, либо NIL, если такого узла нет. Таким образом, нам остаётся найти все эти пути (обходом поддерева от возвращённой вершины). 4.2. Вставка Процедура добавления строки устроена таким образом, что она сначала строит структуру, описывающую изменение страницы, в которую надо вставить новые вершины. Может случиться, что для вставки нет места в странице. В этом случае процедура вызывает расширение дерева на необходимую величину, и вставка не происходит. Она должна быть вызвана ещё раз. Заметим также, что корень дерева может измениться в процессе работы процедуры. Сама процедура добавления достаточно проста, однако она слишком велика, чтобы приводить её здесь. Опишем только основной подход. Начинается вставка с поиска пути по дереву к ключу к, который надо вставить. Алгоритм практически идентичен алгоритму поиска пути, только нас интересует лишь путь S, получающийся в результате. Кроме того, нам понадобятся три дополнительные строки, получаемые из найденного пути и строки к: common, rest и key. Строятся они следующим образом. Возьмём строку S , которая получилась из строки, соответствующей найденному пути S удалением последнего префикса. Она, очевидно, является префиксом добавляемой строки к (либо совпадает с ней). Будем рассматривать строку к , которая получилась из к удалением этого префикса S . Тогда common — это наибольший общий префикс строк к и р = prefix{S\n]) (где Л'[//] — последняя вершина пути S). rest — это остаток от строки р , полученный удалением префикса common, и key — остаток от к , полученный удалением префикса common. Все три строки удобно считать одновременно, и их значение иллюстрирует следующая схема: + <4 + • • • + pref(x„_i) n„_! prefix(x„) s brownfoxjumpsoverala z у dog common к brownfoxjumpsoverala z у gopher hey Алгоритм вставки рассматривает пять случаев: 1. В дереве нет узлов. В этом случае нам надо выделить страницу, на которой расположить единственный новый узел дерева. 2. rest и key — пустые строки. В этом случае нам достаточно пометить последнюю вершину пути как final (в случае минимального дерева она уже будет помечена как final). 3. key — пустая строка, rest — непустая. В этом случае нам достаточно разбить последнюю вершину пути на две, одна их которых будет содержать префикс common и будет помечена как final. 4. key — непустая строка, rest — пустая. В этом случае нам надо добавить дополнительную вершину с префиксом key, дочернюю по отношению к последней вершине пути. 5. key и rest — суть непустые строки. В этом случае последняя вершина х разбивается на три: одну с префиксом common, с двумя исходящими из неё — х , префиксом которой становится rest, и final- вершину с префиксом key. Основной момент, который связан с разделением на блоки, заключается в том, что в случае 4 и 5, если ветка, в которую мы производим добавление, имеет дочерние ветки, мы создаём новую вершину с key в новой ветке. Для этого мы находим среди дочерних веток ту, на странице которой осталось больше всего места. Эго самая дорогая из всех приведённых операций, т.к. требует в худшем случае чтение такого количества страниц, которое равно количеству различных возможных дочерних веток. На практике это неприемлемо. Поэтому в нашей реализации мы ограничиваем количество просматриваемых страниц некоторой константой D (в реализации равна 2). В случае, если среди первых просмотренных D страниц не нашлось той, в которую помещается добавляемая вершина, пытаемся расширить самую занятую из просмотренных. При таком подходе затрагивается не более D+2 страниц. 4.3. Разделение страниц В отличие от В-деревьев, предложенные нами BST-деревья не сбалансированы. Заметим, что так как минимальное дерево Т полностью определяется множеством ключей К, которые оно хранит, мы не можем никак повлиять на его высоту. Под высотой BST-дерева подразумевается высота дерева его веток, т.к. именно этим определяется количество блоков, которые необходимо прочитать, чтобы найти вершину в худшем случае. Кроме того, нашей задачей является избежать большого числа “полупустых” блоков. Процедура выделения места в странице подразумевает разделение страницы и вызывается только в том случае, если на странице не хватает места для вставки нового узла. Мы используем два очень простых алгоритма разделения страниц. Первый из них вызывается в случае, если на странице расположено несколько веток. В этом случае мы разделяем ветки страницы на два непересекающихся набора Рх и Р2, такие, что | ^ _t И’(В) — ^ р w(B) | минимальна по всем возможным разделениям Рг и Р2. Т.е. эти наборы должны разделять ветки примерно пополам по их общему размеру. Это можно сделать, например, с помощью жадного алгоритма. Каждый из этих наборов записывается в отдельную страницу, а ссылки обновляются. Данная операция затрагивает ровно три блока. Второй алгоритм вызывается в случае, если на странице, в которую происходит добавление, осталась только одна ветка. В этом случае мы 291 выделяем корень Рр этой ветки следующим образом. Находим первую вершину от корня, которая содержит N > 1 ссылок. У этой вершины есть N дочерних вершин, которые будут корнями N новых веток, оставшихся на данной странице. Корневое множество вершин Рр мы удаляем из данной страницы и целиком переносим в ветку-предок. Чтобы гарантировать возможную вставку в исходную страницу, применяем к ней первый алгоритм разделения. Если исходная ветка являлась корневой, то множество вершин Рр помещается в новую страницу. Может оказаться, что в странице, хранящей ветку-предок, не хватит места для вставки Рр . В этом случае вызывается процедура выделения свободного места для страницы предка. Данная процедура затрагивает ровно три страницы без учёта возможного рекурсивного вызова. Проблемой могут оказаться строки, по размеру превышающие h страниц, где h — высота дерева в страницах. В этом случае мы можем не найти в ветке вершину, которую можно “перенести” в верхнюю ветку. Тогда, в нашей реализации, строка разбивается на две (возможно нарушая минимальность дерева), и листовую часть строки представляется правильным вынести в отдельную страницу. Эго практически является аналогом страниц переполнения для В-деревьев, но не будет приводить к постоянному чтению этой страницы, т.к. любая исходная строка сравнивается в нашем дереве не более одного раза. 4.4. Удаление Следуя примеру большинства работ по В-деревьям, мы вводим процедуру отложенного удаления [20, 21, 22]. Данный подход широко используется в базах данных, т.к. процедура удаления для В-деревьев может быть сложнее процедуры вставки. Отложенное (lazy) удаление позволяет, во-первых, значительно упростить само удаление; во-вторых, ускорить обновления базы данных. Удаление заключается в простом снятии флага final с найденного узла. После удаления узла таким образом мы получаем избыточный узел, и, следовательно, неминимальное дерево. При таком подходе необходима процедура минимизации дерева (или, возможно, отдельной ветки). Она заключается в удалении всех избыточных вершин. Избыточные вершины бывают двух типов: 1. Вершины, которые не помечены как final, и у которых нет исходящих рёбер. Такие вершины можно просто удалить. 2. Вершины, которые не помечены как final из которых есть ровно одно исходящее ребро. В этом случае вершины достаточно объединить конкатенацией префиксов через символ ребра. В результате применения этой операции не остаётся избыточных вершин. В результате такой операции может получится так, что в некоторой ветке не останется вершин, либо останется единственная ех/еим/-вершина. Такую ветку необходимо удалить, а (единственную) дочернюю ветку перенести вверх на данную страницу. Может оказаться так, что страницу необходимо будет для этого разделить. Таким образом минимизация одной ветки затрагивает не более четырёх страниц (три страницы может затронуть разделение, и с одной страницы мы переносим ветку) 5. Эксперименты В качестве набора данных для тестирования мы использовали базу данных БВЬР [23]. Тестирование производилось с использованием СУБД §ес1па. При тестировании индексировались публикации по идентификатору (ГО) и по двум типам и Я 1-ссылок (ЕЕ и 1ШЬ), которые есть в базе ЭВЬР. Всего индексировалось 861473 публикации. Результаты тестирования показаны в следующей таблице: Набор данных Объем данных Время поиска (сек.) Большой Маленький буфер буфер BST DBLP ID 27МЬ 6.0 6.2 DBLP ЕЕ 17МЬ 15.9 16.0 DBLP URL 31МЬ 15.7 17.0 В-дерево DBLP ID 31МЬ 6.0 6.0 DBLP ЕЕ 44МЬ 16.0 16.0 DBLP URL 46МЬ 16.0 17.0 Каяедая серия поисковых запросов выполнялась в двух условиях: при большом буфере оперативной памяти (большая часть дерева помещалась в памяти) и при маленьком буфере (в памяти помещались всего 32 страницы). В тестах производился поиск 10% всех возможных значений каждого набора в случайном порядке. Как видно, предложенные деревья BST показывают практически одинаковую производительность по сравнению с В-деревьями, однако занимают в некоторых случаях гораздо меньше места за счёт сжатия ссылок. Кроме того, из результатов можно сделать вывод о том, что количество сравнений строк не оказывает существенного влияния на производительность. За счёт того, что они занимают меньше места, BST-деревья медленнее растут в глубину, что может в некоторых случаях серьёзно повлиять на производительность. Однако для того, чтобы это продемонстрировать, нужно генерировать большие искусственные наборы данных. Кроме того, было произведено сравнение скорости вставки в В-деревья и BST-деревья. Различие скорости вставки было также практически неразличимо для двух типов деревьев, поэтому мы не приводим здесь его результатов. В работе [17] очень похожая структура данных сравнивается с различными реализациями В-деревьев (их префиксным вариантом и Berkeley В-Tree). Описанное в работе В-дерево принципиально не отличается от В-деревьев, используемых в СУБД Sedna (со всеми его особенностями). Результаты этой работы также показывают, что префиксные деревья во внешней памяти и В-деревьях отличаются по скорости поиска незначительно. Кроме того, как и отмечалось в данной работе, видно, что скорость поиска в хранимых вариантах префиксных деревьев в большей степени зависит от размера буфера оперативной памяти. Основным преимуществом нашей структуры данных по сравнению с предложенной в работе [17] является то, что нам удалось достичь гораздо более значительного сжатия похожих ключей за счёт хранения общих префиксов. В итоге это может означать более медленный рост дерева в высоту. 6. Заключение Структура данных BST была реализована в качестве возможной структуры данных для индексов в СУБД Sedna. Существует ещё много возможностей её оптимизации (в основном, алгоритмов разделения), которые необходимо дополнительно рассмотреть в будущем. В настоящее время проводится достаточно много работ, связанных с использованием префиксных деревьев. Различные эксперименты с разными наборами данных подтверждают, что структура данных BST показывает производительность не хуже, чем у В-деревьев. Поэтому она может использоваться как полная их замена для строковых ключей. При этом, в случае, если строки достаточно длинные и по своей природе могут иметь длинные общие префиксы, можно достичь значительного сжатия индекса. Например, значительного выигрыша можно достичь при хранении индекса по нумерующим числам в XML-документах [24] и быстрого поиска по ним, например для поддержки блокировок [25]. Однако стоит отметить, что реализация BST достаточно сложна, и при выборе структуры данных для каких-то задач в общем случае есть смысл использовать хорошо проверенные и более надёжные реализации В-деревьев. ]]></text>
</doc>
