<doc>
  <source auto="true" type="str" verify="true"><![CDATA[https://cyberleninka.ru/article/n/prilozhenie-algoritma-prefiksnogo-kodirovaniya-massiva-dannyh-v-sheme-razdeleniya-sekreta-potoka-videodannyh]]></source>
  <category auto="true" type="str" verify="true"><![CDATA[Автоматика]]></category>
  <author auto="true" type="list" verify="true">
    <item type="str"><![CDATA[Файзуллин Рашит Тагирович]]></item>
    <item type="str"><![CDATA[Сагайдак Дмитрий Анатольевич]]></item>
  </author>
  <title auto="true" type="str" verify="true"><![CDATA[Приложение алгоритма префиксного кодирования массива данных в схеме разделения секрета потока видеоданных]]></title>
  <keywords auto="true" type="list" verify="true">
    <item type="str"><![CDATA[РАЗДЕЛЕНИЕ СЕКРЕТА]]></item>
    <item type="str"><![CDATA[ШАРДИНГ]]></item>
    <item type="str"><![CDATA[ДЕЛЬТА-КОД ЭЛИАСА]]></item>
    <item type="str"><![CDATA[РАЗДЕЛЕНИЕ ВИДЕОПОТОКА]]></item>
    <item type="str"><![CDATA[ПРЕДСТАВЛЕНИЕ В ФОРМАТЕ RGB]]></item>
  </keywords>
  <annotation auto="true" type="str" verify="true"><![CDATA[Предложен вариант алгоритма, использующего префиксное кодирование массива данных и основанного на примитивизации дельта-кода Элиаса, в схеме разделения секрета. Описана возможность использования предложенного алгоритма в схеме разделения видеопотока данных. Выполнена программная реализация предложенного метода в среде программирования Borland C++.]]></annotation>
  <text auto="true" type="str" verify="true"><![CDATA[Предложен вариант алгоритма, использующего префиксное кодирование массива данных и основанного на примитивизации дельта-кода Элиаса, в схеме разделения секрета. Описана возможность использования предложенного алгоритма в схеме разделения видеопотока данных. Выполнена программная реализация предложенного метода в среде программирования Borland C++. Ключевые слова: разделение секрета, шардинг, дельта-код Элиаса, разделение видеопотока, представление в формате RGB. На современном этапе развития информационных технологий одними из самых актуальных задач являются задачи безопасного хранения и передачи информации. Раскрытие конфиденциальных данных или их безвозвратная потеря могут привести к фатальным последствиям. Поэтому большинство организаций (пользователей) стремятся защитить свою конфиденциальную информацию, зачастую используя криптографические алгоритмы, которые порой могут оказаться недостаточно стойкими или недостаточно быстрыми для реализации поставленной задачи. Так же использование криптографических алгоритмов может требовать специальных навыков пользователей и наличия вычислительных ресурсов. Тем самым встает вопрос о необходимости использования алгоритмов, обеспечивающих защиту конфиденциальной информации, которые способны осуществлять быстрое и стойкое преобразование и не требовать от пользователя какой-либо специальной подготовки. Зачастую для реализации поставленных целей прибегают к использованию оконечных аппаратных комплексов, которые осуществляют криптографическое преобразование проходящего через них потока, типичными примерами таких устройств могут являться устройства, осуществляющие преобразование видеосигнала, где без знания специального ключа нельзя дешифровать преобразуемый ими видеосигнал. Но при использовании таких устройств пользователи могут столкнуться с рядом проблем, таких как маленькая длина ключа или его слабая стойкость, шифрование всего видеопотока одним ключом, проблемы синхронизации при использовании медленных алгоритмов шифрования и т.п. Кроме того, высокая коррелированность видеоданных и способность человека к распознаванию зашумленных изображений позволяют легко, «на лету», восстанавливать данные. Таким образом, все так же является актуальным использование алгоритмов, не требующих значительных вычислительных ресурсов и осуществляющих преобразование с использованием периодически меняющегося ключа, в таких случаях можно прибегнуть к схеме разделения секрета. Принципиальным решением проблемы может быть применение доказуемо стойких схем с разделением секрета, где существенно большая часть секрета передается по открытому каналу, а меньшая или шифруется, или иначе, передается по защищенному каналу передачи данных. Под меньшей следует понимать ту часть секрета, длина битовой записи которой оценивается логарифмом от длины записи большей части. В настоящей работе предлагаются схема кодирования и эффективное преобразование данных, которое можно рассматривать как доказуемо стойкую схему разделения секрета на существенно неравные части. Постановка задачи Рассмотрим задачу хранения большого числа массивов данных, длины записи которых существенно различаются. Пусть даны n битовых векторов A\,...,An, размерности которых равны M\,...,Mn и дисперсии Mi распределены равномерно в достаточно большом интервале. В этом случае возникает проблема экономичной записи данных, которая в настоящее время решается различными способами: шардингом [1], т.е. грубым физическим разделением данных по различным носителям данных, введением различных типов данных, наподобие CHAR и VARCHAR, 3 10 разделением данных маркерами. Но если Mi варьируются от 10 до 10 , а n изменяется, то отве- дение равных областей памяти для каждого Аi исключительно неэффективно, а разделение данных специальной строкой бит (маркером) неэффективно по времени поиска этого маркера, и нет никакой гарантии, что выбранная в качестве маркера строка не встречается ни в одном из Аг-. Использование алгоритма, представляющего собой примитивизацию дельта-кода Элиаса Рассмотри алгоритм, представляющий собой примитивизацию дельта-кода Элиаса (универсальный код для кодирования целых чисел, разработанный П. Элиасом) [2], который позволяет избежать указанных трудностей. Первые l бит заполним нулями, где l - это длина записи числа п, далее идёт сама запись числа п, например, пусть даны п = 3 битовых векторов, тогда запись числа п в двоичной системе счисления равна 11 и l = 00 . И на первом этапе получается следующая числовая последовательность: 0011. Далее, бит заполняются нулями, где mi - число бит, необходимых для записи длины вектора Аi в двоичной системе счисления. Например, в предыдущем примере п = 3 , следовательно, имеется три битовых вектора A1, A2, A3. Пусть A =111011, A2 =10111, A3 = 101, тогда размерности этих битовых последовательностей равны M1 = 6 , M2 = 5, M3 = 3 соответственно, а т1 = 000, m2 = 000 , m3 = 00 . Тем самым на втором этапе получится следующая последовательность: 0001100001010011. Третьим этапом формирования последовательности является последовательная запись самих векторов A1, A2 , A3. Например, для приведённых выше примеров получится следующая исходная последовательность: 0011000110000101001111101110111101. Обратим внимание на то, что, зная диапазон возможных изменений Аг-, можно записывать Ai в mi + di позициях, предваряя или дополняя нулями значащие цифры Аг-. Это позволяет легко перезаписывать и дописывать массивы и их новые значения, не усложняя структуру данных. Предполагается возможным использование предложенного выше метода как основы схемы разделения секрета для видеопотока данных, и мы попытаемся построить алгоритм, не требующий значительных вычислительных ресурсов. Пусть имеется поток видеоинформации, передаваемый по каналам связи, осуществляется разбиение данного видеопотока на фреймы. Производится построчное чтение пикселей фрейма, затем для каждого пикселя строки находятся его значения в формате RGB (red, green, blue) в двоичной системе счисления (размерностью 24 бита, т.е. по 8 бит для каждого цвета) и записываются последовательно друг за другом в одну строку, создавая последовательность, состоящую из нулей и единиц. Каждая такая достаточно длинная последовательность строки прочитанных пикселей разбивается на п битовых векторов A1,A2,...,An, разных размерностей М1,...Мп . Затем все полученные строки, состоящие из префикса и зашифрованных или преобразованных A1,A2,...,An ^Q,..,Cn (без изменения длин записи), объединяются в одну битовую строку. Очевидно, что, не зная префиксов, определение границ разделения сводится к переборной задаче. Простое шифрование является затратной по времени операцией, и поэтому предлагается модификация с наиболее эффективным по времени преобразованием. Пусть имеется поток определенного («телевизионного») формата 720x576 пикселей 25 кадров в секунду в формате RGB (в дальнейшем будет осуществляться преобразование видеопотоков стандартных форматов: 720x576, 640x480, 352x288 (CIF - Common Interchenge Format), 176x144 (QCIF -Quartered Common Interchenge Format)), т.е. размерность изображения является известной и выбирается из одного из стандартов. Здесь осуществляются аналогичные действия: осуществляется разбиение видеопотока на фреймы, для каждого пикселя фрейма находятся его значения в формате RGB (red, green, blue) в двоичной системе счисления и записываются последовательно друг за другом (изображение считывается построчно слева направо), затем полученная битовая последовательность (битовая последовательность состоит из последовательно записанных друг за другом значения пикселей строк в двоичной системе счисления) разбивается на п случайных битовых векторов разной размерности. Формируется префикс с указанием, на сколько п частей разбита последовательность, и с указанием длин каждых полученных векторов A1,A2,...,An . В качестве генератора случайных чисел в программе, реализующей описываемый метод (произвольно генерируются размерности векторов A1,A2,...,An размером от 500 до 1000 бит), используется генератор псевдослучайных чисел RandomRange(), встроенный в среду программирования Borland (C++, Delphi) и удовлетворяющий набору тестов, определённому стандартом FIPS 140-1 (Federal Information Processing Standards) [3]. Над полученными битовыми векторами A1,A2,...,An осуществляются следующие операции: X1 = A[, X2 = A1 + A2 ,..., Xn = An-1 + An (где «+» - побитовое сложение по модулю 2), полученные битовые векторы X1,X2,...,Хп записываются последовательно друг за другом и дописываются к сформированному выше префиксу. Также возможно, что для получения битовых векторов X1X2,...,Xn вместо операции «+» - побитовое сложение по модулю 2, описанной выше, можно воспользоваться одним из режимов шифрования (метод применения блочного шифра, позволяющий преобразовать последовательность блоков открытых данных в последовательность блоков зашифрованных данных), таких как CBC (Cipher Block Chaining), CFB (режим гаммирования с обратной связью, Cipher Feedback). Тем самым, если атакующему станет известна последовательность, состоящая из последовательно записанных векторов, он не сможет восстановить исходную последовательность без знания сформированного префикса. Если осуществлять посылку основной битовой последовательности и префикса по различным каналам связи, то будет обеспечиваться должный уровень конфиденциальности передаваемой информации. В случае если атакующий попытается восстановить исходное изображение фрейма, зная исходные размеры изображения и только битовую последовательность, без полученного префикса, в результате получим, например, следующие изображения (рис. 1-3). а б Рис. 1. Исходное изображение - а; изображение, полученное атакующим при попытке восстановить изображение из имеющейся у него последовательности бит, - б щвшщжщтши. ЯВШШ . 'Шщ - V. «■- « '■. : .. а б Рис. 2. Исходное изображение - а; изображение, полученное атакующим при попытке восстановить изображение из имеющейся у него последовательности бит, - б Как видно из полученных изображений (см. рис. 1-3), даже зная полученную последовательность и применяя всякого рода перестановки, атакующему все равно не удастся восстановить исходные изображения без знания размеров битовых векторов, полученных в результате разбиения на произвольное число частей исходной битовой последовательности. Рис. 3. Исходное изображение - а; изображение, полученное атакующим при попытке восстановить изображение из имеющейся у него последовательности бит, - б Понятно, что для каждого фрейма видеопотока формируется свой префикс - «ключевая последовательность», что позволяет говорить об аналогии с преобразованием, где используется одноразовый ключ. При наличии у пользователя информации о размере изображения (размер «стандартный» и известен всем), сформированного префикса и битовой последовательности, ему удастся восстановить исходное изображение. Но даже если атакующему станет известна часть префикса, но не А1, и данные будут разделены на равные части А1,А2,...,Ап, ему все равно не удастся восстановить исходное изображения, т.к. задача сводится к решению неопределенной системы уравнений из п уравнений с п + 1 неизвестными: А1 + а2 = X2 , An-1 + An = Xn . Восстановить изображение можно только подбором бит, но в случае, когда длина записи X1 больше, чем 80 бит, задача становится принципиально не решаемой, т.к. осуществить перебор на имеющейся в данное время вычислительной технике невозможно. Описанный метод не требует значительных вычислительных ресурсов и способен осуществлять преобразование данных «на лету». Заключение 1. Предложена схема разделения секрета, основанная на примитивизации дельта-кода Элиаса, описана его теоретическая часть. 2. Подготовлена программная реализация, осуществляющая выполнение описанного выше алгоритма, по полученным результатам программной реализации сделаны выводы об эффективности использования предложенного метода для сокрытия конфиденциальной информации. ]]></text>
</doc>
