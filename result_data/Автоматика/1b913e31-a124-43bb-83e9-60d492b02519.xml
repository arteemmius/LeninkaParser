<doc>
  <source auto="true" type="str" verify="true"><![CDATA[https://cyberleninka.ru/article/n/model-predstavleniya-znaniy-posredstvom-obektov-dlya-postroeniya-intellektualnyh-sistem-podderzhki-prinyatiya-resheniy]]></source>
  <category auto="true" type="str" verify="true"><![CDATA[Автоматика]]></category>
  <author auto="true" type="list" verify="true">
    <item type="str"><![CDATA[Литвин В.В.]]></item>
    <item type="str"><![CDATA[Досин Д.Г.]]></item>
    <item type="str"><![CDATA[Даревич Р.Р.]]></item>
  </author>
  <title auto="true" type="str" verify="true"><![CDATA[Модель представления знаний посредством объектов для построения интеллектуальных систем поддержки принятия решений]]></title>
  <keywords auto="true" type="list" verify="true"/>
  <annotation auto="true" type="str" verify="true"><![CDATA[]]></annotation>
  <text auto="true" type="str" verify="true"><![CDATA[Объектно-ориентированная модель представления знаний - относительно новый метод. Некоторые авторы считают, что эта модель возникла в результате развития фреймовой модели [1, 2]. По мнению многих специалистов [3, 4, 5, 6] эта модель представления знаний вместе с объектно-ориентированными языками программирования позволяет легко переходить от концептуального к формальному описанию модели, а затем и процесса реализации. В настоящее время подход к построению формальных математических моделей представления знаний посредством объектов находится на стадии интенсивного исследования. Авторами предлагается объектно-ориентированная модель представления знаний, которая базируется на понятии схемы объектов [7]. Целью работы являлась разработка основных концепций представления знаний посредством классов и объектов как экземпляров классов, что позволяет сохранять и обрабатывать естественный текст, в частности, решать задачу классификации текста (отнесение к определенному УДК), выполнять сравнения данного текста с другими источниками информации и определять их подобие. Задачей данной работы являлось определение основных подходов к построению определенной структуры, которая состоит из объектов предметной области и классов, к которым принадлежат эти объекты, и определить операции над этой структурой с целью решения задач поддержки принятия решений, в частности классификации научных статей за УДК. Рассмотрим основные понятия, которые отображают структурную сущность объектно-ориентированной модели. С этой целью введем следующие обозначения: С - класс, С - множество классов, которое наследовалось от С. К примеру, возьмем предложение “Основной целью интеллектуального анализа данных (ИАД) является выявление закономерностей, возникающих в базе данных (БД), и построение моделей, которые описывают эти закономерности” [8]. Схема объектов, которая отображает данное предложение, приведена на рис. 1. Для построения схем использован язык объектно-ориентированного моделирования иМЬ [9]. Если считать, что данная модель должна быть математической, то отдельно можно рассматривать аналитические и имитационные модели. ИАД - База данных: ИАД - Модель: ИАД Б Д -Таблицы: БД - Запроси: БД - ...: БД Модель - Объект моделирования: Модель - Тип модели: Модель Закономерность Аналитическая модель - Математический аппарат: Модель Имитационная модель Рис. 1. Пример объектно-ориентированной схемы данных. Путь Path к атрибуту An определим как последовательность C1A1A2...An, n > 1, где С1 - верхний класс в схеме (корень схемы), A¡ - атрибут класса С1, A ¡ - атрибут класса С, при этом C¡ является доменом атрибута A-1 класса С-1 (1< i < n). Значение n назовем длиной пути и будем помечать len(Path)=n. Определение 1. Классом пути назовем множество классов, через которые проходит заданный путь, то есть class(Path)=C1 ^ { Сi | Сi является доменом атрибуту Ai-1 из класса Ci.1, (1< i < n)}. Определение 2. Границей пути назовем множество классов, в которые входят классы из множества класса пути class(Path) вместе со всеми классами, что наследовались от них, то есть scope(Path)= ^С ¡ } С ; класс С1 является корнем scope(Path). Каждому классу С из scope(Path) определим номер позиции i (обозначим pos). Позицию i определим как номер класса С, к которому согласно с иерархией наследственности принадлежит класс С, где Ci е class(Path). Пример 1. Рассмотрим путь Path=ИАД.Модель.Тип моде- ли.Математический аппарат len(Path)=3 classPath={ИАД,Модель,Аналитическая модель} scope(Path)= {ИАД,Модель,Аналитическая модель,Имитацирнная модель} Класс ИАД является корнем scope(Path) pos(Аналuтuческая модель)=3 Определение 3. Объект о является экземпляром класса С, если С является наиболее специализированным классом, ассоциируемым с объектом в иерархии наследственности. Определение 4. Объект о является экземпляром класса С, если он является экземпляром С или экземпляром некоторого подкласса С. То есть экземплярами класса С являются все экземпляры класса С, которые не относятся к любому другому подклассу С. Объект о подадим в виде тройки o=(id, С, val), где id - идентификатор объекта; С - класс, к которому принадлежит объект; val - значение объекта. Значение может быть атомарным (целые числа, символы, символьные строки, логические переменные и действительные числа); множество (набор идентификаторов объектов); список или кортеж (набор атрибутов). Множества задают набор объектов реального мира; кортежи - свойства объектов, а списки - порядок, который имеет место в реальном мире. Модель ПО интерпретирует классы. Определение интерфейса класса происходит через методы, которые являются шаблоном для всех объектов, (экземпляров классов). Методы носят имя функций, параметрами и результатом которых являются объекты. Метод - это отображение некоторого подмножества аргументов объектов в новый объект. Каждый метод имеет форму Ci X С2 X Cn ^ С^ где С1,С2,...,Cn классы, к которым принадлежат объекты, являющиеся аргументами в методе; Cresult - класс объекта результата. Все классы формируют дерево, в котором вершина корня задает самый общий класс объектов. Любой другой класс может иметь родителей. Подклассы унаследовали поведение от своих родителей, а также могут определять собственные дополнительные методы. Таким образом, дерево классов обеспечивает полиморфизм вмещения [4], который позволяет объекту класса C использоваться в любом контексте. Объекты инкапсулируют состояние и поведение. Состояние объекта зафиксировано его значением. Методы, определенные на классе, объект которого является экземпляром, определяют поведение объекта. Поведение проявляется, применяя метод к объекту. Результат прикладной программы метода - некоторый другой объект. Для определения методов над объектами используют запись (о1;o2,...,on)m1m2...mn. Запись o0^...,o„)mltst используют, когда список имен методов несущественный [2]. Понятие схемы объектов. Объекты разных классов соотносятся между собой, образуя единственную структуру, которую будем называть схемой и обозначать Sch. Это соотношение является иерархическим (агрегация или наследственность) и (или) образуется через определение поведения объектов разных классов. Математическую модель такой схемы определим по работе [10], где рассматривается модель семантических сетей. Среди возможных схем выделим два крайних случая: • схему, в которой используются исключительно объекты, обозначим oSch = {o1, o2,..., ок}. • схему, в которой используются исключительно классы, обозначим oSch = {, C2,..., Ck}. Чаще всего употребляются смешанные схемы, в которых используются и классы, и объекты. С целью не разделять отдельно класс C и объект o этого класса o е C , будем обозначать их одной буквой z. Тогда множество всех элементов, которые входят в схему, будем записывать в виде z = {z1, z2,..., zs}. Операции над схемами хорошо выполнять, оперируя с их аналитическим выражением. Рассмотрим множество Q = {^1, q2,..., qp } всех отношений, которые определены в схеме. То есть, Q = {m11,...,m1m,m21,...,m2m,...,ms1,...,mm ,hier1,...,hierp}, где Mt = {mn,...,mim }- множество методов, определенное для z. Hier={hier1,., hierp} - множество всех иерархических отношений (is-а, part-of), определенных в схеме. Мощность множества Q равняется P=m1 + ... +ms+hierp. Множество Q будем записывать в виде Q={M1,M2,...,Ms,Hier}. Тогда любую схему можно представить как Sch={z1,z2,...,zs,Fz1 ,Fz2,...,Fzs}, где Fz I - подмножество элементов с Z, с которыми элемент Zi связан отношениями с Q. В общем виде схему можно рассматривать как пару Sch=(Z,F), где F - отображение Z в Z, взвешенное отношениями с Q: F :ZZ- Последнюю короткую запись будем использовать для определения операций над схемами. Объединение схем. Пусть заданы схемы Sch1=(Z1,F1), Sch2=(Z2,F2),..., Sch„=(Zn,Fn). Схема Sch=(Z,F) называется объединением схем Schi, i=1,2,...,n и обозначается Sch= Schi, если Z= Zi и для V z е Z, Fz= Fiz, i=1,.,n. Пересечение схем. Пусть заданы схемы Schi=(ZbFi), Sch2=(Z2,F2),..., Schn=(Zn,Fn). Схема Sch=(Z,F) называется пересечением схем Schi, i=1,2,...,n и обозначается Sch= ^ Schi, если Z= ni Zi и для V z е Z, Fz= ni Fiz, i=1,.,n. Определение 5. Схема Sch =(Z ,F ) называется подсхемой Sch=(Z,F) и обозначается Sch* — Sch, если Z* — Z и V z е Z*, F*z — Fz. Дополнение схемы. Пусть заданы схемы Schi=(ZbFi) и Sch2=(Z2,F2) такие, что Sch2 является подсхемой Schi, то есть Sch2 — Schi. Схема Sch3=(Z3,F3) называется дополнением схемы Sch2 к схеме Sch1, если Sch3= Sch1/ ^ Sch2, где Sch/ =(Z1,F1), Sch2=(Z2,F2), и выполняются следующие условия: 1) Z1/=Z1\Z2; V zeZ1/, F1/z — F1z; 2) Z2= Z1// ^ Z2// , где Z1// — Z1/ , Z2// — Z2/, к тому же каждый элемент ze Z1// связан минимум одним отношением с объектами с Z2; V ze Z2/, F2z — F1z. Вмещение схем.Определим операцию вмещения схемы в схему. Сначала сделаем это для более простых схем, состоящих из двух элементов и одного отношения между ними. Пусть CSch0=(C1,C2,F0C1,F0C2) , где F0C1={q1C2}; FoC2={0}. Схема oSch1=(o1,o2,F1o1,F1o2), где F1o1={q1o2}; F1o2={0}, называется вмещенной в CSch0, если o1 е C1, o2 е C2, Ffi1 — F0C1, Fo — F0C2. Произвольная схема oSch называется вмещенной в схему CSch, если любая подсхема схемы, которая состоит из двух объектов и одного отношения между ними, вмещена в схему. В результате выполнения операции вмещения отношения, существующие между классами схемы, могут быть перенесены с конкретизацией на объекты схемы. Определение 6. Две схемы Schi=(Zi,Fi) и Schj=(Zj,Fj) называются структурноэквивалентными, если они отличаются друг от друга только заменой значений элементов или отношений. Конкретизация схем. Эта операция своим характером близка к операции вмещения схем с сохранением отношений. В ее основании лежит механизм генерации схем, структурно-эквивалентных схеме (или ее фрагменту), помещенных в нее. В более простом случае генерация заключается в выделении элементов из множества объектов и отношений схемы и построении на их основе схемы, структурноэквивалентной схеме помещенной в нее. Аналитически эта операция определяется следующим образом. Пусть CSch=(C1,C2,...,Ci,...,Cn,FC1,FC2, ...,FCi,...,FCn) является заданной схемой. Схема oSch=(o1,o2,...,oi,...,on,Fo1,Fo2,...,Foi,...,Fon) называется результатом конкретизации CSch, если oie Ci, Foi — FCi, i=1,...,n. Для описания процесса решения задачи используем подход, известный в литературе как метод информационной доски [5]. Рассмотрим архитектуру этого метода в виде системы классов и механизмов их взаимодействия. Основу метода составляют три элемента: информационная доска, источники знаний, управляющая функция [6]. Информационная доска нужна для того, чтобы сохранять данные о процессе решения задачи и состояниях ПО. Доска содержит объекты ПО, которые группируются за уровнями иерархии. Необходимые для решения задачи знания о ПО разделенные на несколько независимых источников. Каждый источник знаний пытается предложить информацию, которая является полезной в процессе решения задачи. Текущая информация из каждого источника помещается на доске и модифицируется в зависимости от содержания знаний. Объекты на информационной доске образуют иерархическую структуру, отвечающую источникам знаний. Каждый источник использует объекты одного уровня иерархии как входные данные, а как выходные - генерирует или изменяет объекты на другом уровне. Руководящая функция на основе эвристических функций, определенных в ПО, определяет, какой источник знаний активизировать, то есть эвристическая функция выступает как параметризированный класс [6]. Объекты на доске образуют иерархию, которая отображает иерархичность разных уровней абстракции. Информационная доска является суперклассом для классов, которые находятся на доске. Если введенную схему рассматривать как отдельный класс, то на информационной доске можно осуществить манипулирование схемами посредством вышеприведенных операций. Для реализации построенных моделей была выбрана программная среда CLIPS и ее объектно-ориентированное расширение CLIPS Object-Oriented Language (COOL) [11]. Рассмотрим как можно реализовать предложение в виде схемы. В программной среде CLIPS части предложения поступают в виде шаблонов: (deftemplate TemplBase (slot number (default 0)) (multislot subject: (default no subject)) (multislot predicate: (default no_predicate)) (multislot attribute: (default no attribute)) (multislot object: (default no attribute))). Первым этапом формирования объекта схемы является проверка на существование объекта в базе знаний (БЗ). В случае нахождения объекта формируется его копия и передается блоку корректировки свойств, который проверяет, присутствует ли свойство (определение) в копии объекта. Если свойство найдено, то объект заносится в схему (файл, который содержит совокупность объектов, созданных из текстовой информации). В противоположном случае данное свойство заносится в онтологию базы знаний (ОБЗ), объект заносится в схему. Операция поиска осуществляется посредством правил (rules): для объектов (defrule MAIN::CheckObject (TemplBase (number ?number) (subject: ?subject) (predicate: ?predicate) (attribute: ?attribute)) => (if (eq TRUE (instance-existp ?subject)) then ... else ...)); для класса (defrule MAIN::CheckClass (TemplBase (number ?number) (subject: ?subject) (predicate: ?predicate) (attribute: ?attribute)) => (if (eq TRUE (class-existp ?subject)) then ... else ...)). Добавление нового свойства к существующему объекту происходит в два этапа. Первым этапом является добавление нового свойства класса, экземпляром которого является объект. Это возможно посредством разработанной функции ModifylnsertSlot, принцип работы которой представим ниже. Второй этап - создание объекта с прибавленным новым свойством. Когда поиск объекта испытал неудачу, происходит поиск среди классов в ОБЗ. При положительном результате поиска происходит создание нового объекта, который поступает на блок корректировки свойств. Отсутствие класса сопровождается поиском объекта в БЗ. Создание нового объекта осуществляется посредством функции make-instance, например, создадим объект Audi класса car: (make-instance [Audi] of car (type Audi) (transmission manual)(engine diesel)). Класс создается посредством конструкции defclass. Положительный результат вызывает создание в ОБЗ нового класса, который является подклассом найденного класса (добавление); создание нового объекта и корректировка его свойств; запись объекта в БЗ и схему. Данный процесс формирования объектов проводится для всех предложений, которые содержатся в тексте. В результате этого получаем файл набор схем, представлящих данный текст. Создается общая схема текста пользователя, который должен служить образцом для последующего анализа. Происходит поиск текстов в Интернете и создания их схем. Завершающим этапом сравнения соответствия текста образцу с найденным является формирование вывода по соответствующим критериям, которые в данной работе не рассматриваются. Выводы. Авторами разработан метод представления знаний посредством классов и объектов как экземпляров классов. Сформулировано понятие схемы объектов, как способа представления определенной структуры, например естественного текста. Операции над схемами позволяют манипулировать этой структурой, осуществляя логической вывод, тем самым решая определенную задачу, например задачу классификации текста (отнесение к определенному УДК), сравнение данного текста с другой информацией и определение их подобия. Эта модель легко реализуется прикладными средствами построения интеллектуальных систем на базе объектно-ориентированных языков программирования, например CLIPS. ]]></text>
</doc>
