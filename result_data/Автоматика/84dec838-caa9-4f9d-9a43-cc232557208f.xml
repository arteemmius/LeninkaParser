<doc>
  <source auto="true" type="str" verify="true"><![CDATA[https://cyberleninka.ru/article/n/ispolzovanie-pobochnyh-effektov-funktsiy-dlya-uskoreniya-avtomaticheskogo-poiska-uyazvimostey-v-programmah]]></source>
  <category auto="true" type="str" verify="true"><![CDATA[Автоматика]]></category>
  <author auto="true" type="list" verify="true">
    <item type="str"><![CDATA[Несов В.С.]]></item>
  </author>
  <title auto="true" type="str" verify="true"><![CDATA[Использование побочных эффектов функций для ускорения автоматического поиска уязвимостей в программах]]></title>
  <keywords auto="true" type="list" verify="true"/>
  <annotation auto="true" type="str" verify="true"><![CDATA[]]></annotation>
  <text auto="true" type="str" verify="true"><![CDATA[Введение В Институте системного программирования РАН разработана среда обнаружения уязвимостей [1][2] в исходном коде программ на языке C, позволяющая обнаруживать уязвимости и дефекты следующих типов: - переполнение буфера (buffer overflow); - неконтролируемая форматная строка (format string); - разыменование нулевого указателя (null pointer) ; - утечка памяти (memory leak). Перед средой ставилась задача не пропускать уязвимости. Для этого предупреждения о возможных дефектах выводятся во всех местах анализируемой программы, в которых при помощи анализа не удалось доказать отсутствие дефектов. Среда использует межпроцедурный итеративный анализ потока данных. Высокая точность выполняемого анализа требуется для снижения количества ложных предупреждений, число которых в данной постановке задачи непосредственно от нее зависит. При межпроцедурном анализе информация о значениях переменных распространяется через точки вызовов функций. Для того, чтобы информация о значении некоторой переменной распространилась от одной функции к другой, она проходит через все промежуточные функции на графе вызовов. Так как каждая функция программы может вызываться из нескольких мест, среднее количество информации, проходящей через каждый вызов в графе вызовов, увеличивается с увеличением размера анализируемой программы. В статье описывается метод, позволяющий сократить количество распространяемой по графу вызовов информации о значениях переменных, тем самым сокращая время анализа и требуемое количество памяти. Метод основан на нахождении побочных эффектов функций одновременно с выполнением основного анализа, и ограничении распространяемых значений переменных с использованием этой информации. Отавшаяся часть статьи организована следующим образом. В разделе 2 приводится обзор процесса анализа. В разделе 3 подробно описывается анализ инструкции вызова функции, передающей данные между процедурами. В разделе 4 описано использование побочных эффектов функции для ограничения распро- странения значений переменных через точки вызова функций. Раздел 5 содержит результаты проведенных экспериментов. Краткое описание процесса анализа В этом разделе кратко описывается процесс автоматического анализа программ в среде обнаружения уязвимостей. Более подробное описание, включающее особенности реализации, можно найти в [2]. Анализируемая программа собирается с использованием модифицированной версии компилятора gcc, дополнительно выдающей файлы, содержащие внутреннее представление для каждого скомпилированного модуля. Набор модулей, составляющий анализируемую программу, объединяется в проект. Среда обнаружения уязвимостей считывает файлы проекта. Для каждой функции строится граф потока управления (в вершинах которого расположены отдельные инструкции внутреннего представления), для проекта в целом строится статический граф вызовов. Впоследствии граф вызовов дополняется ребрами, соответствующими вызовам по указателям. Каждому ребру графов потока управления сопоставляются (изначально пустые) контексты. Т акже контексты сопоставляются точкам входа и выхода из функций. Каждый контекст хранит информацию о значениях переменных, определенную для данной точки программы. Каждой точке определения переменной (включая точки выделения памяти в куче) сопоставляется абстрактная ячейка памяти (АЯП). Контекст сопоставляет каждой АЯП набор атрибутов. Используются следующие атрибуты: - интервал возможных значений (для целочисленных переменных); - множество АЯП, указываемых данным указателем, со смещением указателя относительно каждой указываемой АЯП; для смещения указывается интервал его возможных значений; - флаг, указывающий факт удаления переменной из кучи (для областей памяти в куче); - флаг, указывающий наличие зависимости значения переменной от пользовательского ввода. При межпроцедурном анализе граф потока управления обходится топологически, попеременно в прямом и обратном направлениях. В каждой точке обхода для текущей функции выполняется внутрипроцедурный анализ. При внутрипроцедурном анализе граф потока управления топологически обходится в прямом направлении. Для каждой инструкции применяется функция преобразования потока данных, находящая значения контекстов на исходящих из инструкции ребрах графа потока управления по значениям контекстов на входящих в данную инструкцию ребрах. Анализ вызова функции Межпроцедурная передача информации происходит в функциях преобразования потока данных, сопоставленных инструкциям вызова. При анализе инструкции вызова часть входного контекста вызова передается вызываемой функции. Собранные таким образом из разных мест вызова контексты впоследствии объединяются, составляя входной контекст вызываемой функции. Часть выходного контекста вызываемой функции используется для замены атрибутов АЯП входного контекста вызова для определения выходного контекста вызова. Каждая функция принимает часть АЯП извне (из разных точек вызова), часть АЯП являются локальными для функции, и оставшиеся АЯП обозначают созданные в результате выполнения функции области памяти в куче. Передаваемые вы- зываемой функции АЯП (часть входного контекста инструкции вызова) ограничиваются доступными из вызываемой функции. Для формирования выходного контекста используются АЯП, созданные внутри функции, и АЯП, переданные из данного вызова. Таким образом, ограничивается распространение АЯП по нереализуемым путям, когда переданное в вызываемую функцию в одной точке вызова значение в результате неточности анализа передается другой точке вызова той же функции. Будем обозначать множество АЯП, атрибуты которых определены в контексте C, как Def(C). Будем обозначать Pt(x,C) множество АЯП, указываемых АЯП x в контексте C (points-to атрибуты). Если x не является указателям, или xg C, положим Pt(x,C)=0. Для АЯП, обозначающих переменные структурных типов, поддерживаются отдельные АЯП, обозначающие их поля. Будем обозначать Fi(x) множество полей АЯП x. При вызове функции происходит копирование фактических параметров в формальные, а также внутреннего возвращаемого функцией значения в переменную, принимающую его при вызове. Для данного вызова обозначим ActToForm функцию, сопоставляющую фактическим параметрам формальные (определенную на множестве фактических), ActSet множество фактических параметров, RetToRes функцию, отображающую внутреннее возвращаемое функцией значение Ret на принимающую его переменную вызывающей функции. Обозначим Close(C,S) операцию замыкания множества АЯП S в контексте C относительно преобразования FC(S) = SuNextPtGen(C,S)uFi(S), где NextPtGen(C, S) = U PI (s, C). seS Close(C,S) есть минимальное множество такое, что ScClose(C,S) и Close(C,S)=Fc(Close(C,S)). Обозначим Retain (C,S) операцию, возвращающую контекст C, в котором удалены все АЯП, не включенные в S (в том числе и из points-to атрибутов). Наконец обозначим Replace(C,F) преобразование, возвращающее контекст C с ключами (АЯП), замененными в соответствии с частично определенной функцией F: АЯП®АЯП (на ее области определения). Пусть входной контекст вызова обозначен In, предикат принадлежности к множеству всех глобальных переменных isGlob. Псевдокод нахождения входного контекста вызова функции с удаленными АЯП, не достижимыми из вызываемой функции, приведен на рис. 1. Полученный трансляцией фактических переменных в формальные контекст PassedToCallee передается вызываемой функции. InGlob = {seDef(In) | isGlob(s)} ; множество непосредственно доступных ; вызываемой функции АЯП InAnchorSet = InGlobuActSet ; множество доступных из InAnchorSet АЯП InAccSet = Close(In, InAnchorSet) ; суженный контекст, содержащий ; только АЯП из InAnchorSet FilteredInput = Retain(In, InAccSet) ; результат трансляции фактических параметров ; в формальные PassedToCallee = Replace(FilteredInput, ActToForm) Рис. 1. Псевдокод алгоритма передачи информации к вызываемой функции Пусть выходной контекст функции обозначен FExit. Псевдокод нахождения копируемой в выходной контекст вызова части FExit приведен на рис. 2. Использование побочных эффектов Каждой функции сопоставляется множество АЯП побочных эффектов. Побочные эффекты каждой функции складываются из побочных эффектов каждой инструкции, входящей в функцию. При анализе каждой инструкции определяется множество АЯП, атрибуты которых читаются либо изменяются [2]. ; множество доступных из выходного контекста функции АЯП ExitAccSet = Close(FExit, Def(FExit)) ; множество глобальных АЯП в ExitAccSet ; (на которые вызываемая функция могла сослаться независимо ; от того, передавались ли они ей извне) ExitGlobSet = {seExitAccSet | isGlob(s)} ; множество АЯП в ExitAccSet, выделенных в куче ; (которые могли быть созданы в результате вызова функции) ExitHeapSet = {seExitAccSet | isHeap(s)} IndirectlyAccActSet = ActSet n NextPtGen(In, InAccSet) ; множество АЯП, доступных из вызываемой функции ; через переданные данным вызовом AccFromCallee = (InAccSet \ ActSet) u IndirectlyAccActSet ; множество АЯП, доступных из AccFromCallee ; в выходном контексте вызываемой функции ExitPassSet = Close(FExit, AccFromCallee) ; ограничение на возвращаемое множество АЯП ; для данного контекста вызова RetrSet = ExitGlobSet u ExitHeapSet u ExitPassSet u {Ret} PassedFromCalleeInt = Restrict(FExit, RetrSet) PassedFromCallee = Replace(PassedToCalleeInt, RetToRes) Рис. 2. Псевдокод алгоритма передачи информации к вызывающей функции Пусть множество побочных эффектов вызываемой функции обозначено ChangeSet. Измененный псевдокод вычисления множества InAccSet, ограничивающего передаваемую к вызываемой функции часть входного контекста вызова, приведен на рис. 3. InGlob = {seChangeSet | isGlob(s)} ; множество непосредственно доступных ; вызываемой функции АЯП, включенных ; в множество побочных эффектов InAnchorSet = InGlobuActSet ; множество доступных из InAnchorSet АЯП, ; включенных в множество побочных эффектов InAccSet = Close(In, InAnchorSet) n ChangeSet Рис. 3. Псевдокод измененного алгоритма передачи информации к вызываемой функции Так как не все из входящих в ChangeSet АЯП обязательно определены в контексте In, для распространения множества побочных эффектов по графу вызовов InAccSet добавляется в множество побочных эффектов вызывающей функции полностью. АЯП распространяется от вызывающей функции к вызываемой только по требованию через множество побочных эффектов. За счет топологического по- рядка обхода графа вызовов такое требование достигает точки назначения за одну итерацию и межпроцедурный анализ замедляется незначительно. Экспериментальные результаты В табл.1 показаны результаты анализа 14 пакетов свободно распространяемого ПО. Таблица 1 ___________________________Результаты работы среды_________________________ LOC NOF без учета побочных эффектов с учетом побочных эффектов time (сек) avg time (сек) avg polymorph-0.4.0 400 28 4 33 3 2 surfboard-1.1.8 675 27 6 16 4 4 lhttpd-0.1 814 19 6 21 5 5 ssmtp-2.60 1818 41 21 57 12 7 troll-ftpd-1.26 2279 95 106 72 59 б pound-1.0 1796 49 34 149 27 2 muh-2.05d 2863 184 123 139 46 10 bftpd-1.0.24 3023 181 141 145 46 38 pgp4pine-1.76 3340 106 231 281 37 8 cfingerd-1.4.3 3699 233 313 373 50 4 pcre-3.9 5625 80 343 52 211 10 .2. - ip 'n ад 5832 111 246 196 75 29 sharutils-4.2.1 6368 101 88 103 26 5 thttpd-2.23beta1 7955 191 602 305 120 33 Для каждого пакета приведены его название и номер версии, количество строк исходного кода пакета без учета пустых строк (колонка LOC), количество функций в пакете (колонка NOF). Для каждого варианта реализации среды указаны время анализа (колонки time) и средний размер входных контекстов функций (количество определенных АЯП), установившийся в конце анализа (колонки avg). Как видно из результатов, использование побочных эффектов многократно снижает количество элементов контекстов функций (в 10-50 раз, в зависимости от проекта). Такое снижение даже с учетом возникновения издержек на вычисление побочных эффектов приводит к снижению времени анализа в 2-6 раз. Для больших размеров анализируемых программ выиграш во времени от применения оптимизации увеличивается. ]]></text>
</doc>
