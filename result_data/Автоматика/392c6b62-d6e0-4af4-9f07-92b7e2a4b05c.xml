<doc>
  <source auto="true" type="str" verify="true"><![CDATA[https://cyberleninka.ru/article/n/algoritm-poiska-vektorov-pohozhesti-pri-szhatii-videodannyh]]></source>
  <category auto="true" type="str" verify="true"><![CDATA[Автоматика]]></category>
  <author auto="true" type="list" verify="true">
    <item type="str"><![CDATA[Потапов П.В.]]></item>
    <item type="str"><![CDATA[Кориков A.M.]]></item>
  </author>
  <title auto="true" type="str" verify="true"><![CDATA[Алгоритм поиска векторов похожести при сжатии видеоданных]]></title>
  <keywords auto="true" type="list" verify="true">
    <item type="str"><![CDATA[МУЛЬТИМЕДИА]]></item>
    <item type="str"><![CDATA[ВИДЕОДАННЫЕ]]></item>
    <item type="str"><![CDATA[СЖАТИЕ]]></item>
    <item type="str"><![CDATA[ВЕКТОР ПОХОЖЕСТИ]]></item>
    <item type="str"><![CDATA[ОЦЕНОЧНАЯ ФУНКЦИЯ]]></item>
  </keywords>
  <annotation auto="true" type="str" verify="true"><![CDATA[Предложен новый алгоритм поиска векторов похожести при сжатии видеоданных. Использование данного алгоритма позволяет улучшить производительность и степень компрессии видео. Проведен сравнительный анализ предложенного алгоритма с аналогами.]]></annotation>
  <text auto="true" type="str" verify="true"><![CDATA[П.В. Потапов, А.М. Кориков* Отдел проблем информатизации ТНЦ СО РАН, г. Томск *Томский государственный университет систем управления и радиоэлектроники E-mail: PotapovPavel@mail.ru, korikov@asu.tusur.ru Предложен новый алгоритм поиска векторов похожести при сжатии видеоданных. Использование данного алгоритма позволяет улучшить производительность и степень компрессии видео. Проведен сравнительный анализ предложенного алгоритма с аналогами. Ключевые слова: Мультимедиа, видеоданные, сжатие, вектор похожести, оценочная функция. Введение Пропускная способность компьютерных сетей продолжает расти, высокоскоростное соединение с домашним компьютером стало обычным явлением. Вместительность жёстких дисков, флэш-памяти и оптических устройств хранения данных стала больше чем когда-либо. Стоимость передачи и хранения информации становится всё меньше и меньше, однако проблема сжатия видеоданных не теряет своей актуальности. Возникновение мультимедиа (multimedia) как нового научно-технического направления поставило проблему сжатия различных сигналов на первое место. Алгоритмы сжатия видеоданных постоянно совершенствуются, создаются новые стандарты видеокомпрессии. Сжатие видеоданных имеет два важных достоинства. Во-первых, сжатие позволяет использовать цифровое видео в таких средах хранения и передачи информации, в которых невозможно использовать видео без компрессии. Во-вторых, сжатие видеоданных позволяет более эффективно использовать ресурсы среды передачи или хранения информации [1]. В настоящее время огромное внимание уделяется разработке алгоритмов сжатия видеоданных, использующих компенсацию движения. Так, начиная с 1980 г. организации ITUи MPEG последовательно выпускают ряд стандартов сжатия, использующие блочную компенсацию движения: H.261, MPEG-1, MPEG-2/H.262, H.263, MPEG-4, H.264 (MPEG-4 ^art-10) [2]. Использование алгоритмов компенсации движения при сжатии видеоданных позволяет существенно увеличить степень компрессии при том же соотношении сигнал/шум результирующего видеосигнала. Параллельно с разработкой новых стандартов сжатия происходит совершенствование алгоритмов поиска векторов похожести. Алгоритм поиска векторов похожести является важнейшей частью в системе сжатия видеосигнала. От выбора алгоритма поиска векторов похожести напрямую зависит степень компрессии и вычислительная сложность алгоритма сжатия. Поиск векторов похожести является одним из самых ресурсоемких этапов компрессии видеосигнала. Однако сам алгоритм поиска векторов похожести обычно не фикси- руется в стандарте сжатия. Таким образом, модуль поиска векторов похожести является одной из немногих частей видеокомпрессора, которую можно свободно подвергать алгоритмической оптимизации. Реализация оптимизированного модуля даёт значительное конкурентное преимущество над другими компрессорами, реализующими тот же стандарт сжатия. Именно поэтому в этой области продолжаются интенсивные исследования, несмотря на то, что уже разработано множество алгоритмов векторов похожести движения для различных задач. Критерии сравнения алгоритмов поиска векторов похожести Для сравнения алгоритмов было выбрано два критерия: 1) количество вычислений оценочной функции -N позволяет оценить вычислительную сложность алгоритма поиска векторов похожести; 2) в качестве оценки точности найденных векторов похожести используется размер сжатой видеопоследовательности M, компрессия производится в соответствии со стандартом MPEG-2 с постоянным коэффициентом квантования. Для нахождения векторов похожести во время компрессии используются оцениваемый алгоритм. Оценочная функция В качестве оценочной функции традиционно используется сумма абсолютных разностей (SAD — sum of absolute differences). Вычисление данной функции не требует умножений, что делает её привлекательной для поиска векторов похожести. Функция SAD для некоторого блока A размером KxK, имеющего координаты (x,y), и вектора похожести V вычисляется следующим образом: SAD(Vx ,Vy) = K-1 = ^ \lt(x + m,y + n) -It_!(x + Vx + m,y + Vy + n)|, m ,n=0 где I, I-1 - значения яркости пикселей текущего и предыдущего кадров [3]; t - номер текущего кадра. Описание разработанного алгоритма Для формализации процесса разработки алгоритм поиска векторов похожести был разбит на следующие части: • поиск начального приближения вектора похожести; • уточняющий поиск; • завершающая обработка найденных векторов похожести. Этап поиска начального приближения вектора похожести очень важен. Так как оценочная функция не является выпуклой и имеет множество оврагов и локальных минимумов, применение метода локальной оптимизации будет не эффективно, если начальная точка поиска выбрана неудачно. Для определения начальной точки поиска применяется алгоритм поиска начального приближения вектора похожести. Для определения точки начального приближения мы можем использовать найденные векторы похожести соседних блоков в текущем кадре, а также векторы похожести из предыдущего кадра. Использование этой априорной информации и есть основная идея метода поиска начального приближения вектора похожести. Изложим алгоритм реализации этой идеи с помощью рисунка, на котором представлены блоки поиска начального приближения: 1. Векторы соседних блоков MB1, MB2, MB3 (рис. 1) используются для определения так называемого медианного (среднего) вектора [4]. Вычисляем значение оценочной функции для медианного вектора. Сравниваем это значение с пороговой величиной T1, если полученное значение меньше чем T1 переходим к уточняющему поиску, в противном случае переходим к следующему шагу 2. Пороговая величина T1 вычисляется исходя из значений оценочных функций соседних блоков по формуле: T1 = ak min(SADj,SAD2,SAD3,SAD4) +bk, где ak, bk - весовые коэффициенты. мв2 МВз MB, Текущий блок Рисунок. Блоки, используемые для вычисления медианного вектора 2. Составляем список векторов-кандидатов. В этот список добавляем найденные векторы соседних блоков в текущем и предыдущем кадрах. Также в список добавляются интерполированные векторы: если в предыдущем кадре вектор движения какого либо из блоков указывал в текущий блок, то этот вектор так же добавляется в список [5]. 3. Из списка векторов-кандидатов удаляем близкие вектора. Для всех векторов попарно рассчитывается величина d(F, V)=| V1-V:2|+| V-1-V2|. Если d(Vn,Vm)<T2, то вектор Vm исключается из списка векторов-кандидатов. Экспериментально было получено оптимальное значение параметра T2, равное 4 [6]. 4. Вычисление оценочной функции производим для всех оставшихся векторов-кандидатов. Вектор-кандидат с наименьшим значением оценочной функции принимается за вектор начального приближения. 5. Если значение оценочной функции в точке начального приближения больше чем 73=1/271, то принимаем решение о том, что точка начального приближения найдена неудачно и производим её адаптивный поиск методом сканирования в зависимости от размеров поискового окна и разрешения изображения. В результате работы данного алгоритма получаем точку начального приближения. На следующем этапе происходит уточнение найденного вектора похожести. Для проведения уточняющего поиска выбран градиентный метод локальной оптимизации [7]. Градиентный метод сводится к следующему итерационном процессу: 1. В точке Vk вычисляется градиент оценочной функции. Вычисление градиента оценочной функции в зависимости от ситуации производится методом прямой (упреждающей), либо обратной (отстающей) конечной разности по формулам: Vf(х, у) = {f (x +1, y) - f (x, y), f(x, y +1) - f(x, y)}, Vf(x,y) = {f (x, y) - f(x-1, y), f(x, y) - f(x, y-1)}. 2. Принимаем Vk+1 = Vk -Я^ (V ^, где Я - шаг I Vf (Vk )|| поиска, вычисляем f(Vk+1); 3. Если f(Vk+1)<f(Vk), принимаем V+1 за текущую точку и переходим к шагу 1, иначе уменьшаем Я в два раза и переходим к шагу 2. Поиск производится до тех пор, пока Я>1. Результатом поиска является вектор похожести Vе. Экспериментально доказано, что метод поиска с использованием градиента требует меньше вычислений оценочной функции для нахождения локального минимума, чем методы нулевого порядка, такие как метод Гаусса-Зейделя, метод Хука-Джи-вса, симплексный метод. Метод локальной оптимизации с использованием градиента требует меньше вычислений оценочной функции по сравнению с методами поиска по шаблону, применяемыми в алгоритмах Diamond, PMVFAST [5] EPZS [3]. После нахождения векторов похожести для всех блоков кадра производится уточняющий обратный проход. На этом этапе проходим все блоки кадра в обратном порядке. По сравнению с первым проходом появляется информация о векторах похожести блоков, расположенных ниже и правее текущего блока. Проверяем значения оценочных функций для этих векторов. Если значение оценочной функции меньше чем для найденного на первом проходе вектора похожести, проводим уточняющий поиск для вектора с наименьшим значением оценочной функции. Сравнение с аналогами Проведем сравнение разработанного алгоритма с современными аналогами. В сравнительном анализе участвовали алгоритмы: CBA [8], ADZS [5], PMVFAST, EPZS. Алгоритм EPZS является одним из наиболее эффективных алгоритмов поиска векторов похожести. Использование этого алгоритма позволяет достичь высокой степени компрессии с при низком количестве вычислений оценочной функции [3]. При сравнении использовался программный продукт - программная среда MEFramework [9]. Данная среда была разработана для сравнения алгоритмов поиска векторов похожести при сжатии видеоданных. В ходе сравнения производилось сжатие тестовых видеопоследовательностей в соответствии со стандартом MPEG-2 с постоянным коэффициентом квантования с использованием тестируемого алгоритма поиска векторов похожести. В таблицу заносилось количество вычислений оценочной функции N, а так же результирующий размер сжатой видеопоследовательности M. Количество вызовов оценочных функций для сравниваемых алгоритмов приведено в табл. 1. Значения меры M, полученные для исследуемых алгоритмов на тестовых видеопоследовательностях, представлены в табл. 2. В таблицах предложенный алгоритм обозначен как «Proposed». Из табл. 1 видно, что количество вычислений оценочной функции для разработан- ]]></text>
</doc>
