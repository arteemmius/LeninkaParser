<doc>
  <source auto="true" type="str" verify="true"><![CDATA[https://cyberleninka.ru/article/n/shpargalka-dlya-perehoda-ot-ahdl-k-vhdl]]></source>
  <category auto="true" type="str" verify="true"><![CDATA[Автоматика]]></category>
  <author auto="true" type="list" verify="true">
    <item type="str"><![CDATA[Каршенбойм Иосиф]]></item>
    <item type="str"><![CDATA[Косткин Михаил]]></item>
  </author>
  <title auto="true" type="str" verify="true"><![CDATA[Шпаргалка для перехода от AHDL к VHDL]]></title>
  <keywords auto="true" type="list" verify="true"/>
  <annotation auto="true" type="str" verify="true"><![CDATA[Когда-то в популярной книжке по математике была напечатана такая шутка. Математик задал Физику задачу: «Имеем чайник, воду, плиту и спички. Как получить кипяток?» Физик ответил — «Поставить чайник на плиту, налить воду, зажечь плиту и вскипятить воду». Статья описывает переход от AHDL к VHDL.]]></annotation>
  <text auto="true" type="str" verify="true"><![CDATA[Иосиф Каршенбойм Ik@lmail.loniis.spb.su Михаил Косткин kostkin@asicdesign.ru Вступление Когда-то в популярной книжке по математике была напечатана такая шутка. Математик задал Физику задачу: «Имеем чайник, воду, плиту и спички. Как получить кипяток?» Физик ответил — «Поставить чайник на плиту, налить воду, зажечь плиту и вскипятить воду». «Правильно, — сказал Математик, — а вот более сложная задача — чайник с водой уже стоит на плите, что нужно сделать в этом случае?» Физик ответил, чего, мол, проще, надо зажечь огонь и готово. «Нет, — сказал Математик, — надо вылить из чайника воду, и тогда мы придем к задаче, которую уже умеем решать». То же происходит и в реальной жизни, когда есть необходимость перевести старый проект из ЛИБЬ в УИБЬ. Можно просто взять и сделать проект заново, а можно попытаться переписать строчку за строчкой. Для того чтобы этот процесс произошел быстрее, можно прибегнуть к данной шпаргалке. Необходимость перехода от языка ДИРЬ к УИРЬ Сравнение проектирования на ЛИБЬ и УИБЬ приведено в статье Г. Варфоломеева [1]. В данной статье достаточно подробно описаны все аспекты перехода с ЛИБЬ на УИБЬ. Хочется добавить только следующее: в случае применения ModelSim в качестве инструмента моделирования при проведении симуляции появляется возможность читать данные из файла и эти данные выдавать на проверяемый проект в качестве входных воздействий. Очень полно и подробно о таких методах отладки и проверки проектов, написанных на УИБЬ, можно прочитать в учебнике [2]. Ссылки на подобные решения можно также найти, например, на сайтах www.asicdesign.ru и www.actel.ru. Результаты моделирования тоже могут быть записаны в файл. Допустим, что проект представляет собой многоканальный ИБЬС-контроллер. Число каналов — 30. Данные, которые необходимо пропустить через ИБЬС-контроллер, представляют собой, по меньшей мере, последовательность из 10 байт в каждом канале. Ядро контроллера при обработке каждого канала имеет не менее 10 состояний автомата. В итоге получаем: 30x10x10 = 3000 участков на диаграмме симуляции для проверяемого устройства. Разбираться с такой диаграммой (в случае применения ЛИБЬ и программного средства разработки МахРІш или Quartus с его встроенным симулятором) довольно затруднительно. В случае применения ModelSim для аналогичного проекта, выполненного на УИБЬ, мы получим, например, 30 файлов с выходными данными. Причем, в случае необходимости, можно записать в файл и состояния автомата на требуемых участках диаграммы или на всех участках диаграммы, а также состояния внутренних сигналов проекта и т. д. Результаты моделирования можно сравнить с математической моделью обработки данных и сделать вывод 0 работоспособности создаваемого проекта. Существуют программы-перекодировщики, которые автоматически переводят файлы из ЛИБЬ в УИБЬ или в УегДо^ Примером такой программы может служить Xport.exe. Этот перекодировщик успешно переводит файлы из одного формата в другой, но при перекодировке в выходном файле он не делает параметрических функций. То есть если в ЛИБЬ-файле проект выполнен с параметрами, которые позволяют его гибко использовать, то при перекодировке, в выходном УИБЬ-файле эти параметры ввести будет уже невозможно, и они будут жестко заданы в соответствии с теми значениями, которые были установлены в момент перекодировки. Именно поэтому ручная перекодировка в большинстве случаев будет более предпочтительной. Шпаргалка Для того чтобы было проще перейти от ЛИБЬ к УИБЬ, попробуем противопоставить известным и хорошо изученным в ЛИБЬ-выражениям аналогичные выражения УИБЬ. Тогда-то мы и придем к задаче, которую уже умеем решать. Данная статья не является учебным пособием, описывающим язык УИБЬ. Ее цель — облегчить переход к программированию на УИБЬ для тех разработчиков, которые уже имеют опыт работы на ЛИБЬ. Рассмотрим структуру ЛИБЬ-файла. Он может содержать следующие части: 1 2 3 4 5 6 7 8 9 Title Statement (optional). Include Statement (optional). Constant Statement (optional). Define Statement (optional). Parameters Statement (optional). Function Prototype Statement (optional). Options Statement (optional). Assert Statement (optional). Subdesign Section. Компоненты и технологии, № 1'2003 10. Variable Section (optional). 10.1. If Generate Statement (optional). 10.2. Node Declaration (optional). 10.3. Instance Declaration (optional). 10.4. Register Declaration (optional). 10.5. State Machine Declaration (optional). 10.6. Machine Alias Declaration (optional). 10.7. Assert Statement (optional). 11. Logic Section. 11.1. Defaults Statement (optional). В части файла, называемой Logic Section, находятся следующие выражения, которые могут следовать в файле в любом порядке и повторяться произвольное число раз: 1. Boolean Equation 2. Case Statement 3. For Generate Statement 4. If Generate Statement 5. If Then Statement 6. In-Line Logic Function Reference 7. Truth Table Statement 8. Assert Statement Далее попробуем заменять каждую часть AHDL-файла на соответствующее выражение для VHDL-файла. 1. Пропустим Title Statement, так как аналога в VHDL-файле нет и вместо этого воспользуемся символом комментария «--» и напишем: -- My project... и т. д. 2. Для VHDL-файла заголовочными являются файлы, описывающие, с какими библиотеками придется работать компилятору, а не описания библиотечных и «самодельных» компонентов проекта. Типичный вид части VHDL-файла, описывающего библиотеки: library ieee; use ieee.std_logic_1164.all; use ieee.std_logic_arith.all ; use ieee.std_logic_unsigned.aH ; use work.uart_signals.all ; USE std.standard.ALL; USE std.textio.All; Поэтому часть AHDL-файла, пункт 2, Include Statement, в которой дано описание библиотечных и «самодельных» компонентов для данного проекта, переносится в конструкцию PACKAGE, где компоненты описываются, например, так: COMPONENT DFFE PORT (d : IN STD_LOGIC; clk : IN STD_LOGIC; clrn: IN STD_LOGIC := '1'; prn : IN STD_LOGIC := '1'; ena: IN STD_LOGIC; q : OUT STD_LOGIC ); END COMPONENT; Собственно раздел PACKAGE может быть размещен в одном файле с entities. То же самое относится и к части 6 AHDL-файла — Function Prototype Statement. Вместо декларирования прототипа функции, принятого в AHDL, в VHDL объявляется компонент так, как указано выше. 3. Выделим часть 3 AHDL-файла, в которой описываются константы, применяемые для данного файла, — Constant Statement. В VHDL константы желательно размещать в конструкции PACKAGE. Выражение из AHDL-файла, например: CONSTANT DATA_WIDTH = Data_width; заменяем на выражение для VHDL, при этом необходимо учесть тип данных константы: constant constant_name : type := value; 4. Выделим часть 4 AHDL-файла, в которой описываются параметры, применяемые для данного файла, — Parameters Statement. В VHDL настраиваемые параметры Entity имеют название GENERIC и инициализируются при использовании компонента. Выражение из AHDL-файла, например: PARAMETERS ( Data_width = 32, Data_len = 8 ); заменяем на выражение для VHDL, при этом необходимо учесть тип данных параметров. Для VHDL параметры могут относиться ко всему файлу, тогда они связаны с ENTITY и выглядят, например, так: ENTITY entity_name IS GENERIC(... ; PORT( input name, input_name : IN STD_LOGIC; input vector name : IN STD_LOGIC_VECTOR ( high downto low); bidir_name, bidir_name : INOUT STD_LOGIC; output_name, output_name : OUT STD_LOGIC); END entity_name; И далее, добавим следующую часть кода, описывающего архитектуру: ARCHITECTURE a OF __entity_name IS SIGNAL___signal_name : STD_LOGIC; SIGNAL___signal_name : STD_LOGIC; BEGIN Process Statement Concurrent Procedure Call Concurrent Signal Assignment Conditional Signal Assignment Selected Signal Assignment Component Instantiation Statement Generate Statement END a; 8. Выделим часть 10 AHDL-файла, Variable Section, в которой описываются переменные для данного проекта, например: VARIABLE reset, Inp_shift_rg8 : node; phase_cnt_tx : lpm_counter with ( lpm_width = 4, lpm_direction = «UP» ) ; tx_process ) ; : machine with states ( idle_tx, trm_shift 5. Выделим часть 8 AHDL-файла, Assert Statement, в которой описываются сообщения, выдаваемые при компиляции файла. Выражение из AHDL-файла, например: ASSERT REPORT « CNT_WIDTH равен — %, DATAB_WIDTH равно — %» CNT_WIDTH, DATAB_WIDTH SEVERITY INFO; заменяем на выражение для VHDL, при этом необходимо учесть тип данных, которые проверяются в выражении ASSERT, например, вот так: ASSERT A_s = '1' REPORT «A_s /= '1', it is « & Bit2Strg_c(A_s) SEVERITY NOTE; При этом параметр после SEVERITY определяет уровень сообщения (NOTE, ERROR или другие), которое генерируется при выполнении команды ASSERT, что позволяет, настроив симулятор необходимым образом, либо выдать сообщение, указывающее пользователю, что при заданном условии команда ASSERT выполнилась, либо остановить симуляцию, если выполнение команды ASSERT происходит при возникновении ошибки. 6. Выделим часть 9 AHDL-файла, Subdesign Section, в которой описывается название проекта, например: и т. д. Поступаем следующим образом: А.То, что в AHDL-файле называлось NODE, теперь назовем SIGNAL и поместим либо в ARCHITECTURE (см. п. 7), либо вынесем в отдельный файл PACKAGE. Это позволит уменьшить объем основного файла проекта. Б. Библиотечные и «самодельные» компоненты в VHDL заменяются декларированием соответствующего компонента. Пример файла PACKAGE. library ieee; use ieee.std_logic_1164.all; use ieee.std_logic_arith.all ; use ieee.std_logic_unsigned.all ; PACKAGE uart_signals IS COMPONENT component_name PORT( input_name, input name bidir_name, bidir_name : IN STD_LOGIC; : INOUT STD_LOGIC; output_name, output_name END COMPONENT; : OUT STD_LOGIC); SIGNAL phase_cnt_tx_sclr, rx_process_idle : STD_LOGIC; END uart_signals; и заменим эту часть на соответствующее выражение в VHDL: Если компонент имеет параметры, тогда он декларируется так: COMPONENT __component_name GENERIC(__parameter_name : string :=_default_value; ___parameter_name : integer :=_default_value); PORT( __input_name: IN STD_LOGIC; .... ); END COMPONENT; В. Несколько сложнее обстоит дело с декларацией сигналов статических автоматов. е Компоненты и технологии, № 1'2003 Вот часть кода, описывающего работу статического автомата: type State_Typ is (RST, RedOn, YelOn, GrnOn); signal State_s : State_Typ; begin Explicit_Lbl : process begin wait until Clk'event and Clk = '1'; if Reset = '1' and State_s = GrnOn then Red <= '0'; Yellow <= '0'; Green <= '0'; State_s <= RST; elsif Reset = '0' and (State_s = RST or State_s = GrnOn) then Red <= '1'; Yellow <= '0'; Green <= '0'; State_s <= RedOn; elsif State_s =...... сти от выполнения или невыполнения условий_____expression_1 или__________expression_2. В VHDL выражение «IF — THEN» имеет несколько иное значение, чем в AHDL, поэтому аналогом данного выражения в VHDL будет являться выражение, называемое Concurrent_signal: __label: __signal <=____expression WHEN_boolean_expression ELSE ____expression WHEN_boolean_expression ELSE __expression; Если речь идет об обработке сигналов «внутри» выражения PROCESS: __process_label: PROCESS VARIABLE __variable_name : STD_LOGIC; BEGIN end if; end process Explicit_Lbl; end Explicit_a; Как видно из приведенного примера, необходимо указать тип данных для сигнала State_s и перечислить те состояния, которые он принимает. 9. В части AHDL-файла, называемой Logic Section, могут находиться выражения If Generate Statement. Данная часть AHDL-файла аналогична следующему выражению в VHDL: __generate_label: IF_expression GENERATE ___statement; END GENERATE; 10. В части AHDL-файла, называемой Logic Section, могут находиться булевы выражения типа: ___node_name =_node_name &__node_name; ___node_name =_node_name #__node_name; ___node_name =_node_name $__node_name; из AHDL заменяются в VHDL на следующие выражения для сигналов: WAIT UNTIL_______clk_signal = '1'; — Signal Assignment Statement — Variable Assignment Statement — Procedure Call Statement — If Statement — Case Statement — Loop Statement END PROCESS __process_label; то тогда возможно применение выражения «IF __expression THEN», такого же вида, что и в AHDL. Отличия будут только в выражении_______expression. В AHDL все пе- ременные NODE имеют один и тот же тип данных, который можно сопоставить с типом данных SYGNAL в VHDL. Назовем сигнал, который будет проверяться в выражении «IF __expression THEN», именем my_sygnal и проверим его на соответствие высокому уровню. Выражение в AHDL будет выглядеть так: IF my_sygnal = = 1 THEN Поскольку в AHDL имеется только один тип данных для сигналов, и при проверке сигнала ему автоматически приписывается значение True в том случае, если данный сигнал имеет высокий уровень, выражение может выглядеть и так: __sygnal_name <= __ sygnal_name AND __sygnal_name; sygnal_name <= sygnal_name OR sygnal_name; IF my_sygnal THEN __sygnal_name <= __sygnal_name XOR __sygnal_name; Для VHDL имеется несколько типов дан- а для переменных аналогичные выражения будут выглядеть так: ных, поэтому для данных типа SYGNAL выражение будет выглядеть так: __variable_name := __variable_name AND __variable_name; variable name := variable_name OR variable_name; IF my_sygnal = '1' THEN variable name := variable_name XOR variable name; а для данных типа BOOLEAN выражение 11. В части AHDL-файла, называемой Logic Section, могут находиться выражения «IF — THEN». Выражение из AHDL «IF — THEN» выглядит следующим образом: IF __expression_1 THEN __statement_1; ELSIF __expression_2 THEN _____________statement_2; ELSE _statement; END IF; В AHDL данное выражение заставляет выполняться выражения__________statement_1,______state- ment 2 или statement З только в зависимо- будет выглядеть так: IF my_bool THEN 12. В части AHDL-файла, называемой Logic Section, могут находиться выражения CASE. Выражение CASE в AHDL: CASE __expression IS WHEN______constant_value = __statement; __statement; WHEN OTHERS => __statement; __statement; END CASE; аналогично выражению «IF — THEN», для выражения CASE могут быть применены те же самые правила. Если это выражение не входит в какое-либо выражение PROCESS (см. объявление PROCESS выше), то такое выражение AHDL заменяется на выражение VHDL, называемое Selected signal: __label: WITH_____expression SELECT _signal <=_expression WHEN__constant_value, __expression WHEN__constant_value, __expression WHEN __constant_value, Если речь идет об обработке сигналов «внутри» выражения PROCESS, то тогда аналогично изложенному выше применяется функция «CASE____________expression IS» такого же вида, что и в AHDL. 13. В части AHDL-файла, называемой Logic Section, могут находиться выражения, называемые таблицами истинности. Выражение из AHDL, соответствующее таблице истинности, выглядит следующим образом: TABLE __node_name, __node_name => __node_name, __node_name; __input_value, __input_value => __output_value, __output _value; __input_value, __input_value => __output_value, __output _value; END TABLE; Данному выражению нет прямой аналогии в VHDL, поэтому необходимо воспользоваться выражениями типа Concurrent_signal, «IF — THEN» или CASE, в зависимости от того, входит ли таблица истинности в выражение PROCESS или нет. Заключение Языки AHDL и VHDL относятся к одной группе языков описания аппаратуры. Именно поэтому большую часть выражений языка AHDL можно перевести непосредственно в выражения языка VHDL. Однако полного соответствия между выражениями в этих двух языках, к сожалению, нет. Поэтому часть выражений языка AHDL, которым нет прямой аналогии в VHDL, придется перерабатывать в аналогичные по смыслу конструкции языка VHDL. Поскольку VHDL по отношению к AHDL является языком более высокого уровня, то необходимо также учитывать и дополнительные факторы, такие, как, например, разные типы данных, отличия в описании статических автоматов и др. Однако достаточно хотя бы один раз преодолеть все эти трудности, чтобы потом сказать: «от AHDL до VHDL всего один шаг». ИИ ]]></text>
</doc>
