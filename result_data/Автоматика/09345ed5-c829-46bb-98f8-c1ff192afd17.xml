<doc>
  <source auto="true" type="str" verify="true"><![CDATA[https://cyberleninka.ru/article/n/realizatsiya-algoritma-fiksatsii-vremeni-dlya-soblyudeniya-hronologii-pri-zapisi-setevyh-dannyh]]></source>
  <category auto="true" type="str" verify="true"><![CDATA[Автоматика]]></category>
  <author auto="true" type="list" verify="true">
    <item type="str"><![CDATA[Гуфан Константин Юрьевич]]></item>
    <item type="str"><![CDATA[Сергеев Дмитрий Васильевич]]></item>
  </author>
  <title auto="true" type="str" verify="true"><![CDATA[Реализация алгоритма фиксации времени для соблюдения хронологии при записи сетевых данных]]></title>
  <keywords auto="true" type="list" verify="true">
    <item type="str"><![CDATA[ХРОНОЛОГИЯ СОБЫТИЙ]]></item>
    <item type="str"><![CDATA[ТАЙМЕР]]></item>
    <item type="str"><![CDATA[МЕТКА ВРЕМЕНИ]]></item>
  </keywords>
  <annotation auto="true" type="str" verify="true"><![CDATA[Рассматривается решение задачи уникальной временной маркировки данных с целью соблюдения хронологии их поступления. Обозначены ограничения и проблемы использования в современных операционных системах таких объектов синхронизации, как таймеры, и приведена реализация алгоритма, позволяющего, с одной стороны, обойти существующие ограничения, с другой соблюсти хронологию событий. Рассмотрены требования, предъявляемые к процессу временной маркировки данных.]]></annotation>
  <text auto="true" type="str" verify="true"><![CDATA[Рассматривается решение задачи уникальной временной маркировки данных с целью соблюдения хронологии их поступления. Обозначены ограничения и проблемы использования в современных операционных системах таких объектов синхронизации, как таймеры, и приведена реализация алгоритма, позволяющего, с одной стороны, обойти существующие ограничения, с другой - соблюсти хронологию событий. Рассмотрены требования, предъявляемые к прогрессу временной маркировки данных. Хронология событий; таймер; метка времени. K.Y. Gufan, D.V. Sergeev IMPLEMENTATION OF THE TIME FIXATION ALGORITHM FOR COMPLIANCE WITH TIMELINE NETWORK CAPTURE The article discusses a unique solution to a temporary marking data to comply with the chronology of their income. Indicated limitations and challenges of a modern operating system synchronization objects such as timers and shows the implementation of the algorithm, which allows, on the one hand, to circumvent the existing limitations on the other - to observe the chronology of events. Reviewed the requirements for temporary marking process data. Chronology; timer; time mark. Для записи пакетов в "криминадистическом" режиме в первую очередь необходимо сохранить достоверность хронологии поступающих данных, чтобы иметь возможность реконструировать появление сетевых пакетов в определенные мо, . , -заны не с простыми уязвимостями одного исполнимого потока, а с возможностью , , , организован из нескольких параллельно выполняемых вычислительных потоков . Такие атаки, как правило, связаны с ошибками типа "состояние гонки" (от англ. "race condition"), которые являются ошибками проектирования многозадач-, , -полняются различные фрагменты кода. Такое название ошибка получила из-за сильной схожести потоков, пытающихся "отобрать" разделяемый ресурс с автомобильными гонками, где каждый стремится приехать первым и выиграть приз (ана- ). Каждому блоку данных, который получен по сети и передан сетевому приложению операционной системой, мы должны присвоить маркер времени, однозначным образом сопоставляющий время получения данных самим данным. Для , , взаимодействие с сетевой службой по протоколу POP3. Для сетевого приложения взаимодействие представлено двумя байтовыми потоками: один представляет собой отправляемые другой стороне данные, а второй - получаемые от другой стороны данные. Корректное представление хронологии приема/передачи данных в канале во POP3 ( ): Время 00:00:01 Сторона A: +OK Время 00:00:02 Сторона Б: USER login@mail.ru Время 00:00:03 Сторона A: +OK Password required for user ms.rs.s..smile10 Время 00:00:04 Сторона Б: PASS password Время 00:00:11 Сторона A: -ERR Password supplied for "login@mail.ru" is incorrect Время 00:00:12 Сторона A: +OK POP3 server at mail.ru signing off Если же не принимать во внимание временные метки, то те же данные будут выглядеть следующим образом (некорректное представление): Время 00:00:00 Сторона A: +OK Время 00:00:00 Сторона A: +OK Password required for user ms.rs.s..smile10 Время 00:00:00 Сторона A: -ERR Password supplied for "login@mail.ru" is incorrect Время 00:00:00 Сторона A: +OK POP3 server at mail.ru signing off Время 00:00:00 Сторона Б: USER login@mail.ru Время 00:00:00 Сторона Б: PASS password Если не делать быструю маркировку как можно более мелких блоков данных, то может возникнуть ситуация, при которой будет не ясна очередность информационных блоков "запрос-ответ", а, следовательно, будет непонятен замысел возможной атаки и невозможно будет ее реконструировать. Например, если одна из сторон не использует свойство асинхронности во время приема данных, то временная метка может быть присвоена укрупненному блоку данных (из-за того, что пришедшие небольшими порциями данные накапливались в системном буфере). В , , , -щим образом (некорректное представление): Время 00:00:01 Сторона A: +OK Время 00:00:02 Сторона Б: USER login@mail.ru Время 00:00:03 Сторона A: +OK Password required for user ms.rs.s..smile10 Время 00:00:04 Сторона A: -ERR Password supplied for "login@mail.ru" is incorrect Время 00:00:05 Сторона Б: PASS password Время 00:00:06 Сторона A: +OK POP3 server at mail.ru signing off Следует также отметить, что обработка сетевых пакетов и их доставка при, , . , , на высокоточный таймер, который позволяет измерять временные промежутки с . В операционных системах Microsoft Windows и FreeBSD существуют тайме, -формации о прошедшем времени. В ОС Microsoft Windows имеется три типа программных таймеров -обычные, мультимедиа и ожидаемые [1]. Обычные таймеры используются наиболее часто в пользовательских приложениях, а их использование подразумевает отправку оконных сообщений типа WM_TIMER. Обычные таймеры имеют 20 , потоков и очереди оконных сообщений, скоростью работы диспетчера процессов и частотой его вызова (по сути, это период времени вызова аппаратного прерывания, на англ. "quant"), количеством времени, выделяемым для работы потока (англ. "time slice"). Мультимедиа-таймеры предназначены для использования в мультимедиаприложениях и их разрешение возможно регулировать программным образом (например, с помощью функции timeBeginPeriod). Системная функция timeBeginPe-riod 1 миллисекунды. На самом деле, таймеры обрабатываются диспетчером потоков, , , управление. Понижая квант времени до 1 миллисекунды, можно позволить диспетчеру более точно вызывать события таймера. Для доступа к информации мультимедиа таймеров можно использовать системные функции QueryPerformanceFrequency и QueryPerformanceCounter. Ожидаемые таймеры (waitahle timers) - это объекты ядра ОС, которые самостоятельно переходят в свободное состояние в определенное время или через регулярные промежутки времени. Чтобы создать ожидаемый таймер, достаточно вызвать функцию CreateWaitableTimer. Ожидаемые таймеры всегда создаются в . , , SetWaitableTimer. В ОС FreeBSD используется функция clock_gettime(), позволяющая получить значение высокоточного таймера [2] (если этот функционал поддерживается каким-либо драйвером ядра). Ниже приведен пример использования данной функции (анштога мультимедиа таймера в ОС Microsoft Windows). #include <sys/time.h> #include <stdio.h> #include <time.h> #define COUNT 1000000 int main() { struct timespec ts_start, ts_stop, ts_read; double time; int i; clock_gettime(CLOCK_MONOTONIC, &ts_start); for(i = 0; i < COUNT; i++) { clock_gettime(CLOCK_MONOTONIC, &ts_read); } clock_gettime(CLOCK_MONOTONIC, &ts_stop); time = (ts_stop.tv_sec - ts_start.tv_sec) + (ts_stop.tv_nsec - ts_start.tv_nsec) * 1E-9; printf("%.0f\n", COUNT / time); } Тем не менее, следует учесть, что хотя временные интервалы таймеров задаются в относительно мелких единицах (миллисекундах или даже меньше), на самом деле практически невозможно измерить время меньшее, чем 10-20 миллисекунд. Для гарантированного отсчета таких маленьких временных интервалов необходимо , процессов операционной системы. Кроме того, практические испытания вскрыли два свойства высокоточных таймеров, которые прямым образом влияют на возможность их использования. -, запись администратора операционной системы. Использование сетевой програм, , . - , - - граммной частей эмуляции виртуальной среды разрешение высокоточных таймеров "гаавает" в границах от 10 до 100 и более миллисекунд, при этом изменяясь динамически. Таким образом, можно считать использование высокоточных таймеров не , . , , , -жащий минимальное количество кода, достаточного для решения задачи уникальной временной маркировки данных. Дело в том, что для маркировки сетевых данных важны два свойства: ♦ строго монотонное возрастание функции маркировки; ♦ неточное (плавающее в допустимых пределах) соответствие функции маркировки реальному времени. Строго монотонное возрастание необходимо для сохранения уникальности метки. В этом случае мы всегда сможем указать не только момент времени, приблизительно в котором произошло событие, но и указать очередность поступаю- . сопоставить используемую временную шкалу с обычным течением времени. В противном случае (например, если вместо временного маркера используется ), , , -рами при воспроизведении атаки на программное обеспечение с ошибками типа "состояние гонки". , , системные функции доступа к временным показателям, для вызова которых не нужны повышенные привилегии. Разработанный с этой целью интерфейсный класс atomic_time имеет специальную функцию peek_time, возвращающую значения, представляющие собой "аналог" миллисекунд. Для ее вычисления используется количество секунд, прошедших с 0 часов 0 минут 0 секунд 1 января 1970 года , 1000, 0 999. #include <boost/thread/mutex.hpp> #include <time.h> #define CFG_INT_TIME_GRANULARITY 1000 class atomic_time { long delik_counter; time_t last_time; time_t current_time; boost:: mutex timelock; public: atomic_time() { time(&last_time); // стартуем counter = 0; } time_t peek_time() { boost:: mutex: :scoped_lock lock(timelock); time(&current_time); if (current_time == last_time) { counter++; } else { counter = 0; last_time = current_time; } return last_time*CFG_INT_TIME_GRANULARITY + counter; } void check_me() { for (int i = 0; i < 1000; i++) std::cout << peek_time() << std::endl; } }; Такой подход дает нам возможность хранить в одном целом числе реальные временные характеристики маркера, а кроме того, обеспечивает (за счет прибавле- ) peek_time(). CFG_INT_TIME_GRANULARITY, сЬеск_ше() на серверной станции без виртуализации. Значение верхнего порога для данного параметра приближается к тактовой частоте процессора, с использованием которого исполняется программа. На практике, особенно в виртуальных , . На рис. 1 показано, каким образом а1ошю_Ише: :реек_йше() сопоставляет ( ). Хронология гл “ |з| 4 событий II _____II _________11!_____________ 123456789 1 2 3456789 il it .......................... Рис. 1. Сопоставление разработанного алгоритма учета времени с мультимедиа-ташлером , , устанавливать на любой блок сетевых данных уникальный временной маркер, по значению которого возможно определить реальное время, когда эти сетевые данные поступили на обработку. ]]></text>
</doc>
