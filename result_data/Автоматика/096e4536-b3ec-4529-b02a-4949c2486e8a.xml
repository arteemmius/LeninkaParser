<doc>
  <source auto="true" type="str" verify="true"><![CDATA[https://cyberleninka.ru/article/n/n-model-dannyh]]></source>
  <category auto="true" type="str" verify="true"><![CDATA[Автоматика]]></category>
  <author auto="true" type="list" verify="true">
    <item type="str"><![CDATA[Ольховик Олег Владимирович]]></item>
    <item type="str"><![CDATA[Белых Александр Валерьевич]]></item>
  </author>
  <title auto="true" type="str" verify="true"><![CDATA[N-модель данных]]></title>
  <keywords auto="true" type="list" verify="true">
    <item type="str"><![CDATA[МОДЕЛЬ ДАННЫХ]]></item>
    <item type="str"><![CDATA[ОБЪЕКТ]]></item>
    <item type="str"><![CDATA[АТРИБУТ]]></item>
    <item type="str"><![CDATA[ЭКЗЕМПЛЯР]]></item>
    <item type="str"><![CDATA[КЛАСС]]></item>
    <item type="str"><![CDATA[КАТЕГОРИЯ]]></item>
    <item type="str"><![CDATA[БАЗА ДАННЫХ]]></item>
    <item type="str"><![CDATA[ЖИЗНЕННЫЙ ЦИКЛ ИНФОРМАЦИОННЫХ СИСТЕМ]]></item>
  </keywords>
  <annotation auto="true" type="str" verify="true"><![CDATA[Представленная в данной работе N-модель данных является теоретической базой для создания инструмента, позволяющего сократить затраты на всех этапах жизненного цикла программного обеспечения информационных систем. Вводятся базовые понятия N-модели данных. Затем рассматриваются операции над атрибутами и отношение наследования, после чего представляется понятие базы данных.]]></annotation>
  <text auto="true" type="str" verify="true"><![CDATA[N- для создания инструмента, позволяющего сократить затраты на всех этапах жизненного цикла программного обеспечения информационных систем. Вводятся базовые понятия N-. -дования, после чего представляется понятие базы данных. Модель данных; объект; атрибут; экземпляр; класс; категория; база данных; жизненный цикл информационных систем. O.V. Olhovik, A.V. Belykh N-DATA MODEL The N-data model presented in this paper is a theoretical basis for developing of the instrument allowing to reduce expenses at all stages of life cycle of the software of information systems. Basic concepts of N-data model are entered. Then operations with attribute and inheritance relationship are considered whereupon the concept of a database is represented. Data model; object; attribute; instance; class; category; data base; life cycle of the information systems. Введение. Данная работа посвящена пробл еме снижения трудоемкости поддержания жизненного цикла программного обеспечения информационных систем (ПО ИС). Решая эту проблему, мы исходили из необходимости создания инструмента, позволяющего сократить затраты на всех этапах жизненного цикла, вне зависимости от принятой модели. Подобные инструменты, поддерживающие общий подход и описанный в [1], уже хорошо известны. Они акцентируются на различных аспектах процесса разработки ПО и их сравнительный анализ произведен, например, в работе [2]. Наиболее серьезный набор инструментов на данный момент представлен в линейке продуктов IBM Rational. Среди них IBM Rational Software Architect и IBM Webshere Application Server, которые позволяют из результатов проектирования автоматически генерировать программный код [3]. Однако, по , , , . Мы считаем важным, чтобы такой инструмент основывался на теоретической , . предлагается представленная ниже N-модель данных. Объекты. Имеется счетное множество образов E={ehe2,...,en}. Объектное пространство X={xI,x2,...,xm} состоит из объектов, каждый из которых представляет собой некоторое множество образов: X cB(E). Отношение нестрогого включения с образует на множестве объектов решетку, верхняя грань которой - абстрактный объект x0=E, трактуемый как все, что угодно, а нижняя - пустое множество x^ (ничего). Можно сказать, что отношение с образует понятийную иерархию объектов. Экстенсионалом объекта будем называть множество объектов, каждый из которых является неким его подмножеством. Иначе говоря, экстенсионал объекта , . Exti xi ( ): Ext, = {x / xcx}. (1) Интенсионалом объекта будем называть множество объектов, для которых он : Inf, = {x / xjCx}. (2) Свойства объектов. Существует требование к различимости образов, а это , , . , , , -ляются атрибутами. Атрибут - это функция, определенная на множестве объектов. Аналитические свойства объектов определяются через свойства образов, которые являются функциями f eF\ F'cE^B(P). Собственно свойства объектов представлены множеством функций feF, FcX^B(P) таких, что f(x) = Qf'(e), W {eo,e1,.,er}=x, neN. (3) i=0 Элемент feF называется атрибутивной функцией или атрибутом. P - . - лим в P значение Я, которое будем интерпретировать как неопределенность (null). Поскольку множество образов счетно и, следовательно, счетно множество объек- , - ми. Это означает, что элементы P могут интерпретироваться еще и как идентифи-. Как видно из (3), значение атрибута на объекте - это некое непустое множе-, p e P. x Я, x, - . Введем отношение терминальности E. Объект называется терминальным на атрибуте, если все его образы имеют одинаковое значение функции f, соответствующей данному атрибуту, и, кроме того, атрибут информативен на объекте: f Ex & f(x)i=- Я ^e ex f (e) =f(x). (4) Также, для удобства, будем говорить, что атрибут терминален на объекте, если объект терминален на этом атрибуте. Из определений экстенсионала (1) и терминальности (4) следует, что все объекты в экстенсионале терминального на каком-либо атрибуте объекта имеют такое же значение этого атрибута: f Exi :=> VxeExtj f(x) =f(x). (5) Если значение атрибута на каждом терминальном для него объекте х со держит строго один элемент, то такой атрибут называется ординарным. Если значение атрибута на каждом терминальном объекте может содержать несколько элементов, то он называется множественным. Можно сказать, что на каждом объекте он принимает одномерный массив значений. Множественные и ординарные атрибуты могут интерпретироваться как ссылки на другие объекты. Из (3) и (1) следует важное утверждение: значение атрибута любого объекта состоит из значений этого атрибута на объектах, входящих в его экстенсионал: 1=П /(х) = у/(х ), где {хах1,...,Хп}=Ехи, пеЫ. (6) 1=0 1 , - рибутов: если атрибут определен на терминальном объекте значением $сБ(Р), то все объекты в его экстенсионале имеют значение этого атрибута равное 5. Если же атрибут на нетерминальном объекте имеет значение 5, то можно только сказать, что каждый объект в его экстенсионале имеет значение этого атрибута, равное некоторому подмножеству 5. Плюс к этому можно сказать, что объединение этих значений дает 5. Теперь сформулируем утверждение о различимости объектов по их свойствам. Если объекты различны, то существует, хотя бы один, информативный атрибут, значения которого на этих объектах различны. Обратное также верно: х ^ <^3/е¥, что /(х)Ф/(х), /(х)ФЯ, /(х) ФЯ (7) Очевидно, что элементы Р в значениях одного атрибута должны интерпретироваться одинаково, т.е. относиться к одному типу данных. Еще одной важной функцией является Ю: Х^Ы, которая индексирует множество объектов натуральными числами, или, иначе говоря, идентифицирует объекты. Обратную ей функцию, определяющую объект по его идентификатору, обозначим ОЬ): Ы^Х. Причем, ОЬ1(Ю(х))=х, Ю(ОЬ1(п))=п. Исходные атрибуты. Поскольку атрибуты - это функции, есть возможность задавать их различными способами. Основной способ - фактическое задание зна-. , , -но задается его значение. Это похоже на то, как определяются значения атрибутов в реляционных или объектно-ориентированных базах данных. Поэтому атрибуты, значения которых задаются фактически, будем называть исходными. Задание значения исходного атрибута на объекте означает, что для всех объектов в его экстенсионале значение этого атрибута будет таким же. Таким образом, объекты, на которых задаются значения исходных атрибутов, терминальны относительно этих атрибутов. ( ). Такие атрибуты будем называть расчетными. Экземпляры и классы. Как уже говорилось выше, в предметной области объекты из X могут соответствовать конкретным вещам, явлениям, процессам, либо их состояниям или множествам, либо абстрактным понятиям. Соответственно множество X можно разбить на ч етыре подмножества: объекты -сущности, объекты-состояния, абстрактные объекты и конце пт-объекты. В решетке объектов, в общем случае, концепты находятся на самом верху, а объекты-состояния - внизу. Обозначим через Д множество исходных атрибутов, на которых объект х1 : Д = {// / Ех }. (8) Утверждение. Если объект х1 является подмножеством объекта х, то множество Д является подмножеством Д. Иначе говоря, при возрастании мощности объекта, множество атрибутов, на которых он терминален, не увеличивается: х-сх, => ДсД. (9) хг , Дг - то. Множество экземпляров обозначим через Ех: Ех = {хг / Д Ф0}. (10) хг - , не терминален: Д =0. - - , , Д содержат одинако вые атрибуты. Множество классов обозначим символом С: г=п С = {с /с = 0х, % Д зД}, (11) г=1 Д - . , Д с , хг - Д. сг Ехг - . Дг , сг . , их экстенсионалов и множеств терминальных на них атрибутов в дальнейшем будем обозначать натуральными числами. . значения хотя бы одного исходного атрибута, терминального на них: х1,х2еЕхг =^> З/еЗ, что/(х1^Ф/(х2). (12) Утверждение. Различные экземпляры одного класса не пересекаются: х1,х2еЕхг => х1пх2=0. (13) Утверждение. Класс с1 является подмножеством класса с, если множество терминальных на экземплярах класса с) функций Д является собственным под- Дг сг: ДсЗг=> Сг СС). (14) Утверждение. Если множество атрибутов Д, терминальных на экземплярах класса с, является собственным подмножеством множества атрибутов Д класса с, сг с,: 3)с3г => \6с1еЕхг Зх2еЕх), что х1сх2, и —/Зх^еЕх,, что х1сх3. (15) Теперь введем отношения наследования <уи прямого наследования Ш Будем , сг с, , с, - сг: 3jc3i &с, ю Cj. (16) Исходя из свойств отношения строгого включения, наследование является , , . , , -. : Ci - следует от класса с, то он наследует от с, и не существует такого класса ck, который наследует от с, и от которого наследует с,: с, Ш с, & с, ю Cj, —Зск, что с, ю ck и ck ю Cj. (17) Разграничим случаи простого и кратного наследования. При простом наследовании всякий класс может прямо наследовать только от одного класса: с, Ш Cj =^> —3ck, что с, Ш ck. (18) При кратном наследовании класс может прямо наследовать от любого числа классов. Ограничение (17) не действует. Теперь введем определение отношения наследования на множестве экземпляров. Экземпляр x1 класса ct наследует от экземпляра x2 класса с, тогда и только тогда, когда ct наследует от с, и x1 является подмножеством x2: с, юс'j, x1eExi, x2eExj, x1cx2 &x1ax2. (19) Прямое наследование на экземплярах определяется так: с,Шс,, x1eExi, x2eExj, x1cx2 &x1ax2. (20) Операции над атрибутами. Множество допустимых операций над атрибутами обладает двумя базовыми свойствами. Во-первых, все операции замкнуты относительно понятия атрибут, т.е. и опе-, . - , , задан. Для экземпляров других классов его значение определяется по (5) и (6). То , . Произвольную унарную операцию обозначим символом / Результат операции определяется выражением: h(x)= /f(x), h(x)= {qeP/ q=/(p), pef(x)}. В качестве унарных операций могут выступать одноместные функции, такие как sin, cos, lg, sqrt или любые другие функции определяемые пользователем. Произвольную бинарную операцию обозначим символом ®. Результат операции определяется выражением: h(x)=f(x)&g(x), h(x) = {qeP/q=p0s, pef(x), seg(x)}. Примерами бинарной операции могут быть арифметические операции +, -, *, /, div, mod или конкатенация || или же двухместная UDF. Результаты операций объединения, пересечения и взятия разности определяются как у соответствующих теоретико-множественных операций, за исключением , : h(x)=f(x)ug(x), h(x) = {qeP/qef(x) V qeg(x)}, h(x)=f(x)ng(x), h(x) = {qeP/ qef(x) л qeg(x)}, h(x)=f(x) /g(x), h(x) = {qeP/qef(x) л q£g(x)}. Агрегатные операции характеризуются тем, что производятся над всеми элементами значения атрибута и, в независимости от их числа, результат будет ординарным. К числу таких операций относятся: подсчет количества (Count) или суммы (Sum) значений, а также определение среднего (Avg), максимального (Max) или минимального (Min) значения: h(x)=Count(f(x)) =\ f(x)\, i=n h(x)=Sum( f(x)) = ^q, где {qhq2,...,qn}= f(x), i=1 1 h(x)=Avg(f(x)) = Sum(f(x)) /Count(f(x)), h(x)=Max( f(x)) = sup f(x), h(x)=Min( f(x)) = inf f(x). Композиция - это специальная операция, которая позволяет получить значения атрибута по ссылке. Обозначим ее символом «.». Аргументы композиции -атрибут, который содержит идентификаторы объектов, (ссылка) и имя атрибута, информативного на этих объектах: i=n h(x)=f(x).g, h(x) = у g(x), где xl=ObJ(ql), qef(x). i=1 , , , -няется через операцию соединения. Другая специальная операция - инволюция. В инволюции два аргумента: первый аргумент - некоторое множество объектов, а второй - атрибут-ссылка: h(x)=lnv(X', f), h(x) = {ID(x) / xteX' ID(x)ef(x), feF}. Здесь множество X " имеет смысл задавать именем концепт-объекта. Итак, множество операций замкнуто на атрибутах, и результат операции рассчитывается только для терминальных объектов. Категории. Под категорией понимается концепт-объект, представляющий собой объединение экземпляров класса, на которых истинно некоторое логическое условие L. Простое условие будем обозначать символом H, возможно, с индексом. Оно имеет вид f1 comp-op f2, где f1 и f2 - атрибуты (в т.ч. f2 может быть константой), a comp-op - операция сравнения (=, !=, >, <, <=, >=). Простые условия могут быть соединены логическими связками AND, OR и NOT, образуя произвольное условие L. ti, - ходимо указать класс ck, экземпляры которого она выделяет, и условие, которое должно быть истинным на этих экземплярах. Если условие простое, то категория : cti[ck, L=H= fcomp-op f2] J=m ' 4, cti= U Xj , Vxj£Exk, Vxj fI(Xj) comp-opf2(Xj)=true. j=1 Множество экземпляров класса, входящих в произвольную категорию си бу-Ехсг . Если условие содержит логические связки, то имеются следующие соответст- : си[ск, Ь1 ОЯ Ь2]=а[ск, Ь1]и^2[ск, Ь2], си[ск, Ь1ЛЫБ Ь2]=&1[ск, Ь1]п&2[ск, Ь2], сфк, ЫОТ Ь^=ск / а[сь ь^. Cat. Теперь введем интерпретацию отношения наследования для категорий. Категория ct{ наследует от другой категории ctj тогда и только тогда, когда условие первой категории включает в себя условие второй категории: L, = L AND L' & cti o cj (21) где L' - непустое логи чес кое условие, определенное в соответствии с вышеописан-. , -, . Очевидно, что если категория ct, наследует от категории ct, то является ее : cti Юctj =^> cticctj. (22) Категория cti прямо наследует от другой категории ct, если она наследует от : cti Шctj & ct, coctj, —3ck, что ct, coctk и ctk octj. (23) С каждым классом можно связать категорию, условие которой истинно на всех экземплярах этого класса. Иначе можно сказать, что условие, определяющую данную категорию, пусто. Такую категорию класса будем обозначать символом ct' , . , cti - ck , ct'k: cti Шск & cti ffict'k. (24) На категории может быть определено некоторое множество расчетных атрибутов 3'. Атрибут, определенный на категории, считается терминальным на всех , . - ( ), . , , или других категорий этого класса. Под перекрытием атрибута понимается то, что значение этого атрибута в экземплярах некоторых категорий может быть получено , , . перекрытии выполняются следующие правила: Q1. Допустим, что на некотором концепт-объекте x определен атрибут f Ат-f , x же именем, что и в x, но с другой формулой. Q2. При перекрытии тип данных атрибута должен сохраняться. Q3. В экземплярах категории, где перекрыт атрибут, его значения рассчитываются по формуле, определенной в этой категории. Причем перекрываться может даже исходный атрибут. . - , , , зависит от природы объектов. Для классов оно обусловлено отношением между (16), -(21), - -(19). , . - первых, оно везде обладает свойствами транзитивности, иррефлексивности и антисимметричности, т.е. задает полный порядок. Во-вторых, для объектов любой природы можно сказать, что если один объект наследует от другого, то является его подмножеством (14), (19), (22). В-третьих, наследование везде одинаково может « ». Как видно из (17), (20), (23) и (24), прямое наследование отличается нетран-зитивностью. Вследствие чего оно позволяет практически задавать порядок наследования между объектами в базе данных. Понятие базы данных. Определим схему базы данных (БД), как n-ку Sh=<C, Cat, Ш, F, Type, D>, где C - множество классов; Cat - множество категорий; Ш - отношение прямого наследования; F - множество информативных ат; Type - ; - . Каждый класс определяется тройкой <Name, 3, 3'>, где Namee D - имя класса в схеме; 3 - множество исходных атрибутов, определенных на классе; 3' - множество расчетных атрибутов, определенных на классе (3, 3'cF). Каждая категория определяется тройкой <Name, L, 3'>, где Namee D -имя ; L - ; 3' - , определенных на категории (3'cF). Имя каждого класса или категории должно быть уникальным в множестве классов и категорий. Ш , - . В множество F входят только те атрибуты, которые информативны хотя бы на одном классе или категории. Атрибуты классов и категорий определяются по правилам определения атрибутов, а так же по правилам перекрытия Q1 и Q2. Исходный атрибут задается име-Type. - , задаются своим именем и именем класса или категории, на экземпляры которых ссылаются. Расчетный атрибут задается именем и формулой. Причем, в формулах допускаются только операции, определенные в части «Операции над атрибутами» . Базу данных определим как двойку <Sh, Ex>, где Sh - схема БД, a Ex - множество экземпляров классов из этой схемы. Единственной допустимой структурой данных является класс (11). Ограничения целостности в БД определяются выражениями (12), (15) и пра- . ID, , выполняет роль суррогатного ключа. , , класса. Для исходных атрибутов значения определяются непосредственно на каж-. формулам с учетом правила перекрытия Q3. Значения атрибутов не определенных на классе, но информативных на нем, вычисляются по (5) или (6) в зависимости от места их определения. . , по данной работе, надеются на сотрудничество в решении еще неразработанных вопросов и будут благодарны за конструктивную критику. ]]></text>
</doc>
