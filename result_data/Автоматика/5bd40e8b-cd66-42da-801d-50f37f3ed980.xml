<doc>
  <source auto="true" type="str" verify="true"><![CDATA[https://cyberleninka.ru/article/n/problema-odnomernoy-upakovki-elementov]]></source>
  <category auto="true" type="str" verify="true"><![CDATA[Автоматика]]></category>
  <author auto="true" type="list" verify="true">
    <item type="str"><![CDATA[Курейчик В.М.]]></item>
    <item type="str"><![CDATA[Потарусов Р.В.]]></item>
  </author>
  <title auto="true" type="str" verify="true"><![CDATA[Проблема одномерной упаковки элементов]]></title>
  <keywords auto="true" type="list" verify="true"/>
  <annotation auto="true" type="str" verify="true"><![CDATA[]]></annotation>
  <text auto="true" type="str" verify="true"><![CDATA[Введение. В последние годы наблюдается рост объема производства сверхбольших интегральных схем (СБИС). Использование СБИС оказывается настолько эффективным, что даже большие, в сравнении с производственными затратами, вложения в научно-исследовательские работы, направленные на совершенствова-, . схем, причем одновременно растут их надежность и экономичность [1]. Если задача проектирования топологии разделена на подзадачи, и они рассматриваются абстрактно и с приближениями, то их можно анализировать как классические комби. возможное количество рядов является классической задачей комбинаторной оптимизации, называемой задачей одномерной упаковки (One-Dimensional Bin Packing Problem) [2]. В этой задаче минимизируется количество занятых блоками рядов, а ее допустимые решения представляют собой все возможные перестановки блоков . Задача одномерной упаковки блоков моделирует различные практические задачи в области САПР, например: форматирование таблиц, постраничное разбиение, размещение файлов [3]. , свести одну из них к классической задаче одномерной упаковки, вводятся целевые функции и ограничивающие условия, которые не могут быть строго определены, и производится формализация задачи для ЭВМ. Но даже и при упрощении целевых функций и ограничивающих условий, а также при выполнении некоторых частных , , интеграции схемы растет в экспоненциальной зависимости [2, 4]. Это справедливо и в отношении задачи одномерной упаковки. Поэтому целесообразным для ее решения является использование эвристических алгоритмов, которые, при отсутствии гарантии нахождения оптимального решения, позволяют получить приближенное в течение некоторого реального интервала времени. Недостатки эвристических алгоритмов решения задачи одномерной упаковки сводятся в общем к низкому качеству решения, либо затрачивают на его поиск избыточное количество [3]. 1. Постановка задачи. Задача одномерной упаковки может быть описана, используя терминологию задачи о рюкзаке [5]. Даны n элементов (товара, изделий) и n блоков (рюкзаков, ящиков или бинов (bin)) с Wj - весом элемента j, с - грузо-( ) . Назначим каждый элемент одному блоку так, чтобы общий вес элементов в c, . Математическая формулировка проблемы следующая [5]: * Работа выполнена при поддержке РФФИ (грант №06-01-00272) П минимизировать (i) i=i n при условии, что X WJXV - °Уг , 1 eN = {1, п} (2) i=1 n Z Xv = 1,j eN, (3) i=1 yi = 0 или 1, I e N, Xj = 0 или 1, I e N, j e N, (4) (5) где у{ = 1, если накопитель I использован, в противном случае у{ = 0; Ху = 1, если элемент] назначен бину I, в противном случае х:у = 0. Будем полагать, что wу - положительные целые. Следовательно, чтобы сохранить универсальность, предположим, что Если предположение (6) нарушается, то с может быть заменено на . Если элемент нарушает предположение (7), то упаковка заведомо невыполнима. Будем полагать, что в любом возможном решении используются наименьшие пронумерованные накопители, т.е. yi >yi+1 для i = 1, ..., п-1. 2. Алгоритм одномерной упаковки Next-Fit. Первый рассматриваемый приближенный подход к решению задачи бинарной упаковки - это Next-Fit (NF) алгоритм [5, 6]. Первый элемент назначается блоку 1. Элементы 2, ...,п рассматриваются в порядке возрастания их индексов: каждый элемент назначается текущему блоку, если он вмещается туда; в противном случае он назначается новому блоку, который становится текущим. Временная сложность алгоритма O(n). Доказано, что для любого экземпляра I задачи BPP значение решения NF(I) может быть получено при использовании алгоритма, который удовлетворяет ограничению где 2(!) есть оптимальное значение решения [2,7]. , , -ние ~Ы¥(1)/2(1) сколь угодно близко к 2, т.е. наихудший коэффициент производительности ЫЕ это г(ЫГ)=2. Заметим, что для проблемы минимизации наихудший случай коэффициента производительности эвристического алгоритма А описан как наименьшее вещественное число г(А), такое что где A(I) - значение решения, полученное при использовании алгоритма A. , , , так, что w1 > w2 > ... >wn, где Wj - размер элемента j, и применим NF. Получающийся алгоритм временной сложности O(n-log п) называется Next-Fit Decreasing 3. Алгоритм одномерной упаковки First-Fit. Алгоритм First-Fit (FF), рассматривает элементы в соответствии с возрастанием их индексов и назначает каждый элемент низшему индексированному уже инициализированному блоку, куда он может быть помещен без переполнения. Только когда текущий элемент не мо- с - это положительное целое, Wj — с для j e N. (6) (7) NF(I) <2*z(I), (8) I, (NFD). жет быть помещен в какой-либо уже инициализированный блок, то вводится новый блок. Доказано [2,5,8], что 17 FF (I) =— z( I) + 2 (9) 10 для всех случаев I задачи BPP, и что имеются случаи I со сколь угодно большим z(I), для которых 17 FF (I )>10 z(I) - 8' (10) (9), для других алгоритмов, наихудший коэффициент производительности не может давать полной информации о наихудшем поведении алгоритма. Вместо него, для BPP - изводительности. Для эвристического алгоритма A он определен как минимальное вещественное число r™(A), та кое, что для некоторых положительных целых k A(I) ^ . ) ----- < r (A) для всех случаев I, удовлетворяющих z(I) >k. z(I) ~ 17 Тогда из (9) - (10) следует, что r (FF) = —. , , , так, что w1 >w2 >... >w„, где Wj - размер элемента j, и применим FF. Получающийся алгоритм временной сложности O(n-log n) называется First-Fit Decreasing (FFD). 4. Алгоритм одномерной упаковки Best-Fit. Следующи й алгоритм, Best-Fit (BF) получается из FF назначением текущего элемента допустимому блоку (если ), , поиск такого блока начинается с первого инициализированного блока (как в алгоритме FF). Johnson, Demers, Ullman, Garey и Graham [2] доказали, что BF удовле- , FF ((9)-(10)), - ~ 17 тельно, r (FF) = —. 10 Временная сложность обоих алгоритмов FF и BF O(n-log n). Она может быть 2-3 , . (2-3 - , - ром: а) каждый нелистовой узел имеем 2 или 3 сына; б) каждый путь из корня к l; ) по его значению, его обновления, или вставки нового листа в O(l) время. В этом случае каждая итерация FF или BF требует O(log n) времени, так как число листьев ограничено числом n [9-11]. , , , , w1 > w2 > . > wn, wj - j, BF. - щийся алгоритм временной сложности O(n log n) называется Best-Fit Decreasing (BFD). 5. Результаты экспериментов. Алгоритмы были реализованы на C++ и протестированы на ЭВМ с процессором AMD Athlon 600 МГ ц и 128 Мб оперативной . NFD : 1: wj - пазоне [1,100]; Класс 2: wj в диапазоне [20,100]; Класс 3: wj в диапазоне [50,100]. В таблице n - число элементов для упаковки, T - время выполнения алгоритма, ошибка упаковки Error рассчитывалась следующим образом: ^ (с - ItemSum) Error = -------с------* 100%, NPB где с - вместимость блока, ItemSum - суммарный вес упакованных в него элемен- , NPB - , . Таблица Результаты тестирования алгоритма Next-Fit Decreasing Next-Fit Dec Класс n Error, % T, мсек 1[1,100] 500 21.9912 1 1000 21.8452 2 2000 21.6891 6 5000 21.5413 18 10000 21.7912 25 2[20,100] 500 22.1891 1 1000 22.9908 2 2000 22.6507 5 5000 22.4015 19 10000 22.3253 26 3[50,100] 500 24.0730 1 1000 23.7568 2 2000 24.5603 6 5000 24.2286 17 10000 24.2351 27 Ошибка представляется как средний арифметический процент образовавшихся невостребованных пустот в инициализированных блоках после упаковки. , , , -ченных для упаковки, при возрастании числа элементов значение ошибки сначала , -тании времени выполнения упаковки. На втором классе элементов при увеличении их числа и времени, требующегося для упаковки всех элементов, значение ошибки сначала незначительно увеличивается, затем незначительно уменьшается. На третьем классе элементов с ростом количества упаковываемых элементов и времени работы алгоритма упаковки значение ошибки сначала уменьшается незначи-, . На рис.1-3: «Вместимость» - вместимость блока с; «Блоков для упаковки» -, , -ветствующей эвристики; «Время» - время работы алгоритма; «Ошибка» - ошибка, описанная выше; «Заполнено» - процент укомплектованности блоков. На рис.1-3 показан суммарный вес каждого блока после упаковки. Next-Fit Dec ----- ------ Вместимость: 100 _____ Бинов для упаковки: 0 Время: 0 Ошибка: 32.500000 Заполнена: 79 63 60 58 93 80 90 17 Рис.1. Пример упаковки 12 случайно сгенерированных элементов посредством эвристики Next-Fit Decreasing First-Fit Dec Вместимость: 100 Бинов для упаковки: 6 Время: О Ошибка: 10.000000 Заполнено: 96 99 98 100 93 54 Рис. 2. Пример упаковки 12 случайно сгенерированных элементов посредством эвристики First-Fit Decreasing Рис. 3. Пример упаковки 12 случайно сгенерированных элементов посредством эвристики Best-Fit Decreasing . , задачи одномерной упаковки. Из вычислительных экспериментов следует, что эв-NFD , - , , элементов. Эвристики FFD и BFD, напротив, имеют меньшую, чем эвристика NFD, одинаковую по величине ошибку упаковки. Однако эвристика BFD требует больших, чем FFD-эвристика временных затрат. Связано это, прежде всего, с тем, что в случае BFD-эвристики каждый раз при упаковке текущего элемента необходимо определить максимально упакованный подходящий блок и поместить туда . , -дует считать FFD- и BFD-эвристики. Рост производительности современных ЭВМ позволяет широко использовать алгоритмы, менее критичные по отношению к быстродействию и машинной памяти, но позволяющие получить качественные (т.е. близкие к оптимуму) результаты. Среди таких подходов можно выделить генетические алгоритмы - мощный метод оптимизации, моделирующий естественный процесс эволюции в качестве средства достижения оптимума, сравнительно недавно начавший широко применяться для решения задач в различных областях, включая задачу размещения при проектировании СБИС [12]. ]]></text>
</doc>
