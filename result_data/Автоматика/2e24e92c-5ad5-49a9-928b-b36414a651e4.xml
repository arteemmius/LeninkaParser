<doc>
  <source auto="true" type="str" verify="true"><![CDATA[https://cyberleninka.ru/article/n/usovershenstvovannyy-metod-vychisleniya-logicheskih-funktsiy]]></source>
  <category auto="true" type="str" verify="true"><![CDATA[Автоматика]]></category>
  <author auto="true" type="list" verify="true">
    <item type="str"><![CDATA[Плотников Дмитрий Александрович]]></item>
  </author>
  <title auto="true" type="str" verify="true"><![CDATA[Усовершенствованный метод вычисления логических функций]]></title>
  <keywords auto="true" type="list" verify="true">
    <item type="str"><![CDATA[вычисление логических функций]]></item>
    <item type="str"><![CDATA[программируемые логические контроллеры]]></item>
    <item type="str"><![CDATA[метод масок]]></item>
    <item type="str"><![CDATA[logic functions calculation]]></item>
    <item type="str"><![CDATA[Programmable logic controllers]]></item>
    <item type="str"><![CDATA[masks method]]></item>
  </keywords>
  <annotation auto="true" type="str" verify="true"><![CDATA[Предложен усовершенствованный метод масок, обеспечивающий существенную экономию памяти микропроцессорной системы. Приведены сравнительные характеристики классическо-го и усовершенствованного методов, рекомендации по оценке целесообразности использования предложенного метода. Проанализирована эффективность предложенного метода применительно к задаче моделирования блока управления защитой турбоагрегата по вибрации.]]></annotation>
  <text auto="true" type="str" verify="true"><![CDATA[© 2011 г. Д.А. Плотников Южно-Российский государственный South-Russian State Technical технический университет (Новочеркасский University (Novocherkassk политехнический институт) Polytechnic Institute) Предложен усовершенствованный метод масок, обеспечивающий существенную экономию памяти микропроцессорной системы. Приведены сравнительные характеристики классического и усовершенствованного методов, рекомендации по оценке целесообразности использования предложенного метода. Проанализирована эффективность предложенного метода применительно к задаче моделирования блока управления защитой турбоагрегата по вибрации. Ключевые слова: вычисление логических функций; программируемые логические контроллеры; метод масок. The improved masks method providing essential economy of microprocessor system memory is offered. Comparative characteristics of the classical and improved methods are described; recommendations are made according to expediency of use of the offered method. Article analyzes efficiency of the offered method, applied to the problem of turbo-generator protection block modeling. Keywords: logic functions calculation; programmable logic controllers; masks method. При программной реализации логических блоков с большим числом входных переменных нередко возникает задача вычисления логических функций, у которых независимо друг от друга результат определяют относительно небольшие группы входных переменных. При записи в дизъюнктивной нормальной форме (ДНФ) каждая конъюнкция в формуле такой функции содержит сравнительно немного переменных при достаточно большом их общем количестве. Например, у функции, описываемой формулой у = Х1 х2 + х3 х4 + ••• + х127 х128 (1) при общем числе переменных 128 на результат независимо друг от друга влияют лишь пары переменных (х1, х2), (х3, х4) и т. д. В [1] было показано, что при программной реализации логических блоков с большим числом входных переменных во многих случаях для вычисления логических функций наиболее приемлемым является метод масок [2, 3], основанный на использовании таблицы решений (ТР) вычисляемой функции. ТР содержит список всех комбинаций входных переменных, при которых функция принимает значение «1». Такую таблицу удобно строить на основе ДНФ функции: при этом каждой конъюнкции ДНФ соответствует отдельная строка ТР. Если некоторая переменная входит в конъюнкцию в прямом виде, то в соответствующую позицию строки ТР пишется единица, если в инверсном виде — то ноль. Если переменная вообще не входит в рассматриваемую конъюнкцию, то в качестве её значения указывается символ «*», обозначающий, что в данном случае (то есть при указанных значениях остальных переменных) значение функции не зависит от данной переменной. Например, для функции четырёх переменных у = х1 + х1 х2 + х1х3 х4 ТР будет иметь следующий вид (табл. 1): Таблица 1 Xi X2 X3 x4 0 * * * 1 1 * * 1 * 1 0 Для получения значения функции методом масок на этапе разработки программы на основе ТР формируются две таблицы: М и Т, размерность которых совпадает с размерностью ТР. В таблице М все элементы ТР, имеющие значение «*», заменяются нулями, а остальные — единицами. В таблице Т все элементы ТР со значениями «1» и «0» сохраняются, а остальные заменяются нулями. В табл. 2 приведён пример таблиц М и Т, сформированных для заданной ранее ТР (табл. 1). Таблица 2 Таблица М Таблица Т Х1 Х2 Хз Х4 1 0 0 0 1 1 0 0 1 0 1 1 Х1 Х2 Хз Х4 0 0 0 0 1 1 0 0 1 0 1 0 В процессе вычислений вектор входных переменных поразрядно логически умножается на первую строку таблицы М, за счёт чего всем входным переменным, не оказывающим влияния на результат функции в соответствующей строке ТР, присваиваются значения «0». Затем результат умножения сравнивается с соответствующей строкой таблицы Т. При совпадении считается, что вычисления окончены (то есть текущая комбинация значений входных переменных соответствует одной из строк ТР), а функции присваивается значение «1». При несовпадении рассматривается вторая строка таблиц, третья и так далее. Если совпадение не обнаружено ни в одной строке, то функции присваивается значение «0». Метод масок обладает такими преимуществами, как конфигурируемость (возможность изменения вычисляемой функции без изменения алгоритма вычислений), компактность и сравнительно небольшое время получения результата. Однако для функций типа (1) классическая реализация метода масок приводит к заметному перерасходу памяти микропроцессорной системы (МПС). Вследствие того что у таких функций независимо друг от друга результат определяют относительно небольшие группы входных переменных, в каждой строке ТР функции определено лишь несколько значений (нулей или единиц), в то время как большая часть переменных на результат строки не влияет (табл. 3). Таблица 3 ТР функции, описываемой формулой(1) Х128 • .. Х1 **** **** **** **01 **** **** **** 01** 01** **** **** **** При формировании таблиц М и Т в соответствии с такой ТР каждая их строка будет содержать большое количество незначащих разрядов, соответствующих символу «*», непроизводительно расходующих память МПС. Например, для функции (1) таблицы М и Т имеют вид, представленный в табл. 4. Таблица 4 Таблица М Х128 • .. Х1 0000 0000 • . 0000 0011 0000 0000 • . 0000 1100 1100 0000 • . 0000 0000 Таблица Т Х128 • .. Х1 0000 0000 • . 0000 0001 0000 0000 • . 0000 0100 0100 0000 • . 0000 0000 Для описания каждой конъюнкции из двух переменных в табл. 4 используется 256 битов, что приводит к существенному расходу памяти. С целью его снижения модифицируем метод масок с учетом специфики реализуемых функций. Изменим способ указания используемых и неиспользуемых переменных. Для этого разобьём всё множество переменных на группы и для каждой группы определим признак её использования в текущей строке таблиц. Если этот признак равен нулю, то все переменные группы не используются в данной конъюнкции, а соответствующие им биты исключаются из таблиц М и Т (считаются равными нулю). Если же признак равен единице, то переменные соответствующей группы описываются в таблицах М и Т обычным способом. Длина строк таблиц М и Т в общем случае будет переменной, однако это не ухудшит быстродействие алгоритма их обработки, поскольку строки обрабатываются последовательно друг за другом, и определение адреса начала произвольной строки не требуется. Наиболее эффективным такой способ будет в том случае, если все переменные каждой конъюнкции относятся к одной группе, а размер самих групп невелик — при этом длина строк в таблицах М и Т получится минимальной. Чем больше переменных из разных групп будут участвовать в конъюнкциях, тем длиннее будут соответствующие строки таблиц. Для осуществления предложенного метода на этапе разработки программы необходимо выполнить следующие действия. 1. Составить ТР функции. 2. На основе анализа ТР функции разбить всю совокупность входных переменных на группы, совместно влияющие на результат, и расположить эти группы последовательно одна за другой для упрощения программной реализации. 3. На основе ТР функции составить таблицу признаков использования групп О, а также модифицированные таблицы М и Т. Число строк каждой таблицы одинаково и соответствует числу строк в ТР. Каждая строка таблицы О содержит по одному биту (признаку использования) для каждой группы переменных (то есть число битов равно числу групп). Если всем переменным какой-либо группы в строке ТР соответствуют символы «*», то соответствующий признак использования группы принимается равным нулю. Если же хоть одной переменной из группы в ТР соответствуют значения «0» или «1», то признак использования устанавливается в единицу. Строки модифицированных таблиц М и Т формируются по тем же правилам, что и в классическом методе масок, однако из них исключаются переменные, принадлежащие к неиспользуемым в данной строке группам (то есть к группам, для которых признаки использования в таблице О равны нулю). Полученные в результате описанных действий таблицы О, М и Т размещаются в памяти МПС. Для функции, описываемой выражением (1), они будут выглядеть так, как показано в табл. 5. При этом считаем, что переменные х1х8 образуют группу g1, х9х16- группу £2 и т. д. В приведённом примере все строки таблиц М и Т имеют одинаковую длину, поскольку каждая конъюнкция ДНФ функции (1) содержит переменные только из какой-либо одной группы. Однако это не является обязательным условием: длина строк таблиц М и Т определяется числом единиц в соответствующей строке таблицы О. На этапе вычислений при реализации усовершенствованного метода программа для каждой строки таблиц О, М и Т последовательно выполняет следующие действия. 1. Из вектора входных переменных X при помощи таблицы О исключаются переменные, принадлежащие к неиспользуемым в соответствующей строке ТР группам. В результате формируется сокращённый вектор частично используемых входных переменных XI, длина которого равна длине соответствующих строк таблиц М и Т. 2. Аналогично классическому методу вектор XI поразрядно логически умножается на строку таблицы М, а результат умножения сравнивается со строкой таблицы Т. При совпадении вычисления завершаются, а функции присваивается значение «1». Если же совпадение не найдено ни в одной строке таблиц, функции присваивается значение «0». Оценим экономию памяти, возникающую вследствие использования усовершенствованного метода масок. Для хранения таблиц М и Т классического метода необходимый объём памяти определяется формулой М1 = 2п ■ NK, (2) где М1 — число бит памяти для хранения таблиц М и Т классического метода; п — число переменных; NK — число конъюнкций в ДНФ функции. Для оценки объёма памяти, необходимого для хранения таблиц усовершенствованного метода, получена формула М2 = МкО + Оп >(( ■ N0, (3) 1=1 где М2— число бит памяти для хранения таблиц О, М и Т усовершенствованного метода; О — число групп переменных; N — число конъюнкций, содержащих переменные из 1 различных групп; О при этом Nк = > N1 . 1=1 Для простоты считаем, что число переменных в каждой группе одинаково, а общее число переменных п кратно числу групп. Тогда коэффициент изменения объёма требуемой памяти КМ можно определить, как отношение величины М2 к М1: М2 О 1 ( лм КМ = —- = — +-> ( ■ Ni) (4) М М1 2п NкОj-^K 1'. (4) Из выражения (4) следует, что эффективность усовершенствованного метода для сокращения объема необходимой памяти существенно зависит как от свойств конкретной вычисляемой функции, так и от выбранного числа групп и распределения переменных по группам. Кроме того, применение усовершенствованного метода в некоторых случаях может увеличить объём требуемой памяти. Например, если каждая конъюнкция Таблица G Таблица М Таблица 5 Таблица T функции содержит переменные из всех групп, то коэффициент КМ будет больше единицы. Быстродействие предложенного метода и размер машинного кода программы, его реализующей, зависят от характеристик конкретного микропроцессора и используемого языка программирования. Очевидно, что введение дополнительных признаков использования групп (таблицы О), а также использование групп с количеством переменных, не кратным размеру машинного слова, снизит быстродействие предложенного метода и увеличит размер программы по сравнению с классической реализацией. С другой стороны, предложенный метод существенно уменьшает размер обрабатываемых данных, а именно таблиц М и Т, что должно повысить быстродействие программы. Поэтому дать какие-либо рекомендации по оценке быстродействия и размера машинного кода в общем виде не представляется возможным. Проверка быстродействия и размера машинного кода усовершенствованного метода масок была выполнена автором при его использовании в модернизированной версии прибора для проверки блока логики управления защитой турбоагрегата (ППБЛ), описанного в [4]. Блок логики контролирует по три ортогональных составляющих вибрации для каждой из восьми опор ротора турбоагрегата. По каждой составляющей блок обрабатывает три дискретных сигнала: «Предупредительный уровень вибрации», «Аварийный уровень вибрации» и «Отказ канала измерения». На основании полученных данных (всего 72 входных сигнала) блок логики формирует сигнал «Аварийный останов» в соответствии с выражениями у = Ац ЁЦ (,2 Ё~2 + ^,3 Щ)+ + 4,2 Ё~2 ((,1 % + ^,3 Щ)+ + А.,3 Щ((1~х + ^,2 Ё~2 )+ + (1 % + А;',2 Е;.,2 + А;,3 Е.,3 )Х Х <Ж(;'-1),1 Щ-1),1 + -1),2Щ-1),2 + -1),3Щ-1),3 + + ^(;+1),1 Е(1+1),1 + ^(;+1),2Е(1+1),2 + ^(;'+1),3Е(г+1),э) ,(5) где ;' — номер опоры турбоагрегата (1...8); у — номер составляющей вибрации опоры турбоагрегата (1...3); Ж — сигнал, информирующий о достижении предупредительного уровня на у-й составляющей вибрации ;'-й опоры; А. . — сигнал, информирующий о достижении аварийного уровня на у-й составляющей вибрации ;'-й опоры; Е, — сигнал, информирующий об отказе канала, контролирующего у-ю составляющую вибрации ;-й опоры. По формуле (5) вычисляются промежуточные результаты у1у8. При этом считаем, что перемен- ные с индексом (;-1) при ;=1 и с индексом (;+1) при ;=8 равны нулю. Окончательный результат у вычисляется по формуле у = У1 + У2 + У3 + у4 + у5 + у6 + у7 + У8 . (6) В составе ППБЛ при помощи усовершенствованного метода масок была реализована программно-логическая модель блока логики для сравнения её реакции на некоторый вектор входных воздействий с реакцией тестируемого блока. Проанализируем функцию, описанную формулами (5), (6). Из логических выражений следует, что функция учитывает только взаимосвязи переменных, относящихся либо к одной опоре, либо к двум смежным. Таким образом, если сгруппировать переменные по опорам, то каждая конъюнкция будет содержать переменные не более чем из двух групп. Общее число групп при этом равно восьми. Анализ формул (5), (6) показывает, что рассматриваемая функция включает в себя 48 конъюнкций, содержащих переменные, принадлежащие какой-либо одной группе, и 126 конъюнкций, содержащих переменные из двух различных групп. Воспользуемся выражением (4) для оценки экономии памяти при использовании усовершенствованного метода для реализации описанной функции. При этом считаем, что п=72, О=8, N=174, N^=48, N=126, параметры NN равны нулю. Подставив указанные величины в выражение (4), получим значение коэффициента КМ, равное 0,271. Таким образом, с точки зрения экономии памяти применение усовершенствованного метода для вычисления приведённой функции целесообразно. В ППБЛ, в частности, оно позволило хранить в памяти сразу несколько программно-логических моделей тестируемых блоков вместо одной, что повысило универсальность изделия. Для оценки быстродействия и размера машинного кода были написаны подпрограммы на языке С, реализующие классический метод масок и предложенный усовершенствованный метод. Кроме того, был исследован вариант усовершенствованного метода, в котором каждая группа масок выровнена по границам машинного слова ОМК. Во всех случаях использовалась одна и та же функция, описываемая формулами (5), (6). Быстродействие подпрограмм проверялось на программно-логической модели ОМК семейства MCS51, используемого в ППБЛ. Дополнительная проверка эффективности предложенного метода была выполнена на модели ОМК семейства ARM7, размер машинного слова которого превышает размер группы переменных, а также имеющего более эффективную реализацию команд сдвига, что требуется при работе с данными, не выровненными по границе машинного слова. Для оценки быстродействия использовалось время перебора программой всех конъюнкций, описанных в таблице. Результаты сравнения приведены в табл. 6, 7. Результаты сравнения показывают, что при использовании усовершенствованного метода имеет место некоторая потеря производительности: -35% на ОМК ADuC841 семейства MCS51 и -33% на ОМК LPC2292 семейства ARM7. Таким образом, использование тридцатидвухразрядного ОМК LPC2292 вместо восьмиразрядного ADuC841 не даёт существенного выигрыша в относительном быстродействии по сравнению с классической реализацией. Как показало исследование машинного кода, сгенерированного компилятором, это связано с тем, что ОМК LPC2292 не может в полной мере использовать преимущества увеличенной разрядности при работе с данными таблиц, не выровненными в памяти по границе машинного слова. Тем не менее, размер машинного кода для ОМК LPC2292 увеличился меньше, чем для ОМК семейства MCS51 (132 % против 171 %) за счёт более эффективной системы команд. Выравнивание содержимого таблиц в памяти по границе машинного слова существенно улучшает показатели усовершенствованного метода на ОМК обоих семейств. В первую очередь это связано с исключением операций сдвига данных, особенно неэффективных в ОМК MCS51. Кроме того, быстродействие метода на ОМК повышенной разрядности может дополнительно возрасти за счёт одновременной обработки несколь- ких байтов данных. Однако такое выравнивание в ряде случаев приводит к увеличению размера таблиц, описывающих реализуемую логическую функцию. Например, для описания рассмотренной выше функции усовершенствованный метод использует таблицы М и Т с размером элементов 9 бит (размер группы переменных). При выравнивании под каждый такой элемент будет отведено 16 бит памяти. За счет этого общий размер таблиц увеличится с 849 байтов (без выравнивания) до 1374 байтов (с выравниванием), т. е. в 1,6 раза. При принятии решения о целесообразности применения предложенного метода следует выполнить следующее. 1. Прежде всего оценить количество входных переменных вычисляемой функции. Если оно невелико, то целесообразным может оказаться использование классического метода масок или табличного метода [2,3]. 2. В том случае, если большое число переменных препятствует использованию классических методов [1], следует проверить возможность разбиения всей совокупности входных переменных на группы, независимо друг от друга влияющие на результат. Для этого нужно проанализировать ДНФ функции: чем меньше в ней конъюнкций, содержащих переменные из разных групп, тем более эффективным будет использование предложенного метода. Если кроме экономии памяти необходимо добиться минимального времени получения результата, то размер групп переменных следует выбирать кратным размеру машинного слова используемого микропроцессора. Это позволит выровнять элементы таблиц М и Т по Таблица 6 Сравнение быстродействия Метод Классич. Усовершенствованный Контроллер Без выравнивания С выравниванием Время, Время, Прирост, Время, Прирост, мс мс % мс % ADuC841 (MCS51) 8,386 11,315 -35 6,950 17 LPC2292 (ARM7) 0,549 0,730 -33 0,482 12 Таблица 7 Сравнение размера машинного кода Контроллер Метод Классич. Усовершенствованный Без выравнивания С выравниванием Размер, байт Размер, байт Прирост, % Размер, байт Прирост, % ADuC841 (MCS51) 97 263 171 168 73 LPC2292 (ARM7) 124 288 132 164 32 границам машинного слова и, как следствие, исключить операции сдвига данных и в полной мере использовать преимущества процессоров с повышенной разрядностью. 3. После того как разбиение на группы выполнено, при помощи выражения(4) можно оценить экономию памяти, обусловленную использованием усовершенствованного метода. В случае получения неудовлетворительного результата следует попытаться сгруппировать переменные иначе. При этом нужно иметь в виду, что увеличение числа групп ухудшает быстродействие метода, а уменьшение во многих случаях снижает экономию памяти. Подводя итоги, можно сказать, что использование предложенного усовершенствованного метода в соответствии с формулой (4) даёт существенную экономию памяти МПС для функций с большим числом входных переменных, у которых независимо друг от друга результат определяют относительно небольшие группы пе- ременных. Кроме того, в некоторых случаях отмечается уменьшение времени получения результата. ]]></text>
</doc>
