<doc>
  <source auto="true" type="str" verify="true"><![CDATA[https://cyberleninka.ru/article/n/algoritmy-bezyzbytochnogo-kodirovaniya-perestanovok-i-ih-obosnovanie]]></source>
  <category auto="true" type="str" verify="true"><![CDATA[Автоматика]]></category>
  <author auto="true" type="list" verify="true">
    <item type="str"><![CDATA[Бабенко Л.К.]]></item>
    <item type="str"><![CDATA[Мазурова Т.А.]]></item>
    <item type="str"><![CDATA[Сидоров И.Д.]]></item>
    <item type="str"><![CDATA[Чефранов А.Г.]]></item>
  </author>
  <title auto="true" type="str" verify="true"><![CDATA[Алгоритмы безызбыточного кодирования перестановок и их обоснование]]></title>
  <keywords auto="true" type="list" verify="true"/>
  <annotation auto="true" type="str" verify="true"><![CDATA[]]></annotation>
  <text auto="true" type="str" verify="true"><![CDATA[Известны генераторы (алгоритмы генерации) псевдослучайных последовательностей для получения бегущего ключа при поточном шифровании. При программной реализации наиболее эффективны те из них, состояние которых в текущий момент времени описывается перестановкой элементов некоторого множества, например ЯС4 или 8оШаге [1]. В [2] предложен один из подходов к генерации сверхдлинных псевдослучайных последовательностей на основе ортогональных матриц, полученных при помощи алгоритма их генерации, описанного в [3]. При этом последовательность образуется формированием перестановок комбинаций столбцов сгенерированной матрицы и записью их элементов в строку. В качестве начального состояния генератора (зерна) предлагается использовать некоторую исходную перестановку номеров строк матрицы. Однако при программной реализации предложенного подхода в качестве ключа, формирующего зерно, удобнее использовать битовую строку произвольной длины. Интерпретируя битовый ключ в качестве целого числа в двоичной системе счисления, мы можем поставить задачу перехода от целого числа к перестановке таким образом, чтобы перестановка зависела от всех бит ключа. При этом обозначим множество, из которого формируется перестановка, множеством А (|А|=п). Для решения этой проблемы предлагается следующий подход: нумеруются все возможные перестановки элементов множества А целыми числами от 0 до п!-1. Тогда проблема эффективного кодирования решается достаточно просто, так как ключ и представляет собой число в двоичной системе счисления. Для удобства дальнейших рассуждений положим, что множество А, из которого формируются перестановки, состоит из целых чисел 0..п-1. При этом не теряется общность рассуждений, так как элементам любого другого множества можно поставить в соответствие числа из этого интервала при помощи таблицы. Перенумеровывать перестановки естественно в том порядке, в котором они генерируются. Определим генератор перестановок как алгоритм, выдающий перестановки элементов заданного множества в порядке, определяемом природой алгоритма. Рассмотрим два генератора перестановок [4]: Генератор перестановок РегшСоипЙ. Алгоритм работает индуктивно, т. е. гарантирует получение всех перестановок из п элементов, если получены все перестановки из п-1 элементов. Описание итерации алгоритма: имеется перестановка а1а2^ап-1. Подставляя п поочерёдно на все возможные места, получаем п перестановок: па1а2^ап-1, а1па2^ап-1, ..., а1а2^пап-1, а1а2^ап-1п. Применяя алгоритм рекурсивно, получаем алгоритм - перечислитель перестановок. Пример: перестановки из 3-х элементов {0,1,2}, полученные алгоритмом РегшСоипИ 210 120 102 201 021 012 2. Генератор перестановок РегшСоип12. Алгоритм работает индуктивно. Описание итерации алгоритма: имеется перестановка аіа2...ап-ь Дописываем справа число к (0 < к < п ) и увеличиваем на 1 элементы, значение которых > к. Итого получаем п перестановок. Применяя алгоритм рекурсивно, получаем алгоритм - перечислитель перестановок. Пример: (перестановки из 3-х элементов {0,1,2}, полученные алгоритмом РегшСоиШ2) 210 201 102 120 021 012 Однако если для кодирования перестановки каждый раз перечислять все перестановки, то получим временную сложность задачи порядка 0(п!), что делает задачу неразрешимой при больших п. Эффективно решить эту задачу можно только разработав алгоритмы полиномиальной сложности. Введём несколько определений. Перестановкой размерности п назовём запись а0а1 .ап-1, где а1 є 0..п-1, аі = а^ «і = ] . Безызбыточным кодом перестановки размерности п назовём число 0..п!-1, взаимно однозначно соответствующее этой перестановке. Относительной записью перестановки назовём запись вида Ь0Ьь..Ьп-ъ 0 < Ьі < і, где элемент Ь1 соответствует выбору на 1-том шаге генератора из множества вариантов мощностью 1+1, нумерованных 0..1. Для алгоритма РегшСоиШ! Ь1 показывает, в какую позицию имевшейся на 1-том шаге перестановки был вставлен элемент 1. Для алгоритма РегшСоий:2 Ь1 показывает, какое число было записано в позицию 1 имевшейся на 1-том шаге алгоритма перестановки. Из перестановки можно получить её относительную запись за полиномиальное время. Необходимо только найти, какой по порядку выбор сделан на каждом шаге алгоритма, последовательно «разбирая» перестановку. Для генератора РегшСоипИ мы находим, в какую позицию был записан элемент п-1 - это и будет Ьп-1. Далее мы удаляем этот элемент и сдвигаем оставшуюся часть перестановки. Находя максимумы, удаляя и сдвигая их, находим Ьп-2, ., Ъь Ь0. Для генератора РегшСоий2 мы смотрим, какой элемент был записан в позицию п-1 - это это и будет Ьп-1. Этот элемент мы отбрасываем и уменьшаем на 1 те а є {аі }П—25 а > ап-1. Аналогично получаем Ьп-2, ., Ъь Ь0. От относительной перестановки можно легко перейти к безызбыточному коду, интерпретируя эту перестановку в качестве числа в комбинаторной системе счисления следующего вида: п-1 п х=Х ь хП л і=0 Л=і+2 0 < Ьі < і п П = 1 Л=П+1 Приведем алгоритмы, которые осуществляют переход от перестановки к бе-зызбыточному коду и обратно за полиномиальное время. Преобразование перестановки осуществляется поэлементно. Алгоритм прямого кодирования для РегшСоипЙ. Данный алгоритм поэлементно переводит перестановку в её относительную запись и вычисляет х, используя комбинаторную систему счисления. Вход: n-размерность перестановки. a0ai...an_i - перестановка, полученная PermCountl. Выход: x - номер перестановки в перечислении (0 < x < n!). Переменные: i - индекс; w-весовой коэффициент; q-множитель. 1 [Инициализация] x^0; w^l; q^n 2 [Поиск] i^0; Пока аi ^ q-l i^i+1 кц 3 [Вычисления] x^x+(i*w); w^w*q; q^q-l 4 [Сдвиг] Пока i<q a1^a1+l; i^i+1 кц 5 [Выход] Если q=0 то выход, иначе шаг 2. Доказательство корректности: База индукции: перестановка из 1 элемента 0 возвращает x=0. Тело индукции: предположим, алгоритм работает корректно для перестановки размерностью n. Докажем, что он работает корректно для перестановки размерностью n+l. Каждая перестановка размерности n служит основой для n+1 перестановки. Элемент n занимает позицию i, которая показывает, какой по счёту является данная перестановка среди этих n+1 перестановок. Весовой коэффициент для всех остальных членов базовой перестановки умножается на n+l. То есть xn+l=xn х (n+l) + i; 0 < i < n +1, где xn+l - номер перестановки размерности n+l, xn - номер перестановки размерности n, породившей перестановку с номером xn+l. Формула показывает, что если номер xn определён корректно, то и номер xn+l будет определён корректно. Алгоритм корректен. Алгоритм обратного кодирования для PermCountl. Данный алгоритм раскладывает х в комбинаторной системе счисления и поэлементно переводит относительную запись перестановки в обычную. Вход: n - размерность перестановки x - номер перестановки в перечислении ( 0 < x < n! ). Выход: a0al . an-l - перестановка с номером x в перечислении. Переменные: i,j - индексы; w-весовой коэффициент; q-множитель. 1 [Инициализация] a0,ab...,an-l^ 0; w ^ n!; q^l 2 [Вычисления] i ^ x div w; x <- x mod w; q^q+l; w^w div q 3 [Сдвиг] j ^q-l; Пока (j > i) aj^aj-l j ^j-l кц; a^q-2 4 [Выход] Если w=0 то выход, иначе шаг 2. Доказательство корректности: База индукции. Для n=l x=0 имеем одну перестановку - 0. Тело индукции. Предположим, алгоритм работает корректно для всех перестановок размерности n. Докажем, что алгоритм корректен для всех перестановок размерности n+1. Перестановка формируется по закону xn+l=xn х (n+l) + i; 0 < i < n +1. Аналогично ведёт себя алгоритм: весовой коэффициент умножается на n+1, а i есть остаток от деления на n+1, поэтому лежит в нужных пределах. Алгоритм корректен. Для решения задачи прямого и обратного кодирования перестановок также может использоваться нумерация, задаваемая генератором PermCount2. Проанализируем емкостную и временную сложность предложенных алгоритмов. Для анализа емкостной сложности найдём число знаков, необходимых для представления перестановки, её относительной записи и безызбыточного кода в системе счисления с основанием s. Для получения размера представления в битах и байтах возьмём соответственно s=2 или s=256. Перестановка: n([lcg n]), где flog, n] - размер одного знака перестановки, n - общее количество знаков. 26l Относительная запись: г_| +ц, ГДе |_1°ё* г'] +1 " размер ьтого знака (так г=1 как 0 < Ьг < г); сумма берётся по всем 1=1..п-1. Первый знак относительной записи всегда 0, поэтому мы его не учитываем. Безизбыточный код: , где п! - общее число перестановок. flog sn!] = Отсюда следует, что асимптотическая емкостная сложность представлений одинакова и составляет O(n log n). Оценим временную сложность предложенных алгоритмов. Внешний цикл всегда осуществляет n итераций. Сложность арифметических операций пропорциональна размеру чисел и составляет O(n log n). Время нормализации части перестановки пропорционально её размеру и составляет также O(n log n). Тогда общая сложность всего алгоритма составляет O(n2 log n). Помимо предложенного, существует подход к кодированию перестановок, предложенный в [5], основанный на представлении числа в факториальной системе счисления. Проведённая оценка его сложности также дала результат O(n2 log n). Однако данный алгоритм не обоснован формально и не рассматривается возможность его использования для решения поставленной задачи. Таким образом, разработанные алгоритмы осуществляют установление взаимно однозначного соответствия между множеством перестановок размерности n и множеством целых чисел 0..n!-1, причём переход осуществляется за полиномиальное от n время, что позволяет их использовать для формирования начального состояния криптосхем. Работа поддержана грантами РФФИ № 01-07-90211 и 03-07-90075. ]]></text>
</doc>
