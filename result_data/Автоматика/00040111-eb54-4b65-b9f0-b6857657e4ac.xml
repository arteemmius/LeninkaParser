<doc>
  <source auto="true" type="str" verify="true"><![CDATA[https://cyberleninka.ru/article/n/kombinatorika-slov-i-postroenie-testovyh-posledovatelnostey]]></source>
  <category auto="true" type="str" verify="true"><![CDATA[Автоматика]]></category>
  <author auto="true" type="list" verify="true">
    <item type="str"><![CDATA[Кулямин В.В.]]></item>
  </author>
  <title auto="true" type="str" verify="true"><![CDATA[Комбинаторика слов и построение тестовых последовательностей]]></title>
  <keywords auto="true" type="list" verify="true"/>
  <annotation auto="true" type="str" verify="true"><![CDATA[Статья целиком посвящена возможным подходам к решению задачи построения тестовых последовательностей, поскольку она в имеющейся литературе практически не затрагивается. В статье не излагается ее полное решение с каких бы то ни было позиций, а, скорее, рассматриваются несколько подходов к такому решению, основанных на похожих идеях, и освещаются известные автору результаты, полученные в рамках этих подходов.]]></annotation>
  <text auto="true" type="str" verify="true"><![CDATA[В. В. Кулямин 1. Введение При тестировании систем, поведение которых определяется не только последним обращением к ним, а и предшествующей историей работы, т.е. зависит от внутреннего состояния системы, необходимо строить тесты в виде последовательностей обращений, чтобы покрыть возникающие разнообразные ситуации. Если о системе известно немного, например, только список обращений, которые можно делать, построить ее тест в полном смысле этого слова нельзя, поскольку частью теста всегда является проверка правильности работы системы в ответ на тестовые обращения. Однако можно попробовать построить входные данные теста — определить, какие операции, с какими параметрами и когда вызывать, предположив, что проверка правильности работы системы производится отдельно. Ее может выполнять специальный модуль автоматической проверки, или же это может делать человек, понимающий, когда очередная реакция системы правильна, а когда — нет. При этом возникает две задачи: построение значений параметров вызовов и построение последовательности вызовов. Непосредственное решение этих задач путем построения всех возможных комбинаций значений параметров и всех возможных последовательностей обращений сразу приводит к комбинаторному взрыву, поэтому требуются методы построения небольшого числа тестов, которые, тем не менее, были бы достаточно качественны, то есть покрывали бы максимально возможное число различных ситуаций, связанных с поведением тестируемой системы. Первая задача при отсутствии дополнительной информации о тестируемой системе обычно решается на основе разбиений возможных значений параметров на конечное число групп и использования различных комбинаций значений из разных групп. Для построения этих комбинаций можно 1 Данная работа поддержана грантом Российского Фонда содействия отечественной науке. использовать покрывающие массивы (covering arrays) [1—3], которые обеспечивают минимально возможные множества комбинаций, перебирающие все возможные сочетания пар, троек или другого числа значений отдельных параметров. Другие методы основываются на эвристических алгоритмах, вычисляющих приближения к минимальным покрывающим массивам; это оправдано, поскольку построение такого массива с нужными параметрами является NP-полной задачей. Обзоры имеющихся результатов по построению покрывающих массивов см. в [1,2]. Эта статья целиком посвящена возможным подходам к решению второй задачи — задаче построения тестовых последовательностей, поскольку она в имеющейся литературе практически не затрагивается. В статье не излагается ее полное решение с каких бы то ни было позиций, а, скорее, рассматриваются несколько подходов к такому решению, основанных на похожих идеях, и освещаются известные автору результаты, полученные в рамках этих подходов. 2. Формулировка задачи Будем представлять возможные тестовые последовательности словами в алфавите из возможных вызовов. Число возможных вызовов можно считать конечным — для этого из множества всех возможных вызовов нужно выбрать конечное множество представителей, например, выделив «наиболее интересные» комбинации значений параметров (см. выше). Такому подходу практически нет альтернатив, поскольку тестирование, будучи принципиально конечной процедурой, не может обеспечить качественную проверку работы системы, если имеется бесконечное множество существенно различных способов обратиться к ней. Далее будем рассматривать тестовые последовательности как слова в конечных алфавитах. Поскольку мы не обладаем дополнительной информацией о тестируемой системе, все вызовы (представители) для нас ничем не отличаются друг от друга. Можно обозначить их символами от 0 до (т-1) и рассматривать т-последователъности или т-слова — слова произвольной длины, состоящие только из таких символов. Предположим теперь, что, помимо известного нам числа т различных воздействий на систему, от пользователя мы можем получить только ограничение на суммарную длину теста. Стоящая перед нами задача может быть в итоге сформулирована так: как построить одно «/-слово длины, не превосходящей N, имеющее «как можно более разнообразное» поведение? Возможные интерпретации «как можно более разнообразного» поведения рассматриваются ниже. Сразу отметим, что можно пытаться построить несколько да-слов, сумма длин которых не превосходит N, совместно обеспечивающих нужное разнообразие. Такая постановка задачи и возможные подходы к ее решению оставлены за рамками данной статьи. 3. Максимизация числа различных подслое Наверное, наиболее очевидный способ интерпретации «как можно более разнообразного поведения» слова — это наличие у него как можно большего числа различных подслое. В слове длины N имеется всего N + (N-1) + (N-2) + ... + 2 + 1 = ЩЫ+1)/2 (*) подслов (слагаемые соответствуют подсловам длины 1,2 и т.д.). Можно попытаться максимизировать количество разных подслов, сделав все подслова какой-то длины к различными. При этом все подслова большей длины тоже автоматически будут различны, т.е. мы получим как минимум (Х-к I)(Х-к+2)/2 разных подслов длины к. Значение к при этом можно выбрать так, чтобы максимизировать полученное выражение при фиксированном Л', т.е. как можно меньшее. При этом имеется всего тк разных л/-ело в длины к, а если они все реализуются как подслова одного слова, длина этого слова должна быть не меньше тк+к-1. Предположим, что существуют такие «наиболее плотные» слова, что все их подслова длины к различны и в то же время включают в себя все возможные /н-слова длины к, и они нам известны. Тогда для заданного N можно найти минимальное к, такое что N < тк+к-1, т.е. т<к'1>+(к-1)-1 < N < тк+к-1, и в качестве искомого слова взять начало длины N соответствующего «наиболее плотного» слова. Это гарантирует различие всех подслов длины к в нем. Для того, чтобы еще больше увеличить количество разных подслов в нашем слове, можно попытаться найти «наиболее плотное» слово для (к-1), которое продолжается в «наиболее плотное» слово для к. Взяв начало этого последнего слова, мы получим наилучший результат — в полученном слове длины N все подслова минимально возможной длины к различны, и в то же время в нем в качестве подслов содержатся все возможные слова длины (к-1) и, соответственно, меньшие — все слагаемые в формуле (*) имеют максимальные возможные значения. Осталось выяснить два момента. • Существуют ли «наиболее плотные» слова для всех т и к, и если это так, можно ли их продолжать до «наиболее плотных» слов для т и (к+1)1 Есть ли достаточно эффективные алгоритмы для построения таких слов? • Какой тестовой гипотезе, т.е. какому допущению относительно свойств тестируемой системы, соответствует выбранное понимание «наиболее разнообразного» поведения слова? Для какого рода систем этот подход дает действительно оптимальное покрытие различных возможных ситуаций? Ответу на первый вопрос посвящен весь следующий раздел. В рамках данного раздела проще ответить на второй вопрос. Такой подход к построению тестов базируется на предположении о том, что поведение тестируемой системы целиком определяется последними к обращениями. При этом, выбирая тестовую последовательность, содержащую как можно больше различных подпоследовательностей длины к, мы покрываем наибольшее количество различных «поведений» системы. В качестве реального примера такой системы можно привести кодовый замок, реагирующий на последние набранные к (обычно 4 или 5) цифр (автор сам пользовался такими замками, см. также статью [4], посвященную стратегии эффективного вскрытия замка в отеле Baltimore Hilton). Дополнительное условие, обеспечивающее содержание в тестовой последовательности всех возможных слов длины (к-1), по отношению к этой гипотезе является некоторой необязательной «оптимизацией». 3.1. Слова де Бройна Итак, что можно сказать про «наиболее плотные» слова для т як, т.е. «/-слова, содержащие в качестве своих подслов длины к все возможные m-слова длины к, причем ровно по одному разу каждое9 Такие слова или последовательности известны под именем слое или последовательностей де Бройна (de Bruijn) шага к. Они были известны для случая т = 2 еще в 1894 г. [5], а впоследствии были независимо переоткрыты де Бройном [6] и еще несколькими авторами [7, 8, 9]. В статье [6] де Бройн поставил и решил задачу о том, сколько имеется циклов длины тк (цикл — это класс эквивалентности слов по циклическим перестановкам их символов, например, 0110, ООП и 1001 относятся к одному циклу), содержащих все упражнение 2.3.4.2-23 в [10]) показывает, что такие циклы существуют при всех т, к> 1. Слово де Бройна получается из цикла разрезанием его в некотором месте и копированием (к-1) символа из начала в конец получившегося слова в обратном порядке, чтобы сохранить подслова длины к. Обзор [11] дает наиболее полный экскурс в теорию слов де Бройна и историю их использования для решения различных задач. Там они названы циклами нелинейных сдвиговых регистров полной длины (full length nonlinear shift register cycles). Среди задач, связанных с комбинаторикой слов, в которых возникают слова де Бройна, можно отметить построение псевдослучайных последовательностей [12], построение кодов [13, 14], кодирование образов [15, 16], построение машин на основе сдвиговых регистров [11, 17, 18], организацию CDMA-сетей. В связи с тестированием программного обеспечения они упоминаются в [19]. Слова де Бройна связаны с графами специального вида, называемыми также графами де Бройна. Граф де Бройна с параметрами т > 1 и к > 1 В(т, к) — это ориентированный граф с тк'! вершинами V(m, к) = [O.^m-l)]^1, являющимися всеми возможными «/-словами длины (к-1), и ребрами Е(т, к) = [0..(т-1)]к, возможные «/-слова длины к. Полученный им ответ являющимися всеми возможными «/-словами длины к. При этом ребро Х]Х2... Хк-іХк начинается в вершине х}х2... х/._; и заканчивается в вершине х2... Примеры графов де Бройна показаны на рис. 1. Достаточно легко убедиться в выполнении следующего утверждения. Утверждение 1. 1) Граф В(т, 1) имеет ровно одну вершину — пустое слово — и т ребер-петель. 2) Граф В(т, 2) изоморфен полному ориентированному графу с петлями на т вершинах. 3) Количества входящих и выходящих ребер для любой вершины В(т, к) Последний пункт непосредственно влечет следующее. Утверждение 2. 1) Для всех т, к > 1 граф В(т, к) эйлеров, т.е. в нем существует цикл, включающий все ребра. 2) Любой эйлеров путь в В(т, к) однозначно соответствует слову де Бройна, а значит, такие слова существуют для всех т, к > 1. Для построения слова, соответствующего пути в В(т, к), выпишем слово, равны т. ЬФ є У(т, к) m-deg(v) = out-deg(v) = т оооо ті Рис. 1. Графы В(3, 1), В(3, 2), В(2, 3), В(2, 4). соответствующее первому ребру пути, затем для каждого следующего ребра пути будем приписывать в конец полученного слова последний символ этого ребра. Определим для ориентированного графа G дуальный граф L(G) как граф, имеющий в качестве вершин множество ребер G, а в качестве ребер — множество пар смежных ребер G, т.е. таких, что конец первой является началом второй. При этом ребро L(G) начинается в вершине, соответствующей первому элементу пары, а кончается в вершине, соответствующей второму. Утверждение 3. 1) Для всех т, к > 1 дуальный граф к В(т, к) изоморфен В(т, к+1). Это легко проверить, заметив, что паре смежных ребер В(т, к) соответствует слово длины (к+1), построенное по правилу из второго пункта предыдущего утверждения. Кроме того, все «/-слова длины (к+1) могут быть получены таким способом. 2) Эйлеров путь или цикл на графе G соответствует гамильтонову (проходящему через каждую вершину ровно один раз) пути или циклу на графе L(G). 3) Для всехт, к> 1 графВ(т, к) имеет гамильтонов цикл. Сформулированные утверждения позволяют определить достаточно эффективный алгоритм построения слов де Бройна — для этого достаточно построить граф В(т, к), что требует объема памяти и времени 0(тк), и найти в нем эйлеров цикл, что можно сделать за время, пропорциональное количеству ребер графа, т.е. опять за 0(тк), и используя такой же объем памяти. Длина слова де Бройна равна тк+к-1, т.е. тоже 0(тк), следовательно, такой алгоритм оптимален по порядку. Можно улучшить «внутренние» показатели эффективности такого алгоритма, т.е. уменьшить объем памяти, занимаемый внутренними структурами данных и время их обработки, не учитывая внешнюю память и время, используемые для вывода результата. Различные алгоритмы для порождения слов де Бройна довольно часто упоминаются в литературе, в том числе и алгоритмы с лучшими показателями «внутренней» эффективности. Часть из них основана на неожиданной связи между словами де Бройна и словами Линдона (Lyndon words). Слово Линдона длины к в алфавите мощности т — это лексикографически минимальный представитель /«-цикла, т.е. класса эквивалентности «/-слов по циклическим перестановкам их символов. Оказывается, что верно следующее утверждение. Утверждение 4. [11] Конкатенация лексикографически упорядоченной последовательности всех слов Линдона длин, делящих к, в некотором алфавите дает лексикографически минимальный цикл де Бройна шага к в том же алфавите (для получения из него слова де Бройна достаточно добавить первые к-1 символов из начала в конец). Эффективный (требующий ограниченного константой «внутреннего» времени на построение одного слова Линдона) алгоритм построения слов Линдона и слов де Бройна на их основе представлен в [20]. Другие алгоритмы можно найти в [21-28]. В работе [29] эмпирически сравнивается эффективность по времени алгоритмов из [20], [25] и [27], и последний алгоритм демонстрирует наиболее высокое быстродействие. 3.2. Продолжение слов де Бройна Нас, однако, интересует еще вопрос возможности продолжения слова де Бройна шага к до слова де Бройна шага (к+1). Ответ на этот вопрос дается следующим утверждением. Утверждение 5. 1) При т = 1 для всякого к > 1 единственное слово де Бройна шага к представляет собой слово &, соответственно, оно может быть продолжено до слова де Бройна шага (к+1) — & !. 2) При т >3 для всякого к > I любое слово де Бройна шага к может быть продолжено до слова де Бройна шага (к+1). Это значит, что для т = 1 или т > 3 существуют бесконечные слова, каждое начало которых имеет число разных подслов, максимальное среди слов той же длины. 3) При да = 2 ни для какого к > 2 ни одно слово де Бройна шага к не может быть продолжено до слова де Бройна шага (к+1), но любое такое слово может быть продолжено до слова де Бройна шага (к+2). Для к = 1 слова де Бройна — 01 и 10; каждое из них продолжается до слова де Бройна шага 2 — 01100 и 10011. Поскольку пункт 1 достаточно очевиден, докажем основные утверждения из пунктов 2 и 3. Отдельные утверждения этих пунктов доказаны в [30-32]. В [32], кроме того, несколько иначе доказано утверждение, что именно продолжения слов де Бройна имеют максимально возможное количество разных подслов. Слово де Бройна шага к соответствует эйлерову циклу в графе В(т, к) и гамиль-тонову в графе В(т, к+1). Если выбросить все ребра этого гамильтонова цикла, при да > 2 граф В(т, к+1) останется связным (см. ниже) и эйлеровым, посколь-ку входящие и исходящие полустепени всех вершин уменьшатся на і и оста-нутся равными. Поэтому можно дополнить выброшенный гамильтонов цикл до эйлерова цикла в В(т, к+1), который соответствует искомому продолжению. Связность В(т, к+1) не нарушится от выбрасывания ребер гамильтонова цикла, поскольку каяедую его вершину V можно соединить с 0к+1 (т-1)-м непересекающимся путем, и наоборот, & 1 можно соединить с V таким же количеством непересекающихся путей. Для доказательства этого достаточно рассмотреть следующую конструкцию. Пусть в V і > 0 первых символов равны 0, и х — первый символ V, отличный от 0, т.е. (і+1)-й. Тогда (т-2) искомых путей соответствуют словам, полученным конкатенацией & 1. символа у, не равного 0 или х, и V. Еще один путь получается, если взять конкатенацию (І: 1 и конца V, начинающегося с индекса (і+1). В полученных словах все подслова длины к, кроме начального и конечного, различны. Аналогично показывается существование (т-1)-го обратного пути из V в & 1. Для т = 2 и к > 1 аналогичное выбрасывание ребер гамильтонова цикла оставит несвязанными с остальными вершины & и 1к, в каждой из которых имеется по петле. Значит, хотя бы одна из этих петель не может войти ни в какое продолжение исходного гамильтонова цикла, соответственно, никакое его продолжение не будет соответствовать слову де Бройна шага (к+1). Доказательство того, что 2-слово де Бройна шага к можно продолжить до 2-слова де Бройна шага (к+2), можно найти в [30]. Утверждение 6 (гипотеза). При т = 2 для всякого к > 2 существует слово де Бройна шага к, которое можно продолжить до слова длины тк+1+(к+1)-2, содержащего все возможные 2-слова длины (к+1), кроме одного. Это значит, что при т = 2 некоторые (не все!) слова де Бройна (назовем их продолжающимися) можно продолжить почти до нужной длины (на 1 меньшей длины следующего слова де Бройна), а значит, мы можем модифицировать предложенный выше способ построения слова длины N с максимально возможным числом разных подслов для т = 2 следующим образом: находим минимальное к, такое что 2к+І+(к+1)-1 > X. строим продолжа-ющееся слово де Бройна шага к и продолжаем его до длины N. Поскольку N < 2к 1 (к 0-2. мы сможем это сделать, и полученное слово будет иметь максимально возможное число разных подслов — для длин, не превосхо-дящих к, это следует из того, что его начало является словом де Бройна шага к, а для больших длин из того, что все такие подслова в нем различны. Доказательство этого утверждения автору неизвестно, хотя оно кажется истинным. Примеры продолжающихся 2-слов де Бройна шагов 2, 3, 4, 5, б приведены в Таблице 1. В этих примерах продолжающееся слово де Бройна отделено точкой от продолжения, которое дополняет его до слова, содержащего все слова длины (к+1), кроме 1к+1. к Продолжающееся 2-слово вместе с продолжением 2 00110.1000 3 0001011100.11010000 4 0000100110101111000.1110110010100000 5 000001010110010001101111101001110000.11110011000100101110110101000000 6 000000101000100101110010000110001110111111010011010101101100111100000. 1111100110010101001001110001011000010001101110101111011010000000 Таб. 1. Продолжающиеся 2-слова де Бройна. Примеры можно искать как гамильтоновы пути в В(2, к+1), начинающиеся в & и заканчивающиеся в 1&'1. Предположительно, такой путь всегда можно выбрать так, чтобы он пересекался с каждым циклом графа В(2, к+1) (т.е. имел хотя бы одно общее с циклом ребро), за исключением петель & 1 и 1к тогда он дополняется до «почти эйлерова» пути, который не покрывает только ребро j к+1 4. Универсальные покрывающие последовательности Теперь рассмотрим другой способ интерпретации «как можно более разнообразного» поведения «/-слова. Можно считать, что тестируемая система является некоторым небольшим конечным автоматом, и строить искомое слово как покрывающее все возможные конечные автоматы с числом состояний, меньшим некоторого к (нужно рассматривать только сильно связные автоматы, в которых все входные стимулы допустимы во всех состояниях, иначе их нельзя покрыть с помощью одного слова; кроме того, ограничимся пока детерминированными автоматами). Нужное к можно выбрать как максимальное, покрывающее все автоматы слово длины, не большей N. Таким образом, мы ищем «/-слова, покрывающие все детерминированные сильно связные конечные автоматы с не более чем к состояниями и да входными символами, определенными во всех состояниях (автоматы, в которых во всех состояниях допустимы одни и те же да символов называют да-регулярными). Однако «покрывать» можно разные элементы автомата. Достаточно естественно считать такими элементами все состояния, все переходы, пары смежных переходов и пр. и рассматривать для этих случаев разные слова. Универсальной покрывающей т-последователъностъю или универсальным покрывающим т-словом шага k > 1 и глубины I > 0 (universal covering word) назовем да-слово, которое, будучи подано на вход любому детерминированному сильно связному да-регулярному автомату с к состояниями, определит в нем маршрут, содержащий все возможные маршруты длины / данного автомата. При 1 = 0 считаем маршрутами длины О все его состояния. Обозначим множество универсальных покрывающих да-слов шага к и глубины / через UC(m, к I). Можно усомниться в том, что наша гипотеза о тестируемой системе как автомате с не более чем к состояниями, хорошо согласуется с реальностью — ведь число состояний в большинстве реальных систем таково, что требующиеся последовательности будут иметь колоссальную длину. Однако такая гипотеза приобретает более глубокий смысл, если считать, что состояния системы разбиваются на не более чем к групп таких, что переход по любому стимулу осуществляется из одной группы в другую или в ту же (т.е. отсутствуют такие стимулы, что из некоторой группы состояний переходы по этому стимулу ведут в состояния нескольких разных групп). При этом иногда можно считать, что различия между состояниями в рамках одной группы гораздо меньше, чем между состояниями различных групп, и поэтому, прежде всего, важно протестировать поведение системы относительно разных групп ее состояний. В имеющейся литературе универсальные покрывающие слова практически не упоминаются, в отличие от слов де Бройна. Некоторое количество работ посвящено аналогу универсальных покрывающих слов глубины 0 (т.е. покрывающих все состояния) для неориентированных графов под названием универсальных обходящих последовательностей (universal traversal sequences, введены Куком, S. A. Cook, в конце 70-х годов прошлого века). В центре внимания этих работ находится не собственно построение таких последовательностей, а одна из проблем теории сложности алгоритмов — как соотносятся классы сложности P-log-SPACE детерминированных алгоритмов, требующих полиномиально-логарифмической памяти, и NP-log-SPACE недетерминированных алгоритмов с такими же требованиями к памяти. Дело в том, что задача построения пути между двумя произвольными вершинами графа является примером NP-log-SPACE задачи, а универсальная обходящая последовательность дает для нее детерминированный алгоритм решения. Тем самым, верхние и нижние границы длины универсальных обходящих последовательностей задают правила преобразования сложности NP-log-SPACE алгоритма для решения некоторой задачи в сложность P-log-SPACE алгоритма для нее же. В первой известной автору статье [33], в которой появилось понятие универсальной обходящей последовательности, было показано, что для любых т, к > 1 существует универсальная обходящая последовательность для m-регулярных неориентированных графов с к вершинами длины 0(m2k3log к), а при т = 2 даже ()(к3). Для ориентированного случая, который нас интересует, все обстоит несколько сложнее — длина универсальных покрывающих слов как минимум экспоненциальна в зависимости от к. Для доказательства этого достаточно заметить, что такие слова, как минимум, не короче слов де Бройна (см. Утверждение 7). Доказать, что универсальные покрывающие слова существуют для всех т, к > 1 и / > 0, достаточно просто. Для этого заметим, что ш-регулярных автоматов с к состояниями конечное множество — число способов направить m переходов из одного состояния равно к"1, число возможных способов их компоновки в автомат к!™, а если учесть возможность произвольной перенумерации состояний, отличных от начального, остается ккт/(к-1)\ неизоморфных автоматов. «Почти все» из них сильно связны (т.е. доля автоматов, не являющихся сильно связными, уменьшается с ростом к и т). Если строить универсальное покрывающее слово достаточно прямолинейно — покрывать один за другим пути длины / в одном автомате, затем в другом и т.д. (при этом на проход в первую вершину очередного непокрытого пути тратится не более (к-1) шагов), то максимум через (кт1)(1 + к - 1)(1^т/(к-1)\) шагов все такие пути во всех автоматах будут покрыты — (I + к - 1) шаг делается для того, чтобы покрыть один путь, в каждом состоянии начинается т1 путей, в одном автомате к состояний. Обозначим через 11Б(т, к) множество да-слов, содержащих все возможные т-слова длины к в качестве подслов. Слова де Бройна являются наиболее короткими словами в 11Б(т, к). Утверждение 7. 1) Для всех да > 1 пустое слово лежит в ІІС(т, 1, 0). Для всех да > 1 слово 012...(т-1) лежит в 11С(т, 2, 0). Для всех да, 1>1 иС(т, 1, I) = 11Б(т, 1-1), т.е. в качестве универсального покрывающего слова шага 1 и глубины / можно взять слово де Бройна шага (1-1). 2) Для всех да > 1, к> 2 11С(т, к 0) с Ш(т, к-1). Т.е. слово может быть универсальным покрывающим шага к и глубины 0, только если оно содержит в качестве подслов все возможные слова длины (к-1). Таким образом, длина такого слова не меньше тк'1+к-2. 3) Для всех т, к 1>1 иС(т, к+1, 0) с 11С(т, к, I)- Зная универсальные покрывающие слова глубины 0, мы будем знать универсальные покрывающие слова для всех глубин, хотя, быть может, и не самые короткие. 4) Для всехт,к>1 11С(т, к+1, 0) = 11С(т, к, 1). Т.е. универсальные покрывающие слова глубины 0 в точности совпадают с универсальными покрывающими словами глубины 1 для шага с номером, меньшим на единицу. Следствие: 11С(т, к, 1) с 11Б(т, к). Для доказательства п. 2 рассмотрим семейство графов с к состояниями, изображенное на Рисунке 2. Рис. 2. Семейство "плохих" графов. В каждом графе этого семейства некоторая выделенная последовательность (к-1) символов приводит из начального состояния в (к-1)-е, а все остальные символы во всех состояниях ведут в начальное состояние. Всякая последовательность символов длины (к-1) встречается в качестве выделенной в одном из графов семейства. Если в слове из 11С(т, к, 0) нет какой-то последовательности длины (к-1) в качестве подслова, то состояние (к-1) соответствующего графа не будет покрыто. Для доказательства п. 3 предположим, что слово из UC(m, к+1, 0), будучи применено к некоторому автомату с к состояниями, не покрывает некоторый путь в нем длины /. Добавим в этот автомат новые / состояний так, чтобы этот путь начинался в том же состоянии, что и раньше, а дальше шел по новым состояниям. Переходы по всем символам из [0..(т-1)], не ведущим вдоль выделенного пути, из новых состояний направим в то состояние, которое было вторым на этом пути в исходном автомате. При этом получится т-регулярный автомат с (к+1) состояниями, по-прежнему сильно связный. Поскольку в исходном автомате наше слово не могло покрыть выделенный путь, а только по этому пути можно попасть в 1-е состояние из добавленных, то в результирующем автомате наше слово не может покрывать это состояние, что противоречит его принадлежности UC(m, к+1, 0). Для доказательства утверждения п. 4 (осталось доказать включение UC(m, к, 1) сг UC(m, к+1, 0)) предположим, что слово из UC(m, к, 1) не покрывает некоторое состояние в некотором автомате с (к+1)-м состоянием. Поскольку автомат сильно связен, в это состояние ведет некоторое множество ребер и из него выводит хотя бы одно ребро. Перенаправим все ребра, ведущие в это состояние, в состояние, в которое входит это самое выводящее ребро. При этом сильная связность не нарушится, а в автомате останется к состояний. Значит, наше слово покрывает все ребра из числа перенаправленных. Рассмотрим то ребро из этого множества, которое покрывается первым. Поскольку оно первое из перенаправленных, путь, покрываемый до него словом в исходном и результирующем автоматах, останется неизменным. Значит, в исходном автомате он должен далее пройти по этому ребру и попасть в непокрытое состояние. Полученная при доказательстве существования универсальных покрывающих слов верхняя оценка их длины слишком велика — на практике наиболее короткие покрывающие слова оказываются не намного длиннее соответствующих слов де Бройна. К сожалению, кроме приведенного выше утверждения, автору не много известно о свойствах универсальных покрывающих слов и об алгоритмах их построения. То, что каждое универсальное покрывающее слово глубины 0 содержит все последовательности определенной длины в качестве подслов, позволяет предположить, что можно строить такие слова на основе слов де Бройна. Сами по себе слова де Бройна не являются универсальными покрывающими в большинстве случаев (при к > 3 в п. 2 Замечания 7). Например, минимальная длина элемента UC(2, 3, 0) = UC(2, 2, 1) равна 6 (001011 и 110100), а соответствующие слова де Бройна имеют длину 5 (и универсальные покрывающие слова в данном случае — даже не продолжения слов де Бройна 00110, 01100, 10011, 11001). Неизвестно, выполнен ли аналог утверждения п. 4 Утверждения 7 для глубин, больших 2 при к > 2 (при к = 1 он точно не выполнен, поскольку UC(m, 1, I) совпадает с US(m, I), а, как только что было сказано, UC(m, 2, 1) уже отличается от иБ(т, 2)). Если это так, то можно было бы иметь дело либо только с универсальными покрывающими словами глубины 0 для разных шагов, либо только с универсальными покрывающими словами шага 2 для разных глубин (т.е. искать все универсальные покрывающие слова только на автоматах с двумя состояниями). Последнее свойство выглядит очень сильным, и поэтому есть сомнения в том, что оно выполняется. Все (с точностью до перестановок символов) известные автору универсальные покрывающие слова минимальных длин сведены в Таблице 2 (могут существовать универсальные покрывающие слова меньшей длины с заданными параметрами — те слова, про которые точно известно, что они имеют минимальную возможную длину, помечены звездочкой, в конце остальных слов стоит точка, кроме того, знаками вопроса помечены слова предположительно минимальной возможной длины). т, к, 1 Слова из иС(т, к, 1) 2, 2, 1 001011* 2, 2,2 01011000100111* 01110110001001* 2, 2,3 0101011010010000111000111100? 0101011110100100001110001100? 0101100010100100001111011100? 0101101010000100111100011100? 0101101010010011110001110000? 2, 2,4 00100110001111101101010000010111001010011101011001000010001111011. 00100110001111101101010000010111001010111101100100010011100001101. 00100110001111101101010000010111001010111101100100010011101100001. 00100110001111101101010000010111001010111101100111000010001001101. 2, 2,5 0000001000110011111010111001011010011011110001010100000111011000010010100100 0011010111111011001001110001011011001100010001. 3,2, 1 0010112022121* 0010112122020* 0010120221211* 0010201220211* 0010202201211* 0010211012022* 0010211020122* 0010212201120* 0010212202011* 0010220201211* 0010221201121* 0010221201211* 0012010220211* 0012022010211* 0012022101121* 0012022121011* 0012102212011* 0012110102022* 0012201121020* 0012202010211* 0012202101120* 0012202102011* 0100201211022* 0100211012022* 0101121220200* 0102122011200* 0120100211022* 0121101002022* 0122011210200* 0122021011200* 3,2,2 010021122022120011101210002010212220110201202210. 010021122022120011101210002011021222020102101120. 4, 2, 1 0010213123301120301322? 0010213123303013201122? 0012322133011203102130? 4, 2,2 0010223212031133033121302011002322003013233210122112313103000211122202032001 001230302333123320210330312121132232310102330102320133. 0010223212031133033121302011002322003013233210122112313103000211122202032001 001230302333123320210330312121132232310102330102322133. 0010223212031133033121302011002322003013233210122112313103000211122202032001 001230302333123320210330312121132232310102330102323133. 5,2, 1 01203244134310223042140112330043410. 6, 2, 1 00123424551335214043105322025411303441504351201452340. 00123442531554130210452033514322401154350242050312354. 7, 2, 1 01223454616533041025605143624206311552640321350066244015234651302463154312. 8, 2, 1 0122344567573616071530420317465264327051147250633762410021355776601454023673 7242360156531340307. 0122344567573616071530420317465264327051147250633762410021355776601454023673 7242360156531340703. 9, 2, 1 0123456788765432102041375860814253680716247350518263746172857030644831527225 58408776600113387685123806481731357412436704526183238364101781402. Таб. 2. Минимальные известные универсальные покрывающие слова. 5. Заключение Данная статья представляет два возможных подхода к построению тестовых последовательностей при отсутствии какой-либо информации, кроме числа возможных воздействий на тестируемую систему и длины последовательности, которую хотелось бы получить. Оба подхода приводят к построению слов в конечном алфавите, обладающих специфическими комбинаторными свойствами. Первый подход основывается на предположении, что поведение тестируемой системы определяется фиксированным числом последних оказанных воздействий. Последовательности, построенные на его основе, соответствуют словам де Бройна — самым коротким словам, содержащим в качестве подслов все последовательности определенной длины. Поскольку слова де Бройна имеют помимо тестирования массу других приложений, имеется достаточно много посвященных им работ и различных эффективных алгоритмов их построения. Второй подход предлагает использовать универсальные покрывающие слова, обеспечивающие покрытие путей некоторой длины во всех регулярных сильно связных детерминированных конечных автоматах с фиксированным числом состояний. Несмотря на наглядность предлагаемой идеи, она, по-видимому, до сих пор не рассматривалась, и найти работы, в которых использовалось бы понятие, эквивалентное определенным выше универсальным покрывающим словам, автору не удалось. Такие слова устроены сложнее, чем слова де Бройна, и пока не найдено ни хорошего описания их свойств, ни удобного аппарата для работы с ними, подобного графам де Бройна, ни достаточно эффективных алгоритмов их построения. Все это — задачи для продолжения исследований. Другое возможное направление развития — использование знаний пользователя о системе, которые в реальности чаще всего не нулевые, для построения более эффективных и более коротких тестовых последовательностей. Для начала можно использовать знания о том, что некоторые операции не изменяют состояния системы, некоторые другие, такие, как конструкторы объектов, не зависят от него, впоследствии можно добавить чаще всего известные предусловия операций и т.д. ]]></text>
</doc>
