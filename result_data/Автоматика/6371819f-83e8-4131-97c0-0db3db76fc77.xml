<doc>
  <source auto="true" type="str" verify="true"><![CDATA[https://cyberleninka.ru/article/n/model-identifikatsii-raspredelennyh-dannyh-na-osnove-algoritmicheskih-kodov]]></source>
  <category auto="true" type="str" verify="true"><![CDATA[Автоматика]]></category>
  <author auto="true" type="list" verify="true">
    <item type="str"><![CDATA[Копытков Д.Ю.]]></item>
  </author>
  <title auto="true" type="str" verify="true"><![CDATA[Модель идентификации распределенных данных на основе алгоритмических кодов]]></title>
  <keywords auto="true" type="list" verify="true"/>
  <annotation auto="true" type="str" verify="true"><![CDATA[Рассмотрены проблемы выбора идентификаторов данных в распределенной среде. Предложена модель многоалкодовости данных. Рассмотрены как частные, так и общие случаи работы модели. Показано, что использование функций построения алгоритмических кодов возможно не только в моделях асинхронного тиражирования данных с единым алгоритмом построения алкода, но и в тех моделях, где каждый участник тиражирования использует свой собственный алгоритм построения.]]></annotation>
  <text auto="true" type="str" verify="true"><![CDATA[Д.Ю. Копытков Томский университет систем управления и радиоэлектроники E-mail: pisces@inbox.ru Рассмотрены проблемы выбора идентификаторов данных в распределенной среде. Предложена модель многоалкодовости данных. Рассмотрены как частные, так и общие случаи работы модели. Показано, что использование функций построения алгоритмических кодов возможно не только в моделях асинхронного тиражирования данных с единым алгоритмом построения алко-да, но и в тех моделях, где каждый участник тиражирования использует свой собственный алгоритм построения. Введение В асинхронных распределенных системах каждый участник тиражирования локально работает со своей копией данных в заданный интервал времени, по истечению которого происходит синхронизация изменений, сделанных каждым участником репликации, с разрешением конфликтных ситуаций. Как правило, центром синхронизации выступает отдельный сервер, одним из модулей которого является интеллектуальный сумматор, на «вход» которого поступают измененные данные (дельты), а на «выходе» - суммарная дельта [1, 2]. Каждая дельта содержит следующие данные: • идентификатор записи; • изменения в записи. Идентификатор записи вычисляется для записи, уже подвергнутой изменениям. Одной из проблем моделей асинхронного тиражирования данных является выбор функции получения идентификатора записи. Сложность заключается в том, что изменения, сделанные для конкретной записи в каждом филиале, могут быть различными, а функция построения идентификаторов должна вернуть одно и тоже значение для этой записи у каждого участника тиражирования. Таким образом, необходимо отметить требование к функции построения идентификатора записи: неизменность значения функции при изменении информации в записи, которая не влияет на общий смысл записи. Данное требование представлено в виде равенства: X (НЕС +Д,.) = X (ЯЕС + Д), где X — функция построения идентификатора записи; ЯЕС - запись; Д, Д - /-ые и _/-ые изменения записи. 1. Постановка задачи В данной статье рассматривается функция построения идентификатора записи на основе алгоритмического кода. Под алгоритмическим кодом (алкод) понимается идентификатор документа, который создается по определенным правилам (алгоритму) и однозначно идентифицирует источник [1, 2]. В алкод включаются символы из элементов записи [3, 4] в последовательность, определенной алгоритмом его формирования. При этом построение алкода в автоматизированном режиме осуществляется на основе алгоритма и данных записи. Результатом функции построения идентификаторов на основе алгоритмических кодов будет строка, состоящая из данных, мало подверженных изменению в процессе жизни записи в распределенной среде. Представим функцию построения алгоритмического кода как: Ю = О (А, Я), (1) где Ю - идентификатор записи (алкод); О(А, К) -функция построения идентификатора записи на основе алкода; Л - алгоритм построения алгоритмических кодов; К- запись. Задача создания алкода сводится к построению одинаковых значений Ю для записей одного и того же документа, описанного (созданного, измененного) разными работниками в филиалах участников репликации, но в то же время, к получению различных значений Ю для разных документов. 2. Свойства функции построения алкода Рассмотрим свойства функции О(А, К), где запись К представим как: Я = Е а+Е Ь1 , где К - запись; X а,, X Ь - сумма значимой и до- п т Ю = О (А, Я) = ОI А, X а,- +£ Ь 1 = \ п т У = О(А, Xа, 1 + О(А, ХЬ1= О(А,|, (2) п т О| А,Xа, +ХЬ, | = О| А,Xа, | + О| А,XЬ, |. Ю = О (А, Я) = О X аш, X а + X Ь =X аи ■ \ р п т У р Докажем, что при выполнении свойства линейности результат функции & будет именно таким. = О ( X аш, X а+XЬ, \ р п т 1 ( \ Р X аи , X а + О X аи , X Ь \ Р = О X > Ц1 + ■■■ + ап Л г \ р = О + О X ак > Ь1 + ■■■ + Ьп X' \ р ( + ... + О X' = аи +... + а*р =X ай. Теорема 2.2. Результат функции построения ал-кода неизменен при изменении дополнительной информации, т. е. ( 1 ( 1 О X аи .X а +X Ь = О X а ’X а +X Ь \ р п т у \ р п т Доказательство. ( 1 О X а« -X а +X Ь = О X аъ X а +X Ь полнительной информации. Под значимой информацией понимается та информация из всей информации в записи, которая позволяет однозначно определить запись. Под дополнительной информацией понимается информация, изменение которой не влияет на общий смысл записи, и тем самым не влияет на идентификатор записи. Следовательно, V р У V р 1 ( = О X а« £ а + О X а, £ Ь \ р п у \ р т ( 1 ( ^ О X а, ,у а, + 0 = О X а« X а \ р п У ( Л X аш ,X а \ р п У X а* ,X а \ р п У ( = О Л Xа« £ Ь \ р т = 0, О X а, £ Ь \ р т = 0 следует (В данном утверждении использовалось свойство линейности функции О, которое доказано в теореме 2.1). Учитывая определение алкода докажем следующие теоремы: Теорема 2.1. Функция построения алкода линейна, т. е. где О из (2). Теорема 2.3. Алкоды различных записей различны, т. е. О(А,К1)^О(А,К2). Доказательство. Докажем данное свойство методом от противного. Допустим, что О(Л,К1)=О(Л,К2), тогда ОIА X а +XЬ |=ОIА> Xа +XЬ Доказательство. Из определения алкода следует ( 1 ОI А, X а, | = ОI А, X Это противоречит определению алкода. 3. Функция сравнения алкодов Представим функцию сравнения алкодов в виде: С(О(А1, Я1), О(А2, Я2), А1, А2, Я1), где С - функция сравнения алкодов; 6{Л, Я) -функция получения алкода; Ль Л2 - алгоритмы построения алкодов; Я1, Я2 - записи. Функция в данном виде используется для выяснения, указывает ли алкод 0(Л2, Я2), построенный по записи Я2, на запись Я1, зная о записи Я2 только алкод 0(Л2, Я2) и алгоритм его построения Л2. Введение трех дополнительных параметров Л1,Л2,Я1 позволяет решить проблему сравнения алкодов в случаях, которые будут рассмотрены ниже. В зависимости от аргументов функции сравнения алкодов можно выделить 3 случая. 1. Я1=Я2при ДфЛ2; 2. Я1фЯ2 при Л1=Л2; 3. Я1ФЯ2 и Л1ФЛ2. Рассмотрим каждый случай более детально. Случай 1. Ситуация, при которой Я1=Я2 и Л1^Л2, возможна при использовании модели тиражирования данных в глобальном масштабе, где договориться о едином алгоритме составления алкода крайне сложно. При условии Я1=Я2 и Л1фЛ2 функция получения алкодов (1) вернет различные идентификаторы записей, но функция сравнения алкодов должна быть равна 1, так как Я1=Я2 (из условия), а это возможно благодаря передаче дополнительных параметров Л2,Я1 в функцию. Действительно, при различных алгоритмах построения алкодов, алкоды от равных записей будут различны, т. е. 0(ЛЬ Я1)фО(Л2, Я2). Функция сравнения алкодов, имея Л2 и Я1, позволяет вычислить алкод по алгоритму Л2 для записи Я1, т. е. найти значение 0(Л2, Я1), а так как Я1=Я2, то докажем, что 0(ЛЬ Я1)=0(Л2, Я2) при Я1=Я2 и Л1фЛ2. Теорема 3.1. 0(Л2, Я1)=0(Л2, Я2), при Я1=Я2и Л1фЛ2. Доказательство. О(А2,Ях) = О(А2,Я2) ^ ^оNXа+ХЪ1 =СI а2,Xа2 +ХЪ ^ о у А2, £а) ^ о I а2, Ха 2 где X а) = X а! следует из условия теоремы Я1=Я2, п п следовательно ОI А2, X а) 1= ОКХ а! Более детальное рассмотрение случая Я1фЯ2 при Л1=Л2 дает следующие 4 варианта: 1. Информация записи Я2 включает информацию записи Я1, т. е. Я, Пк) = Xа! ^ Ъ П X а + X Ъ = у П От) у \п гп 2 <П) т ,т 2 <т, у = X а! + X Ъ< ■ п1-П2 т) -т, Так как Я2 = Я1 + X а1 + XЪ, то, учитывая 3 свой- п т ство функции получения алкодов, покажем, что 1Б1ф1Б2, но Ш2 включает в себя Ю1 - это следует из следующего утверждения: Ю) П Ю2 = г II ^ А Xа! +X Ъ ПО А X а! + X Ъ! = О т у = О т, ,т, <т, Случай 2. В рассматриваемом случае, алгоритмы получения алкодов для двух записей равны по условию, поэтому для упрощения далее будем рассматривать вариант функции сравнения алкодов, представленный ниже: С (О( А), Я)), О( А,, Я,)), где С - функция сравнения алкодов; 0(Л, Я) -функция получения алкода; Л1, Л2 - алгоритмы построения алкодов; Я1, Я2 - записи. Таким образом, результатом вычисления разницы двух идентификаторов от записей Я2 и Я1, где информация записи Я2 включает информацию записи Я1, будет идентификатор, содержащий только те элементы записи Я2, которые включены в алгоритм построения алкода. Так как значимая информация записи Я1 полностью содержится в записи Я2 и не конфликтует, т. е. не содержит элементов значимой информации, значения которых расходятся с этими же элементами в другой записи, то С(б(Л1,Я1),б(Л2,Я2)=1. 2. Информация записи Я2 частично включает информацию записи Я1, т. е. Я2 П Я1 = X аг +XЪ! П X а +XЪ = у п1 т1 у у п, т, у = X а + X Ъ! ■ К -п,| |щ-п 2! В данном случае будем рассматривать ситуацию, когда в записях пересекается только значимая информация, так как при равенстве значимой информации и различной дополнительной информации значения функции получения алкодов будут равны по теореме 2.2. Так как алгоритмы получения алкодов идентичны Л1=Л2, вследствие того, что записи не равны, Я1фЯ2, алкоды будут различны, т. е.: 0(Л1, Я1)фО{Л2, Я2) и О(АрЯ1) ф О(АрЯ,) ^ Значение, которое должна вернуть функция сравнения алкодов, зависит от «строгости» практической реализации модели и характера данных. В более строгих схемах вследствие того, что записи содержат различные значения значимой информации, целесообразно использовать следующее значение: С(б(Л1,Я1),б(Л2,Я2)=0. В менее строгих схемах функция сравнения может носить вероятностный характер, значение которой будет колебаться от 0 до 1. 3. Запись Я2 и запись Я1 различны, т. е. Я2 П я1 = X а+X Ъ П X а +XЪ X а +X Ъ + X а +X Ъ В данном случае, так как записи различны, С(0(А1,Я1),0(Л2,Я2)=0. 4. Запись Я2 и запись Я1 совпадают, исключая определенное количество элементов. Данный случай сводится к варианту 2, когда информация записи Я2 частично включает информацию записи Я1. Случай 3. В общем случае Я1фЯ2 и Л1фЛ2. Принцип работы функции сравнения С(0(Л1,Я1), 0(Л2,Я2),Л1,Л2,Я1 в такой ситуации представлен в блок-схеме, изображенной на рисунке, где /(Л1,Л2,Я1,0(Л1,Я1), 0(Л2,Я2),0(Л2,Я1)) - вероятностная функция сравнения алкодов. Рассмотрим представленный в блок-схеме алгоритм более детально: 1. Сравнение алкодов; в случае их равенства принимается решение, что данные алкоды указывают на записи, значимая информация которых равна, следовательно С(б(Л1,Я1),б(Л2,Я2)=1. 2. В противном случае, идет проверка на случай № 1 (Я1=Я2 при Л1фЛ2). Проверка осуществляет- ся вычислением функции получения алкода по алгоритму Л2 для записи Л1. В случае 0(Л1,Я1)=0(Л2,Я1), принимается решение, что данные алкоды указывают на записи, значимая информация которых равна, следовательно С(С(Л1,Я1),С(Л2,Яг)=1. 3. В противном случае, управление передается функции, которая вернет вероятность совпадения записей Л1 и Л2 по имеющейся информации. Обобщая выше приведенные случаи, выделим основные результаты получаемых значений функцией сравнения алкодов при различных условиях: 1. если Л1=Л2, то функция С(0(Л1,Я1),0(Л2,Я2), Л1,Л2,Я1) равна функции С(0(Л1,Я1),0(Л2,Я2); 2. если Л1=Л2, Я1=Я2, то С(0(Л1,Я1),0(Л2,Я2), Л1,Л2,Я1) 1; 3. еслиЛ1фЛ2, Я1=Я2, то С(б(Л1,Я1),в(Л2,Я2),Л1,Л2,Я1)=1; 4. если Л1фЛ2, Я1фЯ2, то значение функции сравнения находится в интервале от 0 до 1, т. е. одлдшл^ямлДНО ,1]. Заключение Рассмотрены проблемы выбора идентификаторов данных в распределенной среде. Предложена модель многоалкодовости данных. Рассмотрены как частные, так и общие случаи работы модели. Показано, что использование функций построения алгоритмических кодов возможно не только в моделях асинхронного тиражирования данных с единым алгоритмом построения алкода (каждый участник тиражирования использует один и тот же алгоритм построения алкода), но и в тех моделях, где каждый участник тиражирования использует свой собственный алгоритм построения, что является актуальным в межкорпоративных моделях тиражирования данных, где использование единого алгоритма не представляется возможным. Рисунок. Блок-схема работы функции сравнения алкодов ]]></text>
</doc>
