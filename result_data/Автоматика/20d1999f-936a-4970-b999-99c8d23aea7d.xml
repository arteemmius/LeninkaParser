<doc>
  <source auto="true" type="str" verify="true"><![CDATA[https://cyberleninka.ru/article/n/algoritm-postroeniya-dereviev-shteynera]]></source>
  <category auto="true" type="str" verify="true"><![CDATA[Автоматика]]></category>
  <author auto="true" type="list" verify="true">
    <item type="str"><![CDATA[Калашников В.А.]]></item>
    <item type="str"><![CDATA[Анисимов А.А]]></item>
  </author>
  <title auto="true" type="str" verify="true"><![CDATA[Алгоритм построения деревьев Штейнера]]></title>
  <keywords auto="true" type="list" verify="true"/>
  <annotation auto="true" type="str" verify="true"><![CDATA[]]></annotation>
  <text auto="true" type="str" verify="true"><![CDATA[Введение При решении сложных задач выбора, таких как построение кратчайших связывающих деревьев, человек имеет преимущество перед ЭВМ в том, что касается выбора решения из большого круга возможных. Однако что касается внимания, то в этом человек существенно проигрывает. Логично предположить, что постараться “научить” машину “думать” по аналогии с человеком проще, чем научить человека запоминать с таким же качеством как это делает машина. И именно поэтому в данной статье будет описан один из алгоритмов, при разработке которого сделана попытка наделения машины человеческими качествами. 1. Постановка задачи Задача трассировки формулируется следующим образом: по заданной схеме соединений положить необходимые проводники на плоскости (плате, ТЭЗ, кристалле и т.п.), чтобы реализовать заданные электрические соединения с учетом заранее созданных соединений [1]. В свете выше изложенного наиболее перспективным подходом к решению задачи трассировки является тот, при котором комплексно решаются следующие взаимосвязанные задачи. 1. Разработка способов предварительного упорядочивания цепей и их контактов перед трассировкой. 2. Алгоритмизация методов оптимального назначения строящихся проводников на слои МП. 3. Совершенствование и развитие алгоритмов синтеза токопроводящих соединений. 4. Исследование и разработка методов доразводки цепей в автоматическом или интерактивном режимах. Исходные данные для трассировки определяются при составлении исходного задания на проектирование, дополняются и/или видоизменяются после выполнения операций компоновки. После обработки, обычно эта операция выполняется различными экстракторами, входная информация представляется следующими компонентами: списком трассируемых контактов и моделью представления МП в ЭВМ. Ниже описанный алгоритм относится к эвристическим алгоритмам [2] - [5]. 2. Описание алгоритма На данном этапе развития технологии наиболее предпочтительным для цепей схемы является кратчайшее ортогональное штейнеровское дерево. Требование ортогональности обусловлено тем, что при решении задачи машиной данный вариант является наиболее Доступным в виду его наибольшей типизированности. Поэтому, далее речь будет вестись только об ортогональных деревьях. Рассмотри основные этапы построения данных деревьев Для цепей схемы 2.1. Подготовительный этап После размещения элементов на поле коммутационной платы имеется список координат йеРШин для каждого Г° (¡=(1Ып), где п - количество цепей) дерева Ц’=(У|,У2, ...,уи}, где к| количество вершин принадлежащих ¡ому дереву. Для повышения качества трассировки Испольэуется сортировка ребер данного дерева. Можно осуществлять сортировку по различным критериям, в том числе и по нескольким вводя функцию веса но наил\дшше результаты, как правило, получаются при сортировке по критерию длинны ребра а поскольку деревья ортогональные, то следует использовать значения прямоугольной длинны ГМ л™ просмотра всех возможных вариантов соединений на предмет поиска кратчайшего пео^а необходимо составить полную матрицу связей, а точнее ее половину М ’={т дерева где Ш|к - вес ребра связывающего и к™ вершины. Очевидно т''2.... сторону возрастания, так чтобы, ребро с минимальным весом было пеТвы^^Гке” поскольку если сразу же построить ребро с большим весом Й чип.» 1-писке, о числе первых оно может существенно удлинить связи других деревьев. А для того, чтобы исктппи,™ для всех деревьев следует выбирать ребро с минимальным весом ш ТаКуЮ СИ1Уацию М’={М|, М2, М„}. Исходя из вышеизложенного на подготовительном этапе° М“°ЖеСТВа получить динамически изменяемый кортеж М=<М|,М7, М > __ необходимо .. " " элементы котсюого также являются кортежами М„ и М,=<та1ь, Шс.,,, где т.ь=(у V 1 минимальный вес среди всех ребер всех деревьев. *’ Ь рворо имеющее Далее следует алгоритм, по которому выполняется данная операция-('"Формирование кортежа М*) 1=0; цикл для 1 пока не закончились цепи начало цикла .N0; цикл для j пока не закончились вершины; считать] вершину и добавить к а=1; цикл для а до] начало цикла Ь=а+1; 1=0; цикл ДЛЯ Ь ДО ] начало цикла 1=1+1; связи d(vB,vb); РЗССЧИТаТЬ "Р^ольную длину координаты точек Ь v 1 ; i занести в М|’как ш,ь; *’**'’ 'Хь’Уь1 и d(v„vb) конец цикла; конец цикла; выполнить сортировку Mi’ по возрастанию d; (* М-’ЩМ добавить Mj в М; 1 " 1 * конец цикла. Следует отметить, что алгоритмы трассировки разработаны уже поэтому можно использовать уже существующий модиАициппвяии^л достаточно хорошо и [6]. пузырьковый алгоритм После выполнения данной операции будет получен кортеж М 2.2. Нахождение точек Штейнера При построении штейнеровского дерева возможно введение что существенно усложняет построение дерева, но уменьшает ДОПОЛНИТельных вершин, постановке задачи (см. разд.1) ничего не сказано о невозможности ^ ДЛИНу‘ ПосколькУ в точек в граф схемы, то мы можем дополнить задачу до штейнеоо ВВдДения Дополнительных задачи для отдельного дерева будет выглядеть следующим образом- ПрИ ЭТ0М постановка точек {xi,x2, х„} плоскости построить кратчайшее покрывающее 3адан”ого множества [1]. Ближайшую точку Штейнера можно найти различными тт Дерево с п’^п вершинами ЯМи’ например, для решения этой задачи существует алгоритм Ханана [ 1 ], но в данном случае наиболее предпочтительным представляется способ сканирования плоскости на предмет искомого соединения. При нем совсем не обязательно просматривать все точки I, достаточно пустить волну поиска из точки источника в точку приемник, поскольку нам известны координаты обеих точек, то цикл поиска будет конечным. После поиска из первой точки следует провести поиск из второй или, если найдена точка Штейнера, то из нее. При этом возможно существенное сокращение связи (см. рис. 2.1). Поскольку дерево ортогонально можно производить поиск по отрезкам находящимся под углом 45 LJ к основным осям (см. рис. 2.2), что при программной реализации даст существенный выигрыш во времени, поскольку не надо будет вычислять тригонометрические функции sin и COS. При этом поиск точек Штейнера будет динамическим, то есть будет учитывать ранее Д Точке Штейнера □ Вершина дерева —. Фронт волны поиска » Направление поиска РИС. 2.1 Фрагмент обычного И штейнеровоого деревьев Рис 2 2 Примвр поиска точвк Сейнере проведенные СВЯЗИ. Следует отметить, что данный способ предполагает избыточность связей представляемых к соединению, поэтому в алгоритме обязателен блок исключения циклов. Для этого достаточно перед тем, как осуществлять поиск точек Штейнера проверить связность точек, если они связаны, то связь вообще можно опустить, а поскольку до текущего момента строились более короткие связи, то проверку на предмет более качественного проведения при построении данного ребра можно также не делать в виду того, что текущая связь заведомо длиннее ранее проведенных. При входе в данный блок алгоритма необходимо иметь координаты двух точек: <Х|,у|> и <Х2,У2>, которые являются конечными точками ребра. Для того чтобы отличить цепи которые необходимо соединить от остальных цепей их необходимо “покрасить” в определенные цвета. При чем данные точки окрашиваются в разные цвета: цвет цепи "источника”, далее источник, и цвет цепи - "приемника”, далее приемник. На данном этапе проверяется связность этих точек, и если точки уже связаны, то дальнейшие операции не выполняются. Для “раскрашивания” цепей используется алгоритм восьмисвязной заливки, который будет описан ниже. Ниже приводится, собственно, сам алгоритм блока. ("■Нахождение точек Штейнера*) Заливка (Х|,у1, источник); если цвет(х2,у2)й источник тогда начало заливка (х2,у2,приемник); поиск ближайшей (Х],уь приемник); поиск ближайшей (х2,у2, источник); проведение связи (х1,у1,х2,у2); конец; восстановление исходного цвета; Операция проведения связи будет рассмотрена в следующем пункте, а операция поиска ближайшей точки будет рассмотрена ниже. В ниже следующий алгоритм необходимо предать координаты точки от которой надо начинать поиск и цвет связи, которую необходимо искать. Пусть координаты переданных точек х и у, а цвет - обозначим как “искомый”. v /v\ (*Найти ближайшую*) ближайшая_х=0; ■ ближайшая_у=0; г=0; пока ближайшая_х=0 и ближайшая_у=0 начало цикла г=г+1; 1=0; цикл для 1 до г начало цикла №пра!„, И1Вче если (х-1)<0 тогда 1шх=0 иначе гп1х =х 1- ОТв т^лраю,_у.| если (у+1-г)<0 тогда ппу=0 иначе гту=у+]-г если цвет(тах,шау)=искомый то начало ближайшаях=шах; ближай шая_у=шау; конец; если ивет(1тйх,тау)=искомый то начало ближайшая_х=1гпх; ближайшая_у=тау- конец; ’ если цвет(тах,т1у)=искомый то начало ближайшая_х=тах; ближайшая_у=щ1у’ конец; если цвет(гшх,1ту)=искомый то начало ближайшая_х=ш!х; ближайшая_у=т,у.’ конец; конец цикла; конец цикла; В алгоритме поиска точек Штейнера используется <Ьтт»о „ пункция восьмисвязной заливки. 2.3. Проведение связи На данном этапе возможно использование волнового алгоритм условии нахождения Штейнеровских точек он требует слишком б ’ но ДйЖе при времени решения. Лабиринтные алгоритмы не дают качественнойЛЬШИ* °бъемов памяти и разбивают задачу на более мелкие, которые все равно решаются т раЗВ0ДКИ’ а канальные -наиболее разумным было бы проанализировать действия человекаМИ *в алгоритмами- Здесь постараться ввести в алгоритм элемент «интуитивности». в различных ситуациях и Для проведения связей были испробованы различные алгоритмы СЛИШКОМ большого времени ДЛЯ своей работы, либо не удовлетв ’ Н0 0НИ ЛИб° ТРебоваЛИ памяти. Выбор пал на алгоритм с эвристическим методом обРЯЛИ П° ТребуемомУ объему алгоритм требует небольших затрат памяти и обладает доста*0^ препятствий- Данный Возможен рекурсивный вариант данного алгоритма но он тпрй, « ЧН0 ВЬ1С0К0Й скоростью. тр бует больших затрат памяти при программной реализации, поскольку, при каждом вызове функции-потомка переменные функции-предка записываются в стек и при большой глубине рекурсии происходило переполнение стека. По этим причинам был разработан следующий алгоритм: (* проведение связи*) и=х; *у=у; пока йсШх и 1уШу начало цикла если 1хих или преграда=истина тогда движение по х; если 1уС!у или преграда=истина тогда движение по у; конец цикла; Данный алгоритм использует процедуры движение по х и движение по у. Поскольку они идентичны, то достаточно описать алгоритм одной из них: (*движение по х*) флаг-истина; <1х=0; если преграда=истина тогда начало <1уу=0; если цвет (Ъс,1у+2)=цвет преграды тогда <1уу:=2; если цвет (1х,1у-2)=цвет преграды тогда <1уу:=-2; у=0; положительный флаг=ложь; отрицательный флаг=ложь; запрет отката=ложь; пока флаг=истина начало цикла у=у+1; если положительный флаг=ложь и цвет(1х+у,1у)=преграда тогда если запрет отката=истина тогда начало преграда=истина; флаг=ложь; соединить (1х,1у,1х+у+2,1у,цвет связи); 1х=1х+у+2; конец иначе положительный флаг=истина; если положительный флаг=ложь и цвет (1х+у,1у)=цвет связи тогда начало положительный флаг=истина; запрет отката=истина; конец; если отрицательный флаг=ложь и цвет(1х-у,1у)=преграда тогда если запрет отката=истина тогда начало преграда^истина; флаг=ложь; соединить (Ьс^.Ьс-у-г^.цвет связи); 1х=1х-у-2; конец иначе отрицательный флаг=истина; если отрицательный флаг=ложь и цвет Ох-уДу)=цвет связи тогда начало отрицательный флаг=истина; запрет отката=истина; конец; если положительный флаг=ложь и цвет(1х+у,1у+(1уу)=пусто тогда начало соединить (1х,1у,1х+у+1,1у, цвет связи); 1х=1х+у+ 1; преграда=ложь; флаг=ложь; конец; если отрицательный флаг=ложь и цвет(1х-у,гу+ёуу)=пусто тогда начало соединить (1х,1уДх-у-1,1у, цвет связи); 1х=1х-у-1; преграда=ложь; флаг=ложь; конец; конец цикла; конец иначе если 1х<х| тогда dx=l иначе dx—1; если dxoO тогда пока флаг=истина начало цикла tx:=tx+dx; если цвет(Ъс,1у)=преграда тогда начало преграда=истина; флаг=ложь; точка (ич1х,1у,пусто); 1х=1х^х; конец иначе точка(1х,1у,цвет связи); если Х1=ЧХ тогда начало флаг=ложь; точка(Чх,1у,цвет связи); конец; конец цикла; В этой части алгоритма положительный и отрицательный флаги запрета запрещают движение в соответствующие стороны, а флаг запрета отката в сочетании с соответствующим флагом говорит о том, что помимо запрета в одну из сторон, там еще и находится ранее проведенная эта же связь. Это возможно в том случае если нижняя часть блока дошла до tx=xi, но связь по у натолкнулась на препятствие. 2.4. Реализация на языке структурного программирования Borland Pascal 7.0 Как было сказано выше этапе подготовки данных необходимо получить кортеж М из исходного массива данных V. Не взывает ни каких сомнений то, что исходные данный должны храниться на внешнем носителе в файле, следовательно этот файл должен быть каким-то образом структурирован. Наиболее предпочтительной в данном случае представляется структура записи из двух членов. На языке Borland Pascal данная запись будет описываться следующим образом: infile=record x:xtype; y:ytype; end; Здесь xtype и ytype - типы, которые должны быть описаны ранее следующим образом: xtype=-l..l 120; ytype=-l..l 120; Параметр 1120 взят из условия максимально-возможного размера печатной платы, который, как будет видно далее, ограничен аппаратными возможностями. Следует также описать тип данных для кортежа M¡, который является составной частью М: mas=record x,a:xtype; y,b:ytypc; l.ltype; end; ltype - прямоугольная длинна ребра между точками с координатами (х, у) и (а, Ь), которая также должна бьггь описана ранее следующим образом. ltype=0..2240; Верхний предел длинны - максимальная длинна связи. В виду ограничений накладываемых реальным режимом функционирования программы максимальное количество вершин в цепи - 110. Следовательно максимальный размер кортежа М, как говорилось ранее, 1102/2=6050. Поэтому его можно описать как линейный массив, это будет выглядеть следующим образом: matr:array [0..6050] of mas; В последствии данный массив будет использован для хранения первых элементов стеков Цепей, поэтому верхний предел количества цепей - 6050. Для оценки необходимого объема памяти воспользуемся методом крайнего пессимизма, то есть возьмем наихудший случай 6050 цепей по 110 точек в каждой. Требуемый объем памяти в данном случае можно подсчитать следующим образом: V = V3n * т * п, где V3„ - объем памяти занимаемый одним элементом массива; тип- размерности массива. Одна запись типа mas занимает в памяти 5 слов, 1 слово = 2 байта, следовательно У]Л=10 б- Как было сказано выше т=6050, а п=110, следовательно V = 10 * 6050 *110 = 66550006 что составляет примерно 6.35 Мб. Естественно, что хранить такие объемы данных в оперативной памяти не всегда Целесообразно, тем более, что одновременно могут быть востребованы только первые элементы кортежей M¡, следовательно можно использовать внешний носитель - жесткий диск. Временный файл должен быть структурой типа LIFO, однако стандартными средствами DOS данная структура файла не доступна, поэтому для такой организации требуется специальная функция, которая будет ее организовывать. Далее следует организовать в памяти область отображающую коммутационное пи паЧиАТПОШ.! Швивити ЛТТ11в1РЛ гтн _______________ « ■' цпиппис поле на котором размещены элементы, однако при рассмотрении областей паи данных целей наиболее удобной представляется область вилепп»» *"* пригодных для причинам: Деопамяти по следующим •наглядность - результаты работы алгоритма сразу же видны пользователю-•хорошая организация - нет необходимости организовывать переадД™ из двумерного массива в одномерный, это сделано на аппаоатнпм ^адресацию из быстрее; ‘паратном уровне, что намного •нет необходимости занимать базовую память котопая и для хранения промежуточных данных. ’ °жет использоваться Однако при всех описанных достоинствах данного решения есть недостаток - уменьшение скорости, ведь доступ к периферийным устрой °ДИН существенный видеокарта, осуществляется через более медленный канал мезо СТВам’ каким является современных скоростях обмена через каналы (для реальных сов ШИНУ- Но ПРИ минимальная скорость обмена у шины КА-16 теоретически составеМеННЫХ компьютеРов реально она меньше в два раза из-за прерываний, регенерации и тюВЛЯет 16 Мб/С> однако запросах профаммной реализации алгоритма на скорость передачи л °К0ЛЬНЫХ процедур) и существенен. Далее можно приступать, собственно, к самой тпягптаННЫХ ЭТОТ недостаток не описаны выше. Ч*ссировке, алгоритмы которой 3. Пример работы алгоритма При проектировании программы производилось большое колич с различными расположениями вершин. Для генерации псевдослучай еСТВ° тестовых запусков координат вершин и записи их в файл использовалась НЫХ последовательносте^ псевдослучайного набора вершин, которая генерирует исхолниа /к,м^5°г*>амма генератор 2 Пт вершин в каждой. содержащий п цепей по Ниже приведены результаты построения Штейнеровских депев четырех цепей (рис. 3.4). На основании проведенных экспериментов ^ 0ДН0Й ^Рис- 31) и проведенных связей составляет 5-10% от общего. Роцентное отношение не L Л 1 рис. 3.5 Одиночное рис. 3.6 Четыре дерева дерево ]]></text>
</doc>
