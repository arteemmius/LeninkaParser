<doc>
  <source auto="true" type="str" verify="true"><![CDATA[https://cyberleninka.ru/article/n/razrabotka-geneticheskogo-algoritma-klasternogo-planirovaniya-sbis]]></source>
  <category auto="true" type="str" verify="true"><![CDATA[Автоматика]]></category>
  <author auto="true" type="list" verify="true">
    <item type="str"><![CDATA[Ерошенко Илья Николаевич]]></item>
  </author>
  <title auto="true" type="str" verify="true"><![CDATA[Разработка генетического алгоритма кластерного планирования СБИС]]></title>
  <keywords auto="true" type="list" verify="true">
    <item type="str"><![CDATA[ПЛАНИРОВАНИЕ СБИС]]></item>
    <item type="str"><![CDATA[ГЕНЕТИЧЕСКИЙ АЛГОРИТМ]]></item>
    <item type="str"><![CDATA[ОБОБЩЕННАЯ ПОЛЬСКАЯ ЗАПИСЬ]]></item>
    <item type="str"><![CDATA[КЛАСТЕРИЗАЦИЯ]]></item>
  </keywords>
  <annotation auto="true" type="str" verify="true"><![CDATA[Рассматривается проблема планирования сверхбольших интегральных схем. Во введении обоснована актуальность задачи. Приведено описание представления плана в виде обобщенной польской записи. Также дано описание структур хромосом, принципов их кодирования/декодирования. Разработаны генетические операторы и схема поиска. Приведен псевдокод генетического алгоритма планирования.]]></annotation>
  <text auto="true" type="str" verify="true"><![CDATA[Рассматривается проблема планирования сверхбольших интегральных схем. Во введении обоснована актуальность задачи. Приведено описание представления плана в виде обобщенной польской записи. Также дано описание структур хромосом, принципов их кодирования/декодирования. Разработаны генетические операторы и схема поиска. Приведен псевдокод генетического алгоритма планирования. Планирование СБИС; генетический алгоритм; обобщенная польская запись; кластеризация. I.N. Yeroshenko THE DEVELOPMENT OF GENETIC ALGORITHM FOR CLUSTERED FLOORPLANNING The article is dedicated to the problem of VLSI floorplanning. The description of floorplan in the form of generalized polish expression (GPE) is given. Genetic algorithm for GPE has been chosen as a search engine. The principles of chromosomes coding and decoding, genetic operators, genetic search scheme are proposed in this paper. The principles of clustering are mentioned. The pseudo-code of genetic algorithm is given. VLSI floorplanning; genetic algorithm; generalized polish expression, clustering. Введение. Планирование СБИС заключается в размещении на поле кристалла непересекающихся блоков, имеющих форму прямоугольников. Основной целью оптимизации является минимизация общей площади кристалла. Данная задача является одним из ранних этапов конструкторского проектирования СБИС и относится к классу NP. Планирование влияет на размеры, производительность чипа. В течение последних лет были предложены различные подходы к решению проблемы планирования. Они отличаются постановками и моделями. В качестве поискового механизма при планировании чаще всего используют метаэвристики, основанные на моделировании отжига (simulated annealing, сам планировщик при этом называется аннилером), и генетические алгоритмы (ГА). Аннилеры работают с одним решением (результат во многом зависит от качества начального решения), а ГА с популяцией решений. Структуры данных, используемые в качестве представлений плана, зачастую сложны для обработки. Поисковые механизмы, задействованные в алгоритмах планирования, не всегда учитывают специфику задачи. Поэтому построение более совершенных моделей является актуальным. В данной статье представлен генетический алгоритм, в основу которого положен механизм многоуровневой эволюции, описанный в работе [1], а кластеризация применяется при входных данных большой размерности. Итак, при создании планировщика СБИС необходимо учитывать следующие аспекты: 1. Представление плана (обобщенная польская запись использована в качестве структуры данных). 2. Поисковый механизм (генетический поиск взят за основу). * Работа выполнена при поддержке: РФФИ (гранты № 10-01-00115, № 10-01-90017-Бел_а), г/б № 2.1.2.1652. Рассмотрим их подробнее. Представление плана «обобщенная польская запись». В литературе представлены два класса планов: гильотинные и негильотинные. План гильотинного типа получается путем рекурсивного деления прямоугольника с помощью вертикальных и/или горизонтальных гильотинных разрезов. Такой план удобно отображать в виде бинарного дерева разрезов, у которого внутренние вершины представляют разрезы, а листья - модули. Дерево кодируется с помощью польской записи (PE - Polish Expression). В общем случае, негильотинное представление имеет большее пространство решений и позволяет добиться более компактного расположения модулей по сравнению с гильотинным планом. В работе [2] представлена схема кодирования GPE (аббревиатура для Generalized Polish Expression). Она является обобщением для польской записи. GPE позволяет эффективно задействовать некоторую область, которая не может быть использована при наличии операторов вертикального и горизонтального разрезов, определенных в польской записи. Благодаря введению нового оператора, возможно представлять план СБИС с негильотинным разрезом. Помимо реляционных операторов V и H в GPE внедрен третий тип оператора - @ (угловое отношение). Угловой оператор @ поместит модуль или супермодуль в углу, сформированном другими модулями. Запись вида @(bc) означает, что нужно поместить текущий модуль/супермодуль в угол справа от b и выше c. Рассмотрим подробнее схему декодирования GPE. Процедура декодирования GPE показана на рис. 1. Рис. 1. Формирование плана для ОРЕ = {bd + g * к + с @ аг/ + * @} ОРБ обрабатывается последовательно слева направо. Сначала, для {Ь ё Н}, модуль ё будет помещен над модулем Ь, сформируется первый элемент списка углов - {ё-Ь}. Для {Ь ё Н g V} модуль g помещается справа от супермодуля {Ь ё Н}. Список углов модифицируется (замена {ё-Ь} на {ё^}, так как для экономии памяти и эффективности расчетов должна поддерживаться выпуклость углов). Затем для {Ь ё Н g V Ь Н} модуль Ь располагают над супермодулем {Ь ё Н g V}. Список углов становится {Ь-ё^}. Когда для {Ь ё Н g V Ь Н с @} встречается оператор @, необходимо выбрать один подходящий угол для модуля с на основе следующей эвристики: (1) выбрать такой угол, в который модуль может быть полностью помещен или (2) выбрать такой угол, у которого помещение модуля не приведет к увеличению площади плана. Если вставка модуля в каждый угол может увеличить план, то тогда выбирается любой угол. В данном примере выбирается угловое ограничение (ё^) для первого оператора @, угловой список становится {Ь-с^}. Процесс свертки продолжается схожим образом до очередного оператора @. Снова необходимо выбрать эвристически один угол из списка {Ь-с^}. Для второго оператора @ выбирается ограничение (Ь,с). Процесс декодирования завершен. В качестве представления плана была выбрана структура ОРБ, так как она относительно проста (связана с бинарным деревом), при этом может отображать планы негильотинного типа. Генетический алгоритм. В данном разделе рассматриваются процедуры генетического поиска для решения задачи планирования на основе обобщенной польской записи. В генетических алгоритмах используется эволюционный подход, они относятся к классу эволюционных вычислений (ЭВ). ЭВ представляют собой совокупность алгоритмических, программных, аппаратных средств и приближенных эвристических методов, основанных на имитации механизмов эволюции для синтеза структур обработки данных, а также на статистическом подходе к исследованию ситуаций и итерационном приближении к искомому решению [3]. Идеи эволюции и самоорганизации оказались плодотворными на практике. В моделях и алгоритмах ЭВ ключевым элементом конструкции являются построение начальной модели и правил, по которым она может изменяться (эволюционировать) [4]. Г енетические алгоритмы оперируют с популяцией решений. Гибкость структуры генетических алгоритмов, возможность настройки множества параметров позволяют получить более высокие результаты по сравнению с другими методами. Для более полного учета специфики планирования в данной работе решение представлено не одной, а несколькими хромосомами: 8 = {Н1, Н2, Н3, Н4}. Хромосома Н1 кодирует разметку модулей, Н2 определяет структуру бинарного дерева, а Н3 содержит информацию о типах внутренних вершин дерева (операторы разрезов и угловой оператор), Н4 описывает ориентацию модулей. Пусть п - число модулей. Тогда размеры хромосом Н1, Н2, Н3 равны п-1, а размер хромосомы Н4 равен п. Каждый ген g1 хромосомы Н1 принимает значение от 1 до (п+1-1). Пример: п = 4, тогда 1^<4, 1^2<3, 1^3<2. Декодирование хромосомы Н1 производится путем последовательного анализа генов хромосом, выбора элементов опорного вектора В, записи в порядке выборки в итоговый вектор разметки Q. Пример: пусть для п = 4 имеется хромосома вида Н1 = <2,1,2>, опорный вектор В1 = <1,2,3,4>, вектор разметки Q (первоначально пустой). gl = 2, тогда в В1 выбирается 2-й элемент, записывается ql = Ь:2 = 2 в Q. Элемент Ь:2 удаляется, получается вектор В2 = <1,3,4>. g2 = 1, тогда в В2 выбирается 1-й элемент, записывается q2 = Ь21 = 1 в Q. Элемент Ь21 удаляется, получается вектор В3 = <3,4>. gз = 2, тогда в В3 выбирается 2-й элемент, записывается q3 = Ь32 = 4 в Q. Элемент Ь32 удаляется, получается вектор В4 = <3>. Наконец, q4 = Ь4ь Каждый ген g1 хромосомы Н2 принимает значение от 1 до (п-1). Пусть дан алфавит А={Х,*}. Структуру бинарного дерева можно задать, используя на базе алфавита А польское выражение для бинарного дерева, где Х соответствует листьям дерева (областям), а * - внутренним вершинам дерева (операторам V, Н, @). Польское выражение для дерева, представленного на рис. 2, имеет следующий вид: ХХ*ХХ*Х**. Рис. 2. Бинарное дерево Число Х-элементов ОПЗ обозначим через пх, а через п* - число *- элементов. Для бинарного дерева выполняется равенство: пх=п*+1. Первый знак * в ОПЗ (при просмотре слева направо) может появиться только после двух знаков Х. Пронумеруем позиции между знаками Х, как показано на рис. 3. Рис. 3. Схема ОПЗ Максимальное число знаков *, которое может появиться в позиции, равно номеру позиции. Если ОПЗ соответствует перечисленным свойствам, то ему соответствует бинарное дерево. Польская запись строится в результате декодирования хромосомы Н2. Значение гена указывает номер позиции в ОПЗ, в которую необходимо поместить знак *. Рассмотрим пример. Пусть имеется для п*=4 (число модулей п=5) хромосома вида Н2=<2,2,4,4>. ОПЗ будет иметь вид (рис. 4): хх!х_А х!х_* * Рис. 4. ОПЗ хромосомы Н2 С помощью хромосомы Н3 задаются типы операторов (Н^, @). Значением гена является 0, 1 или 2 (флаг 0 - Н-разрез, флаг 1 - V-разрез, флаг 2 - угловой оператор @). Разметка внутренних вершин осуществляется последовательно в порядке расположения знаков * в ОПЗ. Хромосома Н4 определяет ориентацию модулей. Если g1 = 0, то высота прямоугольного модуля больше его ширины, при g1 = 1 высота меньше, либо равна ширине. Декодирование хромосом имеет оценку трудоемкости О(п), где п - число модулей. Пространственная сложность для одного решения имеет оценку О(п). В работе используются два типа оператора кроссинговера: К1 и К2 [1]. При помощи К1 можно получить новые решения путем комбинирования составами хромосом родительской пары. Для этого необходимо задать специальный параметр - Рк1 (вероятность кроссинговера). Осуществляется последовательный просмотр хромосом Н1-Н4, и с вероятностью Рк1 производится обмен гомологичными хромосомами родительской пары. С помощью К2 новые решения образуются путем обмена гомологичных хромосом гомологичной пары. Задается параметр Рк2 - вероятность кроссинговера. Последовательно просматриваются локусы хромосом. С вероятностью Рк2 производится обмен гомологичными генами. Комбинированный кроссинговер реализуется следующим образом. Выбирается первичная родительская пара Ю и Я2. Производится кроссинговер типа К2. Образуется дочерняя пара Ю’ Я2’. Получившуюся пару следует рассматривать как вторичную родительскую, к ней применяется оператор кроссинговера К1 (обмен на уровне целых хромосом). В итоге появляется пара Ю’’ и Я2’’ как результат последовательного использования операторов кроссинговера К2 и К1. Оператор мутации выполняется следующим образом. Задается параметр Рм -вероятность мутации. Просматриваются последовательно локусы хромосом решения. С вероятностью Рм осуществляется мутация гена в текущем локусе. Мутация заключается в принятии геном случайного значения из заданного диапазона значений для гена в данном локусе. В основу селекции для выбора родительской пары хромосом положен «принцип рулетки». В соответствии с этим принципом для всех решений рассчитывается вероятность выбора на основе значений фитнеса. На каждом і-м этапе осуществляется генетический поиск путем модификации хромосом, входящих в заданный для этого этапа набор ЫН модифицируемых типов хромосом (рис. 5). Это означает, что в полном объеме используется кроссин-говер К1, заключающийся в комбинировании наборов хромосом, входящих в решение, а кроссинговер К2 и мутация применяются только к тем хромосомам, которые входят в набор типов модифицируемых хромосом. Рис. З. Последовательный подход На рис. 6,а представлен псевдокод алгоритма планирования, реализующий последовательный подход. С помощью процедуры НАЧ_ГЕНЕРАЦИЯ(задача, генетика) осуществляется генерация популяции Пн. На каждом шаге производится обработка особей популяции (всего С шагов). В соответствии с текущим набором типов модифицируемых хромосом происходит эволюционирование популяции. На рис. 6,б приведен псевдокод алгоритма генетического поиска, реализованного в каждом узле последовательной структуры. Алгоритм ПЛАНИРОВАНИЕ; Процедура ЭВОЛЮЦИЯ (попул,наборы[1]) begin begin задача := ИСХОДНЫЕ_ДАННЫЕ; Т := ЧИ СЛ 0_П0 КО Л ЕН И Й; генетика := НАСТРОЙКА; while Т > 0 do попул :* НАЧ_ГЕНЕРАЦИЯ(5адача.генетика); { С:« ЧИСЛО_ШАГОВ; кросс_лопул ;■ 0; SEQN :* ДЛЙНА_ПОСЛЕДОВАТЕЛЬНОСТИ; мут_попул ;■ 0; К :* 1; L:« число_кросс; фитнес := РАСЧЕТ(попул, генетика); while L > 0 do while К <* С do < { род_пара := ВЫБОР(попул, фитнес, генетика); I;* 1; доч_пара := КРОСС_2(род_пара,наборы[1]ггенетика); наборы :« BW60P_HA60P0B(SEQN); доч_пара := КРОСС_1 (доч_пара, генетика); while I <- SEQN do кросс_попул := ВКЛЮЧИТЬО^росс.попул, доч_пара); { 1 :* L”l; ЭВОЛЮЦИЯ (попул.наборыЮ); }; I:-1 + 1; тек_попул := ОБЪЕДИНИТЬ(попул, кросс_попул); >; муг_попул := МУТАЦИЯ(тек_попул,наборы[1].генетика); КК ♦ 1; тек_попул ;= ОБЪЕДИНИТЬ(тек_попул, мут_попул); }; фитнес := РАСЧЕТ(тек_попуп, генетика); end. лучш_реш :* ВЫДЕЛИТЬ(тек_попул, фитнес); попул :■ СЕЛЕКЦИЯ(тек_попул, фитнес); Т:«Т-1; >: end. а б Рис. 6. а — псевдокод алгоритма планирования; б — псевдокод процедуры ЭВОЛЮЦИЯ На каждой генерации (число генераций Т) последовательно реализуются операторы кроссинговера и мутации. Популяция становится временно расширенной, а после редукции уменьшается до начального размера. Операторы кроссинговера К2 и К1 выполняются Ь раз. Каждый раз выбирается родительская пара (по принципу рулетки). Сначала выполняется оператор К2, учитывающий типы модифицируемых хромосом в текущем наборе. Потом пара дочерних особей обрабатывается оператором К1 на хромосомном уровне. В итоге в коллекцию кросспопул попадает пара особей после последовательного выпол- нения операторов K2 и K1. По окончанию кроссоверного цикла популяции попул и кросс попул объединяются в тек попул. Затем хромосомы подвергаются мутации с заданной степенью вероятности, образуются мутанты. Процедура ОБЪЕДИНИТЬ(тек_попул, мут_попул) мутанты присоединяются к текпопул. Процедура РАСЧЕТ(текпопул, генетика) определяет фитнес для новых особей. Запоминается лучшее решение. В конце реализуется процесс «естественного отбора» (редукция популяции). Кластеризация. Для того, чтобы повысить эффективность планирования, можно воспользоваться принципом "разделяй и властвуй". Исходные модули группируются в кластеры. Каждый кластер имеет заданный размер (максимальное число объектов, которое он должен объединять). Кластеры могут интегрироваться в кластеры более высокого уровня. ГА применяется к каждому кластеру. Кластеризация может быть простейшей (когда не учитываются характеристики модулей), а также направленной (когда модули сортируются на основе их геометрических параметров. Группировка модулей, у которых разница по площади невелика, является эффективной при кластерном планировании (тогда мертвая зона может получиться меньше). Важно отметить, что эффективность кластеризации лучше проверять на задачах большой размерности. Заключение. Благодаря совместному использованию подходов, предложенных в работах [1,2], создан прототип кластерного планировщика, который использует механизм генетического для поиска субоптимального плана, представленного в виде довольно простой и эффективной структуры GPE. Разработанные многохромосомные структуры отличаются простотой декодирования и гомологичностью, что облегчает выполнение генетических операторов и упрощает организацию поиска. Необходимо отметить, что при генетическом поиске реализуются случайные изменения, а для нахождения глобального оптимума нередко надо определить цепочку «осмысленных» изменений. Поэтому повысить качество получаемых решений можно за счет внедрения дополнительных эвристик. Предлагаемый в данной статье алгоритм планирования СБИС на основе эволюционного подхода находится в стадии разработки. Предполагается дальнейшее развитие (учет дополнительных физических ограничений) и реализация данного алгоритма (как программы-планировщика), а также проведение серии тестов для изучения характеристик и экспериментального определения его временной сложности. ]]></text>
</doc>
