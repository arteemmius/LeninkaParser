<doc>
  <source auto="true" type="str" verify="true"><![CDATA[https://cyberleninka.ru/article/n/proektirovanie-samotestiruemyh-sbis-s-primeneniem-metoda-geneticheskogo-poiska]]></source>
  <category auto="true" type="str" verify="true"><![CDATA[Автоматика]]></category>
  <author auto="true" type="list" verify="true">
    <item type="str"><![CDATA[Родзин С.И.]]></item>
  </author>
  <title auto="true" type="str" verify="true"><![CDATA[Проектирование самотестируемых СБИС с применением метода генетического поиска]]></title>
  <keywords auto="true" type="list" verify="true"/>
  <annotation auto="true" type="str" verify="true"><![CDATA[]]></annotation>
  <text auto="true" type="str" verify="true"><![CDATA[Введение Генерация тестов для проверки СБИС требует огромного времени и памяти. Сокращение затрат на проверку можно достигнуть путем проектирования самотестируемых схем. Термин “самотестирование” здесь употребляется применительно к СБИС, на кристаллах которого размещаются схемы генерации теста, сигнатурного анализа и управления тестом [1]. Цель метода состоит в том, чтобы проектируемая схема тестировалась в своем рабочем состоянии без изменения алгоритма функционирования. Для достижения поставленной цели предлагается расширить во взаимосвязи две следующие задачи: - синтезировать тестовую последовательность для обнаружения заданного класса неисправностей проектируемой схемы, имея в виду подходящую реализацию генератора теста и, используя для синтеза теста внутреннюю логику проектируемой схемы; - спроектировать генератор теста. Рассмотрим особенности решения этих задач подробнее. Синтез теста генетическим алгоритмом. Генетические алгоритмы доказали свои преимущества при решении многих оптимизационных ^-полных задач автоматизированного проектирования, швенйя 1Р1У Тематический выпуск например, при размещении модулей на кристалле СБИС, при трассировке цепей. Рассмотрим применение генетического алгоритма для решения задачи синтеза тестовой последовательности [2]. В качестве хромосом используются тестовые векторы вида (X.Z), где X входные наборы, Z состояния схемы. Генетический алгоритм обрабатывает популяцию тестовых векторов закодированных в хромосомы. В процессе обработки популяции к ней последовательно применяются различные генетические операторы, такие как кроссинговер и “точечная” мутация с заданными вероятностями. Затем производится селекция популяции путем перебора лучших решений, которые составляют следующее поколение, после чего цикл повторяется. Генетический алгоритм требует, чтобы хромосомы оценивались с точки зрения целевой функции задачи. Чтобы вычислить целевую функцию необходимо моделировать изменение логических состояний в узлах схемы и область распространения возможных неисправностей. Обозначим через ui узел цепи i, а через Z(ui) - логическое состояние узла ui (1,0,х). Считаем, что Z(ui) изменяется изменяется после подачи входного набора Tii длины q. Входной набор состоит из последовательности векторов X, которые улучшают целевую функцию, если для всех пар (i j) узлов схемы выполняется соотношение I Til • Tjl |<Е, где е - некоторое относительно небольшое целое число. Чтобы вычислить целевую функцию, необходимо произвести маркировку всех узлов схемы, начиная с первичных входов. Для этого можно воспользоваться алгоритмом поиска в глубину [3], согласно которому каждому узлу схемы назначается некоторое неотрицательное число к. Маркировка достигается с помощью рекурсивной процедуры следующего вида: Input: A description of the network Result: Mark all nodes in the circuit with a level procedure DFSJevel(u) /* Initially, global variable current_level<-l; *1 if u is not marked if u never assigned a level assign current level to u current Jevel«-current Jevel+1 end if mark u for each w in fanout(u) do DFSJevel(w) end for end if end procedure После маркировки схема разбивается на подсхемы, состоящие из Фиксированного количества элементов. Процедура test_generator реализует диетические операторы кроссинговера и мутации и формирует новую популяцию хромосом. Результирующая последовательность {XF,ZF} является тестом для проектируемой схемы. Практическая реализация метода самотестирования Ниже приводятся два прикладных примера реализации предполагаемого Метода самотестирования: программируемый тактовый генератор на три входа и ^-разрядный секционируемый центральный процессор. В зависимости сигналов на входах тактовый генератор производит синхроимпульсы различной продолжительности. Для реализации встроенного самотестирования исходной схемы был спроектирован генератор тестов в виде программируемой логической матрицы [1]. Длина теста для обнаружения всех одиночных неисправностей константного типа оказалась равной 27 наборам. Схема генератора теста содержит два триггера и 17 вентилей. Однако затраты на генератор теста сокращаются, если использовать для генерации теста сигнатурный регистр. В этом случае генератор теста реализуется комбинационной схемой на 7 вентилей и отношение дополнительных затрат на генератор теста и собственно проектируемый тактовый генератор синхроимпульсов равно 13%. Другим примером является реализация теста для 32-разрядного секционируемого процессора, который имеет 13 управляющих входов, 32 входа данных, 32 выхода и 128 триггеров. Длина теста оказалась равной 139 наборам, а схема встроенного генератора теста содержит один триггер и программируемую логическую матрицу с общим числом термов, равным 155. Для управления генератором используются два триггера процессора и 8 триггеров 32-разрядного сигнатурного регистра. Секции процессора тестируются параллельно. Дополнительные затраты на генератор теста и собственно процессор составляют отношение 10%. Заключение В статье представлен метод проектирования самотестируемых схем. Мы Ожидаем, что использование функциональных тестов для формирования начальной популяции хромосом способно улучшить результаты. Сочетание генетических алгоритмов с традиционным детерминированным синтезом позволит генерировать тесты высокого качества для СБИС на основе концепции встроенного самотестирования. ]]></text>
</doc>
