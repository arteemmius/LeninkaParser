<doc>
  <source auto="true" type="str" verify="true"><![CDATA[https://cyberleninka.ru/article/n/razrabotka-programmnoy-sistemy-effektivnoy-oplaty-schetov]]></source>
  <category auto="true" type="str" verify="true"><![CDATA[Автоматика]]></category>
  <author auto="true" type="list" verify="true">
    <item type="str"><![CDATA[Замкова Л.И.]]></item>
  </author>
  <title auto="true" type="str" verify="true"><![CDATA[Разработка программной системы эффективной оплаты счетов]]></title>
  <keywords auto="true" type="list" verify="true"/>
  <annotation auto="true" type="str" verify="true"><![CDATA[]]></annotation>
  <text auto="true" type="str" verify="true"><![CDATA[В настоящее время существует большое количество программных комплексов автоматизации различных задач бухгалтерского учета. Но задача оплаты счетов остается неавтоматизированной. В данной работе предлагается автоматизация задачи оплаты счетов-фактур. 1. Задача эффективной оплаты счетов и метод её решения Задача заключается в следующем: существует множество неоплаченных счетов на текущий момент времени; для каждого счета известна сумма выплаты ri и крайний срок оплаты d^ кроме того, задается текущий день, на который производится оплата df. Для каждого счета можно определить пеню l1=r1*p1*v1, которую необходимо выплатить при просрочке оплаты за vi дней с момента di по df (процент пени pi оговаривается в соответствующем пункте договора). Пусть D - часть средств, которую можно использовать для оплаты счетов. Из множества счетов необходимо выбрать те, которые можно оплатить в рамках суммы D, минимизируя суммарную пеню. Таких выборок может быть несколько. Решением задачи оплаты счетов является выборка, максимизирующая остаток средств у предприятия при оплате счетов в рамках суммы D. Эта практическая задача описывается двухкритериальной моделью о рюкзаке: п 21г • у I ^ тах /=1 п 2 V • у,- ^ тт л I ^ I /=1 п 2 V • У г < о /=1 Уі є {0,1} і = 1,2,...,n V = V + I / / / Разработанный метод решения предполагает последовательную оптимизацию. Сначала определяется множество допустимых решений, удовлетворяющих первому критерию оптимизации, затем при удовлетворении первому критерию и ограничению выбирается решение, удовлетворяющее второму критерию. Таким образом, двухкритериальная постановка сводится к решению однокритериальной задаче о рюкзаке: п 21г • У г ^ тах 1=1 п 2 V • Уг < о 1=1 У j є {0,1} і = 1,2,..., Постановка бухгалтерской задачи эффективной оплаты счетов опубликована в работе [1]. При разработке метода решения использовался способ формализации, представленный в публикации [2]. Метод включает два основных этапа: прямой проход и обратный. Цель прямого прохода - определить одно оптимальное решение. Однокритериальная задача о рюкзаке разбивается на n этапных задач: k max X li - y, i=1 1 1 k .sri- У, ^ D . k=1,...n yie{o,l} i=1,...k k k L(y) = S li - y, R(y) = S r, - y,. i=1 i=1 Для задачи размерности k строится множество допустимых решений (Ck,base). Элементы Ckbase упорядочиваются по возрастанию значений целевой функции. CJbase содержит два вектора (0) и (1). Ckbase k=2,3...n формируется на основе множества CH-i,base. Очередной в порядке номеров вектор с^(сьсь...,^) j=l,2,...,|Ck_i,base|, принадлежащий Ck_i,base, порождает два вектора-потомка, размерности k с1=(с1,с2,.. -0) и с^сьс^...,^,!). Если в Ckbase нет векторов, дающих равное или большее значение целевой функции, чем с1, то вектор с1 помещается на последнее место в Ckbase. Если Ckbase есть вектор, доминирующий над с1, то с1 заносится на последнее место во множество Ск,оЬ - множество векторов, отсекаемых из Ckbase на k-м шаге. Если в СкЬа8е есть векторы, дающие большее значение целевой функции, то с1 заносится перед первым таким вектором. После обработки первого вектора-по-томка с1 проверяется возможность добавления во множество Ckbase второго потомка с2. Если значение функции веса R(c2) не превосходит D, то вектор с2 заносится на последнее место в Ckbase. Сформированное таким образом множество Ckbase содержит вектора, упорядоченные по возрастанию значений целевой функции. Выходными данными прямого прохода являются множества Cibase , Ciots, i=1, 2..., n и вектор opt, который расположен в Cnbase на последней позиции. В результате функционирования алгоритма обратного прохода из всех решений, максимизирующих целевую функцию, выбирается наименьшее по значению функции веса. Введем множество B, элементами которого будут последние векторы множеств Cibase i=1, 2, ..., n. Если последний вектор Cibase i=1, 2, ..., n максимизирует целевую функцию, то он помещается в B. Вектор расширяется до размерности n нулевыми координатами. Он включается в Copt (множество оптимальных решений) при выполнении условия несовпадения по составу**. Для каждого элемента bk из множества B (k - размерность вектора bk) определяются предки размерности k-1, k-2, ., 2. Переобозначим вектор bk и его предков как вектора pt t=k, k-1, ., 2 (t - их размерность). Если в Ctots есть вектор, равный по значению целевой функции вектору pt t=k, k-1, ..., 2, то этот вектор расширяется до размерности k последними k-t координатами вектора bk. Затем полученный вектор размерности k расширяется нулевыми координатами до размерности n. Расширенный таким образом вектор заносится в Copt при выполнении условия несовпадения по составу с векторами, включенными в Copt. После завершения обработки всех векторов, принадлежащих множеству B, среди элементов Copt выбирается наименьший по значению функции веса. 2. Описание программной системы, разработанной на основе метода Программная система принятия решения об эффективной оплате счетов имеет следующую структуру: БПР Здесь БД - база данных «Бухгалтерия», БПР - блок принятия решения. Пусть у1 и у2 - два вектора размерности к. L(у1) и L(у2) - значения целевой функции в точках у1 и у2, R(y1) и R(y2) - значения функции веса в этих точках. Если L(у1) = L(у2) и R(y1) > R(y2), то вектор у2 считается доминирующим над у1. Два вектора являются совпадающими по составу, если они определяют одно подмножество множества L={li} і=1,2...п. Например, рассмотрим множество L={l1,l2,l3,l4}, где 11=5, 12=3, 13=3, 14=2. Векторы (1101), (1011) совпадают по составу, так как они определяют подмножество {5,3,2}. Исходными данными для БПР являются значения из таблицы «Сводная» (см. разд. 3) и таблицы «Сумма предприятия» базы данных «Бухгалтерия». Действие 1 исключает из таблицы «Сводная» записи, для которых значение поля «Признак» есть True. Таким образом, при очередном запуске системы рассматриваются только неоплаченные счета (значение поля «Признак» есть False). Перед запуском программной системы необходимо переформировать таблицу «Сводная», а при необходимости и таблицу «Сумма предприятия». Элементам массива l присваиваются значения множества значений поля «Пеня» таблицы «Сводная». Элементам массива r присваиваются значения множества значений поля «Сумма в счете» таблицы «Сводная». Переменной D присваивается значение поля «Sum_Sum_сумма» таблицы «Сумма предприятия». Блоком принятия решения определяется решение двухкритериальной задачи о рюкзаке: n 2 li • yi ^ max i=1 n 2 ri • yi ^ min i=1 r = Г + h i = 1,2,---,n , n 2 ri • yi ^ D i=1 yi e где n - количество неоплаченных счетов на текущий момент, количество записей в таблице «Сводная» после действия 1. Эта задача решается двухэтапным алгоритмом, описанным в разд. 1. Именно этот алгоритм заложен в основу программы, представляющей БПР. БПР реализован в Borland С++ Builder 4. БПР выдает вектор у, являющийся решением двухкритериальной задачи о рюкзаке. Вектор у имеет булевы координаты. Причем yi=1 означает, что i-й счет выбран для оплаты, а yi=0 означает, что i-й счет не будет оплачиваться. Таким образом, из исходного множества неоплаченных счетов выбирается подмножество счетов, которые можно оплатить на текущий момент. На базе решения у корректируется таблица «Сводная» - действие 2. Для счетов, определяемых yi=1, устанавливается значение True поля «Признак» i-й записи. Таким образом, пользователь до запуска программной системы по базе данных «Бухгалтерия», а именно по таблице «Сводная» может просмотреть, какие счета-фактуры нужно оплатить. При разработке программной системы особого внимания потребовал вопрос совместимости продукта фирмы Microsoft СУБД Access и продукта фирмы Borland С++ Builder (системы программирования). Это выражалось в том, чтобы приложение в Builder могло обратиться к таблицам базы данных «Бухгалтерия», созданной в СУБД Access. Для того чтобы это было возможным, необходимо с пакетом Builder устанавливать утилиту bdecfg32.exe. С помощью этой утилиты создается псевдоним базы данных «Бухгалтерия», с которым и работает приложение в Builder. Для каждой таблицы, с которой будет работать приложение, создается экземпляр объекта типа TdataSource и экземпляр объекта типа TTable. Причем в свойстве DatabaseName компоненты Table указывается имя псевдонима. А в свойстве Table-Name - имя таблицы базы данных, для которой создается компонента. В свойстве DataSet компоненты DataSource указывается имя соответствующей таблицы базы данных. В приложении можно писать команды манипулирования с экземплярами объектов типа TTable, например, считывать и изменять значения полей. На базе предприятия «Элегант» проводилось тестирование программной системы принятия решения об оплате счетов. В качестве исходных данных для программной системы использовались данные того же порядка, который фигурирует в реальной бухгалтерии предприятия «Элегант». Использовать конкретную информацию из бухгалтерских документов не предоставилось возможным из-за коммерческой тайны. Рассмотрим тестирующий пример. Программная система была запущена 28.03.04. Пеня, сумма в счетах и средства предприятия выражены в рублях. D««Сумма предприятия»=35000 г««Сумма в счете 1» ={320, 550, 1750, 1500,4000,1850,500,3700,300,250,180}. «Процент пени»={0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2} «период оплаты»={4,3,3,2,3,2,4,2,2,1,3} «Дата выписки прих. ордера»={25.02.04, 20.03.04, 18.02.04, 01.03.04, 18.03.04, 20.02.04, 10.03.04, 12.03.04, 11.03.04, 15.02.04, 17.03.04} Множество значений поля «Пеня» расчитывает СУБД Access. l ««Пеня»={(28.03.04-(25.02.04+4)- 1)*0.2*320=1856, (28.03.04-(20.03.04+3)-1)*0.2*550=660, (28.03.04-(18.02.04+3)-1)*0.2*1750=12950, (28.03.04-(01.03.04+2)-1)*0.2*1500=7800, (28.03.04-(18.03.04+3)-1)*0.2*4000=6400, (28.03.04-(20.02.04+2)-1)*0.2*1850=13320, (28.03.04-(10.03.04+4)-1)*0.2*500=1500, (28.03.04-(12.03.04+2)-1)*0.2*3700=11100, (28.03.04-(11.03.04+2)-1)*0.2*300=960, (28.03.04-(15.02.04+1)-1)*0.2*250=2100, (28.03.04-(17.03.04+3)-1)*0.2*180=324} Множество значений поля «Сумма в счете» расчитывает СУБД Access. r ««Сумма в счете»={320+1856=2176, 550+660=1210, 1750+12950=14700, 1500+7800=9300, 4000+6400=10400, 1850+13320=15170, 500+1500=2000, 3700+11100=14800, 300+960=1260, 250+2100=2350, 180+324=504} D=35000 i 1 2 3 4 5 6 7 8 9 10 11 l, 1856 660 12950 7800 6400 13320 1500 11100 960 2100 324 r, 2176 1210 14700 9300 10400 15170 2000 14800 1260 2350 504 В результате работы программной системы полю «Признак» таблицы «Сводная» присваиваются следующие значения: «Признаю^йге, false, true, false, false, true, false, false, false, true, true} Это соответствует решению y=(1,0,1,0,0,1,0,0,0,1,1) двухкритериальной задачи о рюкзаке. Вся пеня, которая идет на 28.03.04, составляет 58970 рублей. Из неё в рамках суммы предприятия 35000 рублей оплатили 30550 рублей, что составляет «52% от всей пени на 28.03.04. Кроме того, после оплаты выбранных счетов у предприятия остается 35000-34900=100 рублей при учете того, что из 35000 оплачиваются выбранные счета и пеня по ним. Для этого примера программная система выдала результат за 1,1 минуты. 3. Проектирование базы данных «Бухгалтерия» Реляционная база данных (БД) «Бухгалтерия» создавалась в системе управления базами данных (СУБД) Access97. БД состоит из восьми основных таблиц: «Выписки из банка», «Договоры», «Лист кассовой книги», «Счета», «Сводная», «Сумма в кассе», «Сумма на лицевом счете», «Сумма предприятия». Таблицы «Выписки из банка», «Договоры», «Лист кассовой книги», «Счета» заполняются на основании бухгалтерских документов. Представим подробно структуру этих таблиц и принцип их заполнения. Структуру таблицы «Выписки из банка» составляют следующие поля: «Дата выписки», «Сумма на счете». Эта таблица заполняется на основании информации множества выписок из лицевого счета. Дата выдачи лицевого счета заносится в поле «Дата выписки», а исходящий остаток - в поле «Сумма на счете». Структуру таблицы «Договоры» составляют следующие поля: «Наимен. документа», «Процент пени», «Период оплаты». В поле «Наимен. документа» заносится значение, например, договор85 (номер договора), в поле «Процент пени» - данные раздела договора85 «Г арантии исполнения и ответственность сторон» (например, процент пени 0,15), в поле «Период оплаты» - данные раздела договора85 «Цены и порядок расчета» (например, срок оплаты 3 дня с момента получения приходного ордера). Структуру таблицы «Счета» составляют следующие поля: «Наимен. договора», «Сумма в счете1», «Дата выписки прих. ордера», «Номер счета». В поле «Наимен. договора» заносится номер договора, по которому выставляется счет (договор указан как основание в накладной, прилагаемой к счету-фактуре, например, договор85). В поле «Сумма в счете» заносится сумма, выставленная в счете-фактуре (например, в счете-фактуре выставлена сумма 5087 руб. 25 коп). В поле «Дата выписки прих. ордера» заносится, например, дата 25.07.2001. В поле «Номер счета» заносится номер счета-фактуры, соответствующего указанному договору. Структуру таблицы «Лист кассовой книги» составляют следующие поля: «Номер документа» и «Сумма». В поле «Номер документа» заносится номер приходного или расходного ордера, по которому фиксируется сумма в колонке приход или расход листа кассовой книги за текущий день. В поле «Сумма» значение из колонки приход заносится с положительным знаком, а колонки расход с отрицательным знаком. Остаток на начало дня из листа кассовой книги за текущий день заносится в поле «Сумма» с положительным знаком. Следует заметить, что таблица «Лист кассовой книги» заполняется по листу кассовой книги на текущий день. Таблица «Сумма в кассе» формируется запросом на создание таблицы. Эта таблица содержит одну запись с единственным полем <^ит_сумма». Значение поля <^ит_сумма» формируется суммированием множества значений поля «Сумма» таблицы «Лист кассовой книги». Запросом на выборку по таблице «Выписки из банка» определяется запись, для которой поле «Дата выписки» имеет максимальное значение. Таблица «Сумма на лицевом счете» формируется запросом на создание таблицы. Она содержит единственную запись, соответствующую ранее определенной максимальной дате (дате последней выписки из банка). Запросом на добавление к таблице «Сумма в кассе» добавляется значение поля «Сумма на счете» таблицы «Сумма на лицевом счете». Таким образом, количество элементов множества значений поля «Sum_сумма» таблицы «Сумма в кассе» становится равным двум. Таблица «Сумма предприятия» формируется запросом на создание таблицы. Она содержит единственную запись с одним полем «Sum_Sum_сумма», полученную суммированием значений поля «Sum_сумма» таблицы «Сумма в кассе». Таблица «Сводная» формируется запросом на создание таблицы. Результаты запроса формируютя на основании двух связных таблиц, таблицы «Договоры» и таблицы «Счета». Таблицы связываются по полям «Наимен. документа» (таблица «Договоры») и «Наимен. договора» (таблица «Счета»). Таблицу «Сводная» составляют следующие поля: «Наимен. договора» (таблица «Счета»), «Процент пени» (таблица «Договоры»), «Период оплаты» (таблица «Договоры»), «Сумма в счете1» (таблица «Счета»), «Дата выписки прих. ордера» (таблица «Счета»), «Пеня», «Сумма в счете», «Признак». Поле «Пеня» вычисляется согласно следующему выражению: (Ба1е()-(([дата выписки при ордера]+[период оплаты])-1))* *[процент пени]*[сумма в счете1] Поле «Сумма в счете» вычисляется согласно выражению: [сумма в счете1]+[пеня] Поле «Признак» инициализируется значением False. Это означает, что ни один счет не выбран для оплаты. ]]></text>
</doc>
