<doc>
  <source auto="true" type="str" verify="true"><![CDATA[https://cyberleninka.ru/article/n/sposoby-uvelicheniya-proizvoditelnosti-algoritmov-dlya-otkazoustoychivyh-sistem-hraneniya-dannyh]]></source>
  <category auto="true" type="str" verify="true"><![CDATA[Автоматика]]></category>
  <author auto="true" type="list" verify="true">
    <item type="str"><![CDATA[Пименов В. М.]]></item>
    <item type="str"><![CDATA[Соколов Е. В.]]></item>
    <item type="str"><![CDATA[Кобец А. Л.]]></item>
  </author>
  <title auto="true" type="str" verify="true"><![CDATA[Способы увеличения производительности алгоритмов для отказоустойчивых систем хранения данных]]></title>
  <keywords auto="true" type="list" verify="true"/>
  <annotation auto="true" type="str" verify="true"><![CDATA[]]></annotation>
  <text auto="true" type="str" verify="true"><![CDATA[Современные информационные системы обрабатывают все возрастающие объемы данных, которые требуют как места для хранения, так и высокой пропускной способности для передачи по сети. Для обеспечения сохранности данных применяются различные способы, основанные в первую очередь на хранении с избыточностью (как правило, путем «-кратного копирования или с использованием заранее определенных схем создания избыточности [Patterson, 1988]). Ранее был предложен подход [Тормасов и др., 2001; Пименов, Сметанин, 2006], основанный на (п, к )-пороговой схеме, позволяющий более гибко управлять избыточностью хранения данных. Именно, данные преобразовываются в п частей («разборка»), по любым к которых можно восстановить исходные данные («сборка»). Это дает возможность выбирать соотношение между надежностью и используемым для хранения объемом. Алгоритм основывается на использовании свойств матрицы Вандермонда, любые к из п строк которой являются линейно независимыми. Матрица Вандермонда размером п X к строится из п различных порождающих элементов p, последовательно возводимых в степень: av = pj- ', i ! [l; п], j ! [l; к]. Исходный файл разбивается на последовательность ячеек х, собираемых в матрицу, и умножается слева на матрицу Вандермонда: У У2 Уп -Уп Уп + l Уп + 2 У2п - l У2п У2п + l У2п + 2 Узп - l Узп pl p2 pl Р 2 ^ pi -rt- X, Х Х X, Хзк Каждая полученная строка (проекция) вместе с соответствующим ей порождающим элементом сохраняется в отдельном месте. Для выполнения обратного преобразования требуются любые к проекций вместе со значениями р, использовавшимися при их построении. Из подмножества р по правилу построения исходной матрицы ИМИ составляется матрица 11М11. Так как построенная матрица тоже является матрицей Вандермонда, то все ее строки линейно независимы. Поэтому можно вычислить обратную к ней матрицу ИМИ . Тогда исходные векторы х] получаются по формуле х] = ИМИ у]: Х1 Хк +1 Х2к + l Х2 Хк + 2 Х2к + 2 Хк Х2к Х3к Pi Р* l Рак Рк l -та, -1 ' Уа Уп + а У2п + а N pal У*2 Уп + *2 У2п + * Рк~ 'j L У* Уп + * У2п + * * *' р Х 2к + l Х 2к + 2 п Х Х к п 1818-7900. Вестник НГУ. Серия: Информационные технологии. 2007. Том 5, выпуск 1 © В. М. Пименов, Е. В. Соколов, А. Л. Кобец, 2007 Скорость разборки с использованием данного алгоритма обратно пропорциональна nk, а сборки - k, и, зная скорость разборки, можно получить скорость сборки, умножив первую на n/k. Поэтому свойства алгоритмов сборки в работе практически не рассматриваются (за исключением особо оговоренных случаев). Работа (n, k )-схемы обеспечивается свойствами матрицы Вандермонда, но ячейки не могут представляться обычными рациональными числами в силу того, что их множество неогра-ничено, а в вычислительной технике применяются конечные числа. Поэтому в качестве ячеек матриц используются элементы полей Галуа, вычисления в которых достаточно трудоемки. В работе рассматривается поле GF (28), представимое в виде многочленов 7 степени с коэффициентами из поля GF (2). Элементы этого поля можно описывать 1 байтами, где каждый разряд задает коэффициент при соответствующей степени. В таком случае сложение выполняется операцией «исключающее ИЛИ», а умножение - по правилам перемножения многочленов по модулю какого-либо неприводимого многочлена 8 степени. В существующих процессорах общего назначения отсутствуют команды, выполняющие умножение в полях Галуа. Программное вычисление «в лоб» по правилам перемножения многочленов чрезвычайно медленно. Общепринятым способом преодоления этого ограничения для GF (28) является использование таблиц умножения и деления, содержащих заранее вычисленные значения соответствующих операций 2. Однако скорость работы подобных алгоритмов также оставляет желать лучшего (рис. 1). В настоящей работе описываются различные способы увеличения скорости преобразований по (n, k )-схеме на процессорах общего назначения с архитектурами intel / amd x86 / x64 как за счет использования низкоуровневых свойств процессоров, так и за счет изменения свойств алгоритмов, а также благодаря ускорению вычислений в полях Галуа. Разворачивание циклов При выполнении конкретного преобразования (когда матрица преобразования 11М11 уже зафиксирована) можно использовать локальную таблицу умножения, полученную копированием из общей таблицы строк, соответствующих задействованным в ИМИ элементам, в один массив друг за другом. Это позволяет расположить участки с большой частотой обращения рядом друг с другом (в отличие от полной таблицы, где используемые и неиспользуемые строки перемешаны). Это приводит к более эффективному использованию кешей процессора, а также сокращает число используемых ячеек таблицы умножения. Кроме того, так как число столбцов матрицы ИМИ уже известно, можно осуществить «разворачивание» внутреннего цикла (loop unrolling) 3, проходящего по каждой из ее строк, следующим образом. Для получения 7-й проекции используется только одна строка матрицы преобразования _1 Pi ... pk— 1) " (0 1 ... k — 1). Из таблицы умножения в одномерный массив выбираются лишь задействованные в преобразовании строки: J l 2 256 N ml ml .. ml l 2 256 mp m .. m p pi p l 2 256 m k -1 m — l . .. m k—l l Pi pi— p P Значения ячеек заменяются индексами строк массива: _1 р ... рк—') " (0 1 ... к — 1), и вместо цикла из к шагов само тело цикла записывается к раз, с использованием явных смещений. Результаты применения подхода «разворачивание циклов» приведены на рис. 1 в сравнении с исходной реализацией (п, к )-схемы. 1 Более подробное и строгое описание можно найти в [Пименов, Сметанин, 2006]. 2 Использование «таблицы умножения» дает 22-кратный прирост скорости разборки на x86 архитектуре. 3 Intel architecture software developer’s manual. Vol. 3: system programming guide, 1999. http://www.intel.com/ design/pentiumii/manuals/243192.htm. Упрощение матрицы преобразования «Алгоритмическим» способом ускорения является предварительное упрощение матрицы Вандермонда, которое заключается в сведении элементарными преобразованиями матрицы ~ Е ИМИ к матрице ИМИ вида , где НЕ - единичная матрица: ИМИ = ' 1 0. . 0 0 0 1. 0 0 0. 1 ак + 1,1 0к + 1,2 • ак + 1, к . 0,1 0,2 . ■ ап,к ) Полученная матрица ИМИ обладает теми же свойствами, необходимыми для реализации (п, к)-схемы, что и исходная \\М (любые п из к строк являются линейно независимыми и могут образовать базис в к-мерном пространстве). В исходном алгоритме для вычисления У = 11М11Х требовалось кп операций умножения. После преобразования матрицы ИМИ можно представить вычисления У - = НЕIIХ||1-|| = 11Е11Х и У \ = IIКIIX . Так как преобразованные с помощью единичной матрицы данные совпадают □ Ор1егоп х86 ■ Ор1егоп х64 (10,5) (15,10) (10,5)-ипго11 (15,10)-ипго11 0 10 20 30 40 Рис. 1. Скорости работы разборки файлов в исходной и ускоренной реализациях, МБ/с 50 □ Ор1егоп х86 ■ Ор1егоп х64 (10,5) (15,10) ~\ I I I I 0 10 20 30 40 50 Рис. 2. Скорости работы разборки файлов при использовании «упрощенной» матрицы преобразования, МБ/с с исходными, остается вычислить только нижнюю часть вектора У ., и поэтому количество требуемых операций умножения уменьшается до к (п — к). Умножение на единичную матрицу фактически представляет собой копирование, но в силу выбранного способа размещения исходных данных и проекций, сопровождается переупорядочением. Для того чтобы избежать вызываемого этим замедления, порядок следования исходных данных изменяется (рис. 2): 1 1 У1 У2 УЗ Уm + 1 Уm + 2 Уm + 3 Уm(n - 1) + 1 Уm(n - 1) + 2 Уm(n - 1) + Уmn + 1 Уmn + 2 Уmn + 3 P1 P2 к - 1N Pn - 1 Pn Р2к - 1 рк„ --1 рП -1 Хз Скорость сборки с использованием «упрощенной» матрицы зависит от выбираемых проекций. Это происходит из-за того, что число строк, выписанных из единичной матрицы, в ИМИ и 11М11 совпадает, поэтому данные либо просто копируются, либо преобразуются с использованием операций в полях Галуа (рис. 3). матрица преобразования с единичным столбцом 4 Свойство независимости строк матрицы сохраняется, если любую строку матрицы разделить на произвольный коэффициент. Поэтому ее можно упростить, преобразовав все коэффициенты нижней части по формуле Ь, = о,/а, к + 1 < и, 1 < , < к. Таким образом матрица принимает вид 1 о. . о O о 1. . о о о. 1 1 bk + 1,2 • bk + 1, к 1 bn, 2 . ■ b„ k 0 а количество умножений уменьшается на п — к (рис. 4). Вычисления в полях (24) Для обеспечения отказоустойчивости в локальных системах хранения данных нередко используются КЛГО-массивы, состоящие из нескольких дисков. В подобных системах возможно использование (п, к )-схемы на основе ОЕ (24) при этом порядок п и к (ограничен- □ Оріегоп х86 ■ Оріегоп х64 1-5 проекции 5-10 проекции 50 100 150 200 250 300 350 400 450 Рис. 3. Скорости работы сборки файлов при использовании «упрощенной» матрицы преобразования при (и, k) = (10, 5), МБ/с 4 Этот алгоритм ускорения разборки не может быть применен для сборки. 5 Более подробное описание выполнения операций в этих полях можно найти в работах [Mastrovito, 1991; Paar, 1994]. См. также: Advanced encryption standard (AES) / National Institute of Standards and Technology (NIST), 2001. http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf. Х Х Х m + 1 m + 2 m + 3 Х Xmk + 2 Хmк + 3 mk + 1 0 ных 15) вполне достаточен для работы. В этом случае операция умножения становится вычислимой напрямую через последовательность «простых» арифметических операций (имеющихся и в SIMD-командах), и необходимость использования таблицы умножения отпадает. Эти вычисления осуществляются следующим образом. Элементы поля GF (24) можно представить в виде многочленов 3-й степени: a (x) = адсъ + aX + ape + a0, b (x) = bjX3 + b2x2 + bx + b0. Результат их умножения: c (x) = a (x) b (x) mod p (x), где p (x) - любой неприводимый многочлен 4-й степени, например, x4 + x + 1. В таком случае c (x) = CjT3 + c2x2 + c1x + c0, c0 = (a 7 b0) © (a 7 b1) © (a 7 b2) © (a1 7 b3), c0 c1 = (a 7 b0) © (a0 7 b1) © (a, 7 b2) © (a2 7 b3) © c0, c2 = (a2 7 b0) © (a1 7 b1) © (a0 7 b2) © (a3 7 b3) © c1, (10,5) (15,10) c3 = (a3 7 b0) © (a2 7 b1) © (a1 7 b2) © (a0 7 b3) © c2, □ Opteron x86 ■ Opteron x64 10 20 30 40 50 60 Рис. 4. Скорости работы разборки файлов при использовании матрицы преобразования с единичным столбцом, МБ/с □ Opteron x86 ■ Opteron x64 (10,5) без SIMD (15,10) без SIMD (10,5) c SIMD (15,10) c SIMD 20 40 60 80 100 120 Рис. 5. Скорости работы разборки файлов при использовании ОЕ(24) совместно с «упрощенной» матрицей на обычных и SSE-регистрах, МБ/с 0 0 где сгруппированы одинаковые слагаемые. При неизменном Ь (х) можно представить результат в матричной форме: ( N Со ао а3 а2 N аі1 С а1 ао а3 а2 С2 а2 а1 ао а, а, а2 ао Со ао а3 а2 аі . • р • і © [а3 7 Ь1) © (а2 7 Ь2) © (а1 7 Ь3) (а, 7 Ь2) © а 7 Ь3) (а, 7 Ьз) После этого каждый столбец матрицы ||«^ || помещается в отдельный регистр и целиком умножается на одну ячейку Ъ]. Часть произведения используется для вычисления правого столбца (с использованием циклического сдвига и маскирования «логическим и»), складывается с ним и добавляется к предыдущему результату. После повторения этих действий для всех столбцов матрицы ||«^^|| получается столбец Цс^Ц с результатом. Алгоритм реализован с использованием двойных слов (64 разряда) и SSE-регистров и команд (128 разрядов). Результаты работы алгоритма приведены на рис. 5. Параллельное выполнение Преобразование по (и, к )-схеме линейно. Поэтому можно разделить всю работу на части и выполнять их параллельно на нескольких процессорах. На рис. 6 приведена производительность алгоритма в зависимости от количества одновременно выполняемых потоков на двухпроцессорной машине. Выводы Общий график производительности разборки (МБ/с) разных алгоритмов представлен на рис. 7. Отмечен порядок следования различных алгоритмов и величина относительного прироста скорости. Первоначально независимо были реализованы «разворачивание циклов» и «упрощение матрицы». Затем на основе «упрощенной матрицы» реализована «матрица с единичным столбцом». На основе последнего сделаны обе реализации ОЕ (24). «Распараллеливание» реализовано на основе «ОЕ (24) без SIMD». 0 2 Ь 0 0 20 40 60 80 100 120 140 Рис. 6. Скорости работы разборки файлов при параллельном выполнении вычислений в ОЕ (24) совместно с «упрощенной» матрицей на двухпроцессорной машине при (и, к) = (10,5) в зависимости от количества одновременно работающих потоков, МБ/с первоначальные скорости разворачивание циклов упрощенная матрица упрощенная матрица с единичным столбцом GF(24) без SIMD □ Opteron x86 ■ Opteron x64 GF(24) c SIMD распараллеливание (на 4 потока на двухпроцессорной машине) 20 40 60 Мб/сек 80 100 120 первоначальные скорости разворачивание циклов упрощенная матрица упрощенная матрица с единичным столбцом GF(24) без SIMD □ Opteron x86 ■ Opteron x64 GF(24) c SIMD распараллеливание (на 4 потока на двухпроцессорной машине) Мб/сек Рис. 7. Общий график производительности алгоритмов: а - для (и, к) = (10,5); б - для (и, к) = (15,10). 0 - без распараллеливания достигнуто ускорение от 3-х до 5-ти раз в зависимости от выбора n и k; - распараллеливание дает дополнительное ускорение в 1,6 раз на двухпроцессорной машине; - за счет удачного подбора проекций при сборке можно достигнуть большей скорости; наименее ресурсоемкими являются первые k проекций; - достигнутые скорости позволяют эффективно использовать (n, k )-схему в гигабитных сетях для распределенного хранения данных. ]]></text>
</doc>
