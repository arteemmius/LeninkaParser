<doc>
  <source auto="true" type="str" verify="true"><![CDATA[https://cyberleninka.ru/article/n/yazyki-programmirovaniya-v-ekspertnyh-sistemah]]></source>
  <category auto="true" type="str" verify="true"><![CDATA[Автоматика]]></category>
  <author auto="true" type="list" verify="true">
    <item type="str"><![CDATA[Сеченов М.Д.]]></item>
    <item type="str"><![CDATA[Щеглов С.Н.]]></item>
  </author>
  <title auto="true" type="str" verify="true"><![CDATA[Языки программирования в экспертных системах]]></title>
  <keywords auto="true" type="list" verify="true"/>
  <annotation auto="true" type="str" verify="true"><![CDATA[]]></annotation>
  <text auto="true" type="str" verify="true"><![CDATA[Одной из характерных особенностей компьютеру экспертными системами (ЭС) , является их способно™.программ, называемых опыт наиболее квалифицированных специ^ов Накапливать знания и предметной области. Используя накопленные системой °В В ОПРеДелснной знания, пользователи с обычной квалификацией получают возможность достигать результатов, сравнимых по качеству решений с уровнем экспертов. Это является следствием того, что ЭС в своей работе повторяет приблизительно ту же последовательность рассуждений, что и человек при анализе проблемы. Компьютерные системы, способные лишь повторить логический вывод эксперта, принято относить к экспертным системам первого поколения. Но при решении сложных интеллектуальных задач, возможностей системы, способной только имитировать деятельность человека, оказывается явно недостаточно. Желательно, чтобы ЭС играла роль полноценного советчика, способного генерировать и отбрасывать гипотезы, работать в условиях неполных, недостоверных, плохо формализуемых и противоречивых знаний, порождать новые решения и т.д. Наличие таких возможностей характерно для экспертных систем второго поколения, которые разрабатываются в настоящее время. Такие системы называются партнерскими, или усилителями интеллектуальных способностей человека. Их отличительными чертами является умение обучаться и развиваться. Весьма актуальной становится проблема обеспечения интерфейса, ’’дружественного” пользователю, и взаимодействия на ограниченном естественном языке. Для достижения вышеперечисленных характеристик исключительно важную роль играет выбор модели представления знаний и поддерживающего его языка программирования. Вопрос в том, какова должна быть формальная модель представления знаний в интеллектуальной системе, не решен окончательно до сих пор. Популярные модели типа фреймов, продукций или семантических сетей, Удобные при концептуальном описании процессов, протекающих в базах знаний и блоках логического вывода, оказываются далеко не столь удобными в программных реализациях. Тот или иной выбранный для программирования процессов в ЭС язык диктует свои жесткие требования к структурам данных, с которыми он будет оперировать. А это приводит тому, что конкуренция между Различными языками программирования для интеллектуальных систем до сих пор продолжается. Языки программирования можно разбить на три широкие категории в соответствии с природой их семантики [1]: 1) процедурные языки (алгоритмические языки СИ, Паскаль, ФОРТРАН и др-); 2) функциональные языки (например, Лисп); 3) реляционные языки (Пролог, ОиС, ЕБР и др.). Процедурный язык соответствует специфическим механизмам, которые проводят решение задачи так, как она описана обрабатывающими процедурами, т. е- соответствует миру компьютера. Соответствие между объектами и явлениями Реального мира и их процедурным описанием не имеет связи с семантикой самого языка. Смысл конструкции в функциональном языке (например, вызова функции) определяется в терминах значения, которое она вырабатывает. Вызов функции Можно рассматривать как объявление вырабатываемого ею значения. Функциональные языки имеют более высокий уровень, чем процедурные, поскольку программист может мыслить в терминах вычисления значений, а не Поведения ЭВМ. Сами же значения нередко являются частью спецификации. Смысл конструкции в реляционном языке определяется как отношение между °тдельными сущностями или классами сущностей. Реляционные языки имеют паивысший уровень, так как семантика конструкций реляционного языка весьма близка к спецификации задачи. Другими словами, описывается, что нужно сДелать, а не способ выполнения. С декларативной точки зрения реляционные языки допускают более высокий уровень абстракции и гораздо ближе к языку смыслов, чем процедурные. Исходя из сказанного, при построении экспертных Систем преимущество следует отдавать языкам функционального и реляционного типов, что, впрочем, не означает полного отрицания использования процедурных языков. В 70-х годах в программировании задач искусственного интеллекта (ИИ) наметилась тенденция перехода от процедурных к декларативным описаниям. К этому же времени сформировались и концепции представления знаний на основе семантических сетей и фреймов. Вследствие этого появились специальные языки программирования, ориентированные на поддержку этих концепций. Среди таких языков представления знаний (ЯПЗ) можно отметить KRL, FRL, KL-ONE, KL-TWO и ряд других[2]. К особенностям этих языков можно отнести: двухуровневое представление данных (абстрактная модель предметной области в виде иерархии множеств понятий и конкретная модель ситуации как совокупность взаимосвязанных экземпляров^ этих понятий) , представление связей между понятиями и закономерностей предметной области в виде присоединенных процедур; семантический подход к сопоставлению образцов и поиску по образцу. Одни из этих языков (например, KRL, FRL) активно использовали Лисп. В частности, FRL - не самостоятельный язык, а хорошо продуманная библиотечная система над Лиспом. Здесь имеются развитые средства манипулирования иерархическими списками свойств объектов, включая механизмы наследования свойств, и набор присоединенных к описаниям процедур. Другие языки (KL-ONE, KL-TWO) объединяют семантические сети и прологоподобные средства логического вывода. Интеграция семантических и логических механизмов, обменивающихся информацией в процессе вывода, расширяет выразительные возможности модели представления знаний и позволяет решать задачи, которые не могут быть решены с помощью каждого из этих средств в отдельности. * В настоящее время ведутся работы в области создания специализированных языков и систем программирования для экспертных систем. Краткий, но достаточно информативный обзор трех наиболее интересных языков представления знаний (RLL, ART.OPS5) можно найти в [3]. RLL использует концепцию фреймов и является универсальной средой для конструирования языка представления знаний для ЭС. Подобно другим инструментальным средствам, RLL содержит два слоя. Первый составляют базисные примитивы, а второй - средства их комбинирования на более высоком, чем Лисп, уровне. Все структуры, более сложные, чем список значений, описываются в виде фрейм-подобных RLL -элементов. С помощью RLL-элементов описываются не только понятия предметной области, но и понятия самой RLL-среды ( слот, механизм наследования и т.д.). Здесь возможно использование различных механизмов вывода решений. В RLL имеется библиотека управляющих структур И определенные средства конструирования из них решателей, необходимых для конкретной ЭС. В ART имеется не только ЯПЗ, удобный для создания экспертной системы, но и инструментальное окружение. Во входном языке ART выделяются декларативная и процедурная компоненты. К первой относятся факты и схемы,а ко второй правила. Факты в ART экземпляры фреймов, а схемы фреймы- прототипы. Процедурную ART-компоненту составляют гипотетические правила, правила ограничений и правила полаганий. Все они имеют традиционную форму продукций, а отличаются способами работы с контекстами. Управление выводом в ART в основном встроенное. Нужно отметить, что средства описания фактов здесь почти целиком базируются на Лиспе, что снижает концептуальную целостность языка. OPS5 - ЯПЗ для экспертной системы, поддерживающий продукционный подход. OPS5-nporpaMMa содержит секцию декларации, где описываются используемые далее объекты и определяются введенные пользователем функции, и секцию продукций, основу которой составляют правила. ОР55-объекты описываются с помощью фреймов-экземпляров, прототипы которых задаются в виде определенных структур данных, описывающих небольшое число встроенных типов данных. Модуль вывода решений в OPSS - системе состоит из трех основных блоков: 1) отождествления, где осуществляется поиск подходящих правил; 2) выбора исполняемого правила из конфликтного множества правил; 3) собственно исполнителя выбранного правила. В OPS5 поддерживается единственная стратегия вывода решений вывод, управляемый целями. OPSS является достаточно мощным инструментальным языком для представления знаний в ЭС . Однако с точки зрения базового набора операций уровень OPS5 ниже, чем у ЯПЗ типа KRL. Уступает он и уже упоминавшемуся языку RLL, предназначенному для проектирования ЯПЗ. Анализируя наиболее распространенные языки и системы для создания ЭС, следует отметить, что не существует единого общепринятого подхода к их созданию. Все они в той или иной мере не свободны от недостатков. Многие из специализированных ЯПЗ так и не вышли за рамки лабораторных исследований, другие являются весьма дорогостоящими и практически недоступными для широкого круга проектировщиков экспертных систем. Исходя из этого, следует остановиться на эффективных инструментальных средствах программирования общего назначения. К числу таких средств относятся исторически хорошо себя зарекомендовавшие языки обработки символьной информации Лисп и Пролог, позволяющие строить довольно гибкие системы в рамках различных формализмов представления знаний. Еще одним аргументом в их пользу является наличие трансляторов с этих языков на многих ЭВМ, включая персональные компьютеры. Рассмотрим кратко оба этих языка. Язык Лисп, использующий функциональный подход, является языком обработки списков, ориентированным на символьную обработку данных. Этот язык основан на алгебре списочных структур, лямбда-исчислений и теории рекурсивных функций [4,5]. Первые попытки решения задач ИИ на ЭВМ были предприняты вСША в конце 50-х годов. Более чем за тридцать лет своего существования язык Лисп был существенно расширен, появилось множество диалектов. Наиболее известными диалектами являются NTER USP.ZETA LISP, FRANZ LISP и COMMON LISP. Многие реализации Лиспа требуют наличия мощного процессора и значительных ресурсов памяти. Профессиональная работа на Лиспе возможна в основном на сверхмощных Лисп-машинах типа Simbolics 3600 и FAIM-1 или хотя быУАХ-11/780. Однако, как уже отмечалось, имеются реализации Лиспа и для персональных компьютеров. Язык Лисп, по сути, это комбинация команд SETQ, CAR,CDR, COND, ^ONS, EVAL с добавлением определения функций пользователя DEFUN. Прочие элементы языка являются результатом добавления на уровне библиотечных нестандартизированных функций со всеми вытекающими отсюда последствиями. Язык Пролог появился почти четверть века назад. В его основе лежали идеи логического программирования, предложенные Р.Ковальским и П.Хейесом.Первый интерпретатор Пролога был создан в Марселе в 1973 году А-Колмероэ. Прологу присущ ряд свойств, которыми не обладают традиционные языки программирования. К таким свойствам относятся механизм вывода с поиском и возвратом, встроенный механизм сопоставления с образцом и простая, Но выразительная структура данных с возможностью ее изменения. Данные и программы являются лишь двумя различными точками зрения на объекты Пролога. В единой базе данных можно свободно создавать и уничтожать °тДельные элементы. Так как не существует различия между программами и Данными, можно менять программу во время ее работы. В Прологе отсутствуют Указатели, операторы присвоения и перехода. Единственным методом Программирования является рекурсия. Многие интересные и полезные свойства Пролога непосредственно вытекают сг0 декларативности. Рассмотрим некоторые достоинства, обусловливающие пеоспективу использования Пролога для решения задач ИИ, в частности построения экспертных систем и инструментальных средств создания ЭС[6]: 1 Пролог обладает четкой математической основой, базируется на исчислении предикатов первого порядка, что является в некотором роде формализацией человеческого мышления. 2 Существенно упрощается проблема верификации программ. 3 Удобство при работе с реляционными базами данных.В Прологе факты представляются выражениями, в которых константы играют роль термов. Следовательно, множество этих выражений можно рассматривать как реляционную базу данных. 4 Принципы организации вычислений Пролога, параллельные по своей сути, выявляют новую точку зрения на возможную архитектуру машин. 5 Пролог поддерживает вычисления, основанные на поиске через обратную цепочку рассуждений, что довольно эффективно используется при построении ЭС. 6 Использование аппарата унификации как основного средства для сопоставления образцов поддерживает стиль программирования, основанный на предложениях. По сравнению с Прологом большинство языков программирования функционального типа, в частности Лисп, нуждаются в механизме логического вывода для осуществления вычислений, связанных с поиском. Помимо этого существует ряд проблем, для которых функциональные решения или очень сложны или в чем-то недостижимы. Решения же некоторых из этих проблем, выполненные с применением Пролога, относительно элегантны. Главная причина этого состоит в том, что Пролог может хранить промежуточные вычисленные результаты для последующего использования. Основной механизм, облегчающий эту возможность,- понятие "логическая переменная", которая позволяет иметь дело с поисваиванием значений сцепленным переменным в очень естественной манере. Практическая ценность языка Пролог заключается в том, что, подобно тому, как Лисп скрывает от программиста устройство памяти ЭВМ, Пролог позволяет ему не заботиться (без необходимости, конечно) о потоке управления в программе. Как и любой реальный язык программирования Пролог, имеет и некоторые недостатки, подробно рассмотренные в [6,7]. К основным недостаткам, по-видимому, можно отнести следующие: 1. Сложность понимания процесса выполнения программы на Прологе, связанную с некоторой "скрытностью" деталей управляющего механизма. 2 Во встроенном механизме вывода жестко заложен поиск в глубину, что не всегда удобно (приходится дополнительно предусматривать методы изменения поиска). 3. Некоторые из встроенных предикатов дают побочные эффекты. 4. Отсутствие пригодных средств для разбиения пространства предложений Пролога, чтобы улучшить модульность программ. 5. Неэффективность работы при наличии циклов. Продолжаются исследования , направленные на устранение этих и ряда других недостатков языка Пролог. Этот язык в свое время был выбран в качестве базового в японском проекте вычислительных систем пятого поколения. Однако в процессе разработки проекта этот язык пришлось существенно расширить за счет разделов абстрактных типов данных противоречивых логик, нечетких множеств, параллельного вывода и т.д. Особый интерес вызывает использование неопределенных, неточных знаний, так как именно с такого рода информацией приходится сталкиваться в реальных ЭС. Для реализации возможностей обработки неточной, неопределенной информации в системе логического программирования реализованы, по крайней мере, два типа "нечеткого" Пролога [8,9]. Первая реализация [8] предполагает представление неопределенности в виде нечетких истинностей, а вторая с помощью обосновывающих пар, представляющих собой оптимистическую и пессимистическую оценку степени истинности утверждений. В [10] описана реализация "нечеткого" Пролога, являющаяся модификацией варианта из [9], позволяющая оперировать "возможностными" обосновывающими парами. Обзор других реализаций можно найти в [11,18]. В настоящее время, несмотря на конкуренцию со стороны основанных на Лиспе сред для разработки экспертных систем (эти среды имеются, главным образом, только на более дорогих машинах), преимущества Пролога и тот факт, что он легко доступен на более дешевых персональных компьютерах (особенно после появления версии Турбо-Пролог), позволяют стать Прологу наиболее пригодным средством для создания прототипов малых и средних экспертных систем. К началу 90-х годов в нашей стране появился ряд переводных изданий по языку Пролог. Первой по времени и значению была книга У.Кпоксина и К.Меллиша [12], которая по праву считается базовым учебником языка, неофициальным стандартом ядра "чистого" Пролога. Издан ряд книг, ориентированных как на начинающего [13-16], так и на опытного программиста [1,17,18]. В [19] систематизированно излагается формируемый в настоящее время стандарт языка Пролог и основные методы, широко используемые при написании прикладных программ на Прологе (так называемый «инструментальный ящик программиста»). Описание и сравнительные характеристики различных версий языка Пролог можно найти в [1,12,20]. В работах [6,21,22] описывается реализация языка Турбо-Пролог (компилятор Пролога с контролем типов данных, содержащий все характеристики интерпретатора Пролога, описанного в работе [12], но обладающий гораздо более высоким быстродействием). Концепции, заложенные в иные формализмы представления знаний (реализация фрейм-программ и семантических сетей), другие стратегии решения задач, различные виды интерфейсов с пользователем - все это можно реализовать на Прологе [1]. Тем не менее, программную часть экспертной системы можно написать практически на любом алгоритмическом языке высокого уровня. Все дело заключается во времени и усилиях, затраченных на создание и отладку программы. С точки зрения практики для каждого языка существует своя методология программирования. Любой язык программирования вбирает в себя современные ему идеи, систематизирующие и облегчающие труд программиста. Попытка создания качественного программного обеспечения ЭС на базе какого-либо одного языка программирования приводит, как правило, к выбору неадекватных средств при решении конкретных задач, и, как следствие, к громоздкости описаний и к неэффективности. В такой ситуации создание качественного программного обеспечения базируется на многоязыковом программировании, в котором можно условно выделить ряд направлений: программирование с заменой, когда неэффективные программы перепрограммируются на языке боле низкого уровня; программирование, ориентированное по видам обрабатываемых данных; Функционально-ориентированное программирование, когда выделены взаимодействующие языки, выполняющие конкретные функции процесса решения 3&дачи; объектно-ориентированное программирование и т.д. Многоязыковое программирование позволяет разумно сочетать сильные стороны языков программирования и выявлять тпик™ „* уровне описания. выявлять ошибки на соответствующем Поэтому весьма перспективным является совместное использование алгоритмического языка высокого уровня, например СИ и Пролога. При этом на СИ возлагаются процедурные функции, построение оболочки и создание интерфейса. На откуп Прологу отдаются логический вывод и работа с базой знаний, а также анализ и синтез естественно-языковых конструкций при общении пользователя и экспертной системы. Сочетание универсальности СИ с "интеллектуальными возможностями Пролога делает возможным создание очень высокопроизводительных инструментальных систем. Версия Турбо-Пролог является интегрированной системой. Модули на Прологе, СИ, а также Ассемблере могут быть объединены на этапе редактирования В заключение следует отметить, что использование существующих и "«пе^7систеГбудТюа“но^ ГрГ,”ГМ °* 0“0,Н“ ”“Д'"и""Х 1т,ИТ"’ ^™т>ы ЭВМ можно ]]></text>
</doc>
